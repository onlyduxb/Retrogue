"""Overworld generator."""

# -- Imports

import math
import random
from collections import deque


def hash_function(coordinates: tuple[int, int]):
    """Hash function for seed generation."""
    x = coordinates[0]
    y = coordinates[1]
    x **= 2
    y **= 2
    x_len = len(str(abs(x)))
    y_len = len(str(abs(y)))
    x_half = str(x)[0 : x_len // 2]
    y_half = str(y)[0 : y_len // 2]
    try:
        return int(x_half + y_half)
    except:
        return random.randint(100, 10000)


def poisson_disk_sampling(
    map_,
    map_size,
    POISSION_K_VALUE,  # noqa: N803
    POISSON_RADIUS,  # noqa: N803
    coordinates=(random.randint(1000, 100000), random.randint(1000, 100000)),
    debug_character=" x ",
):
    """Use poisson disk sampling to generate a set of points where towns and dungeons can be created."""
    random.seed(hash_function(coordinates))  # Seed generated by hash function
    points = []  # Generated points list
    active_points = []  # Active points list
    first_point = (map_size // 2, map_size // 2)  # First point at the center of the map
    points.append(first_point)  # Append the first point to the point array
    active_points.append(first_point)  # Appened the first point

    def calculate_dist(p1, p2):
        """Calculate the distance between two points."""
        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

    def generate_candidate():
        """Generate a candidate for PDS."""
        random.seed(hash_function(coordinates))  # Use the same seed
        random_point = random.choice(
            active_points
        )  # Choose a random point in the active points
        current_point_valid_candidates = 0  # Number of valid 'candidates'
        for i in range(POISSION_K_VALUE):  # K value is the number
            valid = True
            while True:
                random_distance = random.uniform(
                    POISSON_RADIUS, 2 * POISSON_RADIUS
                )  # Select a random distance
                theta = random.uniform(0, 2 * math.pi)  # Create a random angle
                random_candidate_position = (
                    random_point[0]
                    + (
                        random_distance * math.cos(theta)
                    ),  # Travel a random distance along the x direction
                    random_point[1]
                    + (
                        random_distance * math.sin(theta)
                    ),  # Travel a random distance along the y direction
                )
                if (
                    0 <= random_candidate_position[0] < map_size
                    and 0 <= random_candidate_position[1] < map_size
                ):  # Bound safety
                    break
            for point in points:
                if calculate_dist(point, random_candidate_position) < POISSON_RADIUS:
                    valid = False  # Point too close
            if valid:
                current_point_valid_candidates += 1  # Point marked as valid
                points.append(
                    (
                        int(random_candidate_position[0]),
                        int(random_candidate_position[1]),
                    )  # If the point is valid add to points
                )
                active_points.append(random_candidate_position)  # Add to active points
        if current_point_valid_candidates == 0:
            active_points.remove(
                random_point
            )  # If there is no more active points remove the generated points

    while len(active_points) != 0:
        generate_candidate()
    for point in points:
        map_[point[0]][
            point[1]
        ] = debug_character  # Marks all poi points with a debug character (default x)
    return map_, points


class Town:
    """Town.

    ## Description
    Towns are complete with buildings including: Inns and Shops. Where items could be purchased. More to be added later.
    ## Attributes
    ```
    self.debugger: Debugger # Debugger
    self.coordinates: tuple[int, int] # Coordinates of town
    self.sizes: dict[str, int] # Sizes of towns with their names (Hamlet / village)
    probability_town_size: list[float] # Probability of each town size
    self.type: str # Type of town
    self.POISSION_k_value: int # K value
    self.POISSON_RADIUS: float # Radius
    self.grass_char: str # Grass character
    self.road_char: str # Road character
    self.house_positions: list[tuple[int, int]] # Cooridinates of houses
    self.town_layout: list[list[str]] # Layout of town
    self.house_positions: dict[tuple[int, int], str] # Positions of buildings with the building type
    ```
    ## Methods
    ```
    get_house_positions(self) # Return the building positions.
    get_road_pos(self) # Return the positions of the roads.
    set_houses(self) # Set the positions of the buildings in towns.
    get_adjacent_grass(self, pos) # Get the positions of grass chars adjacent to a position.
    set_paths(self) # Create paths between houses.
    print_town(self) # Print town.
    ```
    """

    def __init__(
        self,
        debugger,
        coordinates: tuple[int, int] = (0, 0),
        grass_char: str = " . ",
        road_char: str = " = ",
    ) -> None:
        """Initialise town."""
        self.debugger = debugger  # Debugger
        self.coordinates = coordinates  # Coordinates of town
        self.sizes = {
            "Hamlet": 10,
            "Village": 20,
        }  # Sizes of towns with their names (Hamlet / village)

        probability_town_size = [0.75, 0.25]  # Probability of each town size
        self.type = random.choices(
            [size for size in self.sizes.keys()], weights=probability_town_size, k=1
        )[
            0
        ]  # Type of town

        self.POISSION_k_value = 20
        self.POISSON_RADIUS = self.sizes[self.type] / 5

        self.grass_char = grass_char
        self.road_char = road_char
        self.house_positions = []
        self.town_layout = [
            [self.grass_char for i in range(self.sizes[self.type])]
            for i in range(self.sizes[self.type])
        ]
        self.town_layout, self.house_positions = poisson_disk_sampling(
            self.town_layout,
            len(self.town_layout) - 1,
            POISSION_K_VALUE=10,
            POISSON_RADIUS=5,
            coordinates=coordinates,
            debug_character=" t ",
        )
        # Deduplicate house positions created by integer rounding in PDS
        self.house_positions = list(
            {(int(p[0]), int(p[1])) for p in self.house_positions}
        )
        self.building_positions = {}
        self.set_paths()
        self.set_houses()

    def get_house_positions(self):
        """Return the building positions."""
        return self.house_positions

    def get_road_pos(self):
        """Return the positions of the roads."""
        road_positions = []
        for row_index, row in enumerate(self.town_layout):
            for element_index, element in enumerate(row):
                if element == self.road_char:
                    road_positions.append((row_index, element_index))
        return road_positions

    def set_houses(self):
        """Set the positions of the buildings in towns."""
        generator = OverworldHouseGeneration()
        for house_pos in self.house_positions:
            house_char = generator.generate_house()
            self.town_layout[house_pos[0]][house_pos[1]] = house_char
            self.building_positions[house_pos] = house_char

    def get_adjacent_grass(self, pos):
        """Return a safe adjacent grass tile; fall back to original pos."""
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        candidates = []
        for dx, dy in directions:
            nx, ny = pos[0] + dx, pos[1] + dy
            if 0 <= nx < len(self.town_layout) and 0 <= ny < len(self.town_layout[0]):
                if self.town_layout[nx][ny] == self.grass_char:
                    candidates.append((nx, ny))
        if candidates:
            return candidates[0]
        return pos

    def set_paths(self):
        """Create paths between houses."""

        def get_closest_house(start):
            """Get the closest house from some start house."""

            def dist(start, finish):
                """Return the distance between two houses."""
                return math.sqrt(
                    (start[0] - finish[0]) ** 2 + (start[1] - finish[1]) ** 2
                )

            min_dist = float("inf")
            closest = (float("inf"), float("inf"))
            for house in self.house_positions:
                s = dist(start, house)
                if s < min_dist and s != 0:
                    min_dist = s
                    closest = house
            return closest

        def bfs_path(self, start, end):
            """Use bfs to pathfind between two buildings to create a path."""
            rows, cols = len(self.town_layout), len(self.town_layout[0])
            queue = deque([start])
            visited = {}
            visited[start] = None
            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

            while queue:
                x, y = queue.popleft()
                if (x, y) == end:
                    break
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < rows and 0 <= ny < cols:
                        if (nx, ny) not in visited and self.town_layout[nx][
                            ny
                        ] == self.grass_char:
                            visited[(nx, ny)] = (x, y)
                            queue.append((nx, ny))

            if end not in visited:
                return []

            path = []
            node = end
            while node is not None:
                path.append(node)
                node = visited[node]
            path.reverse()
            return path

        paths_generated = []

        for house in self.house_positions:
            start = self.get_adjacent_grass(house)
            target_house = get_closest_house(house)
            end = self.get_adjacent_grass(target_house)
            if not start in paths_generated:
                road = bfs_path(self, start, end)
                paths_generated.append(start)
                paths_generated.append(end)

                # Fallback Manhattan path if BFS fails
                if not road:
                    x0, y0 = start
                    x1, y1 = end
                    fallback = []
                    # horizontal first
                    step = 1 if y1 > y0 else -1
                    for y in range(y0, y1 + step, step):  # type: ignore
                        fallback.append((x0, y))
                    # vertical second
                    step = 1 if x1 > x0 else -1
                    for x in range(x0, x1 + step, step):  # type: ignore
                        fallback.append((x, y1))
                    road = fallback

                for step in road:
                    self.town_layout[step[0]][step[1]] = self.road_char

    def print_town(self):
        """Print town."""
        for row in self.town_layout:
            print("".join(row))


class OverworldHouseGeneration:
    """Overworld house generation.

    ## Description
    Generate houses for the overworld.
    ## Attributes
    self.empty_char: str # Empty character
    self.wall_char: str # Wall character
    self.door_char: str # Door character
    self.npc_char: str # NPC character
    self.bench_char: str # Bench character
    ## Methods
    ```
    generate_house(self) # Return a house type.
    ```
    """

    def __init__(
        self,
        empty_char=" _ ",
        wall_char=" # ",
        door_char=" / ",
        bench_char=" $ ",
        npc_char=" X ",
    ) -> None:
        """Initialise House generation."""
        self.empty_char = empty_char
        self.wall_char = wall_char
        self.door_char = door_char
        self.npc_char = npc_char
        self.bench_char = bench_char

    def generate_house(self):
        """Return a house type."""
        return random.choice([" I ", " S "])


class House:
    """House.

    ## Description
    Base class for houses.
    ## Attributes
    ```
    self.empty_char: str # Empty character
    self.wall_char: str # Wall character
    self.door_char: str # Door character
    self.npc_char: str # NPC character
    self.bench_char: str # Bench character
    self.house_char: str # House char
    self.layout: list[list[str]] # House layout
    self.PLAYER: Player # Player object
    self.player_pos: tuple[int, int] # Player position
    ```
    ## Methods
    ```
    place_player(self) # Place the player at the enterance of the building.
    ```
    """

    def __init__(
        self,
        player,
        house_char=" H ",
        empty_char=" _ ",
        wall_char=" # ",
        door_char=" / ",
        bench_char=" $ ",
        npc_char=" X ",
    ) -> None:
        """Initialise house."""
        self.empty_char = empty_char
        self.wall_char = wall_char
        self.door_char = door_char
        self.npc_char = npc_char
        self.bench_char = bench_char
        self.house_char = house_char
        self.layout = []
        self.PLAYER = player
        self.player_pos: tuple[int, int] = (5, 3)

    def place_player(self):
        """Place the player at the enterance of the building."""
        self.layout[self.player_pos[0]][self.player_pos[1]] = self.PLAYER.char


class InnGenerator(House):
    """Inn generator.

    ## Description
    Generates an Inn.
    ## Attributes
    ```
    self.empty_char: str # Empty character
    self.wall_char: str # Wall character
    self.door_char: str # Door character
    self.npc_char: str # NPC character
    self.bench_char: str # Bench character
    self.house_char: str # House char
    self.layout: list[list[str]] # House layout
    self.PLAYER: Player # Player object
    self.player_pos: tuple[int, int] # Player position
    ```
    ## Methods
    """

    def __init__(
        self,
        player,
        house_char=" I ",
        empty_char=" _ ",
        wall_char=" # ",
        door_char=" / ",
        bench_char=" $ ",
        npc_char=" X ",
    ) -> None:
        """Initialise inn."""
        super().__init__(
            player, house_char, empty_char, wall_char, door_char, bench_char, npc_char
        )
        self.layout = [
            [
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.bench_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.bench_char,
                self.npc_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.bench_char,
                self.bench_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.door_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
            ],
        ]
        self.place_player()


class ShopGenerator(House):
    """Shop generator.

    ## Description
    Generates a shop.
    ## Attributes
    ```
    self.empty_char: str # Empty character
    self.wall_char: str # Wall character
    self.door_char: str # Door character
    self.npc_char: str # NPC character
    self.bench_char: str # Bench character
    self.house_char: str # House char
    self.layout: list[list[str]] # House layout
    self.PLAYER: Player # Player object
    self.player_pos: tuple[int, int] # Player position
    ```
    ## Methods
    """

    def __init__(
        self,
        player,
        house_char=" S ",
        empty_char=" _ ",
        wall_char=" # ",
        door_char=" / ",
        bench_char=" $ ",
        npc_char=" X ",
    ) -> None:
        """Initialise shop."""
        super().__init__(
            player, house_char, empty_char, wall_char, door_char, bench_char, npc_char
        )
        self.layout = [
            [
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.bench_char,
                self.bench_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.npc_char,
                self.bench_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.empty_char,
                self.wall_char,
            ],
            [
                self.wall_char,
                self.wall_char,
                self.wall_char,
                self.door_char,
                self.wall_char,
                self.wall_char,
                self.wall_char,
            ],
        ]
        self.place_player()


# --- OVERWORLD ---


class OverworldGeneration:
    """Overworld generator.

    ## Description
    Generates the overworld.
    ## Attributes
    ```
    self.debugger: Debugger # Debugger
    self.coordinates tuple[int, int] # Coordinates of the overwor;d
    self.road_char: str # Road character
    self.grass_char: str # Grass character
    self.dungeon_char: str # Dungeon character
    self.seed: int # Seed for randomisation consistency
    self.map_size: int # Map size
    self.map: list[list[str]] # Map list
    self.POISSION_k_value: int: # K value
    self.POISSON_RADIUS: float: # Radius
    self.poi_info: dict[tuple[int, int], str] # Stores PoI info
    self.building_info: dict[tuple[int, int], str] # Stores building info
    ```
    ## Methods
    ```
    generate_map(self) # Return the generated map.
    get_poi_coordinates(self) # Return the poi coordinates.
    get_poi_info(self) -> dict[tuple[int, int], str] # Return the poi info.
    get_building_info(self) # Return building info.
    add_dungeon(self, coordinates) # Add a dungeon.
    add_town(self, coordinates) # Add a town.
    print_map(self) # Print the map.
    ```
    """

    def __init__(
        self,
        debugger,
        coordinates: tuple[int, int] = (1, 1),
        road_char: str = " = ",
        grass_char: str = " . ",
        dungeon_char=" Î” ",
        map_size: int = 50,
    ) -> None:
        """Initialise overworld generation."""
        self.debugger = debugger  # Debugger
        self.coordinates = coordinates  # Coordinates
        self.road_char = road_char  # Road character
        self.grass_char = grass_char  # Grass character
        self.dungeon_char = dungeon_char  # Dungeon character
        self.debugger.write(
            f"Generating overworld with coordinates {self.coordinates}"
        )  # Debug statement
        self.seed = hash_function(coordinates)  # Hashes coordinates for seed
        self.map_size = map_size  # Map size
        self.map = [
            [self.grass_char for i in range(self.map_size)]
            for i in range(self.map_size)
        ]  # Map
        random.seed(self.seed)
        self.POISSION_k_value = 20
        self.POISSON_RADIUS = 20
        self.map, self.poi_coordinates = poisson_disk_sampling(
            self.map,
            self.map_size,
            self.POISSION_k_value,
            self.POISSON_RADIUS,
            self.coordinates,
            debug_character=self.grass_char,
        )
        pois = [self.add_dungeon, self.add_town]
        probabilities = [0.25, 0.75]
        self.poi_info = {}
        self.building_info = {}
        for poi in self.poi_coordinates:
            add_poi = random.choices(pois, weights=probabilities, k=1)[0]
            add_poi(coordinates=poi)

    def generate_map(self):
        """Return the generated map."""
        return self.map

    def get_poi_coordinates(self):
        """Return the poi coordinates."""
        return self.poi_coordinates

    def get_poi_info(self) -> dict[tuple[int, int], str]:
        """Return the poi info."""
        return self.poi_info

    def get_building_info(self):
        """Return building info."""
        return self.building_info

    def add_dungeon(self, coordinates):
        """Add a dungeon."""
        self.debugger.write(f"Generating Dungeon at coordinates {coordinates}")
        self.char = self.dungeon_char
        self.poi_info[coordinates] = self.char
        self.map[coordinates[0]][coordinates[1]] = self.char

    def add_town(self, coordinates):
        """Add a town."""
        self.debugger.write(f"Generating Town at coordinates {coordinates}")
        self.char = " T "
        self.poi_info[coordinates] = self.char
        town = Town(
            debugger=self.debugger,
            coordinates=coordinates,
            grass_char=self.grass_char,
            road_char=self.road_char,
        )
        for i, row in enumerate(town.town_layout):
            for j, ele in enumerate(row):
                if (
                    town.coordinates[0] + i < self.map_size
                    and town.coordinates[1] + j < self.map_size
                ):
                    if ele not in [self.grass_char]:
                        self.map[town.coordinates[0] + i][town.coordinates[1] + j] = ele
                        if ele in [" S ", " I "]:
                            self.building_info[
                                (town.coordinates[0] + i, town.coordinates[1] + j)
                            ] = ele

    def print_map(self):
        """Print the map."""
        for row in self.map:
            print("".join(row))
