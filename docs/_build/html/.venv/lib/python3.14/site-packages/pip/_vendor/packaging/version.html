

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>This file is dual licensed under the terms of the Apache License, Version &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">This file is dual licensed under the terms of the Apache License, Version</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/version.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version">
<h1>This file is dual licensed under the terms of the Apache License, Version<a class="headerlink" href="#this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version" title="Link to this heading"></a></h1>
</section>
<section id="and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository">
<h1>2.0, and the BSD License. See the LICENSE file in the root of this repository<a class="headerlink" href="#and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository" title="Link to this heading"></a></h1>
</section>
<section id="for-complete-details">
<h1>for complete details.<a class="headerlink" href="#for-complete-details" title="Link to this heading"></a></h1>
<p>“””
.. testsetup::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pip._vendor.packaging.version import parse, Version
</pre></div>
</div>
<p>“””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import itertools
import re
from typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union</p>
<p>from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType</p>
<p><strong>all</strong> = [“VERSION_PATTERN”, “InvalidVersion”, “Version”, “parse”]</p>
<p>LocalType = Tuple[Union[int, str], …]</p>
<p>CmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]
CmpLocalType = Union[
NegativeInfinityType,
Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], …],
]
CmpKey = Tuple[
int,
Tuple[int, …],
CmpPrePostDevType,
CmpPrePostDevType,
CmpPrePostDevType,
CmpLocalType,
]
VersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]</p>
<p>class _Version(NamedTuple):
epoch: int
release: tuple[int, …]
dev: tuple[str, int] | None
pre: tuple[str, int] | None
post: tuple[str, int] | None
local: LocalType | None</p>
<p>def parse(version: str) -&gt; Version:
“””Parse the given version string.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; parse(&#39;1.0.dev1&#39;)
&lt;Version(&#39;1.0.dev1&#39;)&gt;

:param version: The version string to parse.
:raises InvalidVersion: When the version string is not a valid version.
&quot;&quot;&quot;
return Version(version)
</pre></div>
</div>
<p>class InvalidVersion(ValueError):
“””Raised when a version string is not a valid version.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; Version(&quot;invalid&quot;)
Traceback (most recent call last):
    ...
packaging.version.InvalidVersion: Invalid version: &#39;invalid&#39;
&quot;&quot;&quot;
</pre></div>
</div>
<p>class _BaseVersion:
_key: tuple[Any, …]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __hash__(self) -&gt; int:
    return hash(self._key)

# Please keep the duplicated `isinstance` check
# in the six comparisons hereunder
# unless you find a way to avoid adding overhead function calls.
def __lt__(self, other: _BaseVersion) -&gt; bool:
    if not isinstance(other, _BaseVersion):
        return NotImplemented

    return self._key &lt; other._key

def __le__(self, other: _BaseVersion) -&gt; bool:
    if not isinstance(other, _BaseVersion):
        return NotImplemented

    return self._key &lt;= other._key

def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, _BaseVersion):
        return NotImplemented

    return self._key == other._key

def __ge__(self, other: _BaseVersion) -&gt; bool:
    if not isinstance(other, _BaseVersion):
        return NotImplemented

    return self._key &gt;= other._key

def __gt__(self, other: _BaseVersion) -&gt; bool:
    if not isinstance(other, _BaseVersion):
        return NotImplemented

    return self._key &gt; other._key

def __ne__(self, other: object) -&gt; bool:
    if not isinstance(other, _BaseVersion):
        return NotImplemented

    return self._key != other._key
</pre></div>
</div>
</section>
<section id="deliberately-not-anchored-to-the-start-and-end-of-the-string-to-make-it">
<h1>Deliberately not anchored to the start and end of the string, to make it<a class="headerlink" href="#deliberately-not-anchored-to-the-start-and-end-of-the-string-to-make-it" title="Link to this heading"></a></h1>
</section>
<section id="easier-for-3rd-party-code-to-reuse">
<h1>easier for 3rd party code to reuse<a class="headerlink" href="#easier-for-3rd-party-code-to-reuse" title="Link to this heading"></a></h1>
<p><em>VERSION_PATTERN = r”””
v?
(?:
(?:(?P<epoch>[0-9]+)!)?                           # epoch
(?P<release>[0-9]+(?:.[0-9]+)*)                  # release segment
(?P<pre>                                          # pre-release
[-</em>.]?
(?P&lt;pre_l&gt;alpha|a|beta|b|preview|pre|c|rc)
[-<em>.]?
(?P&lt;pre_n&gt;[0-9]+)?
)?
(?P<post>                                         # post release
(?:-(?P&lt;post_n1&gt;[0-9]+))
|
(?:
[-</em>.]?
(?P&lt;post_l&gt;post|rev|r)
[-<em>.]?
(?P&lt;post_n2&gt;[0-9]+)?
)
)?
(?P<dev>                                          # dev release
[-</em>.]?
(?P&lt;dev_l&gt;dev)
[-<em>.]?
(?P&lt;dev_n&gt;[0-9]+)?
)?
)
(?:+(?P<local>[a-z0-9]+(?:[-</em>.][a-z0-9]+)*))?       # local version
“””</p>
<p>VERSION_PATTERN = _VERSION_PATTERN
“””
A string containing the regular expression used to match a valid version.</p>
<p>The pattern is not anchored at either end, and is intended for embedding in larger
expressions (for example, matching a version number as part of a file name). The
regular expression should be compiled with the <code class="docutils literal notranslate"><span class="pre">re.VERBOSE</span></code> and <code class="docutils literal notranslate"><span class="pre">re.IGNORECASE</span></code>
flags set.</p>
<p>:meta hide-value:
“””</p>
<p>class Version(_BaseVersion):
“””This class abstracts handling of a project’s versions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A :class:`Version` instance is comparison aware and can be compared and
sorted using the standard Python interfaces.

&gt;&gt;&gt; v1 = Version(&quot;1.0a5&quot;)
&gt;&gt;&gt; v2 = Version(&quot;1.0&quot;)
&gt;&gt;&gt; v1
&lt;Version(&#39;1.0a5&#39;)&gt;
&gt;&gt;&gt; v2
&lt;Version(&#39;1.0&#39;)&gt;
&gt;&gt;&gt; v1 &lt; v2
True
&gt;&gt;&gt; v1 == v2
False
&gt;&gt;&gt; v1 &gt; v2
False
&gt;&gt;&gt; v1 &gt;= v2
False
&gt;&gt;&gt; v1 &lt;= v2
True
&quot;&quot;&quot;

_regex = re.compile(r&quot;^\s*&quot; + VERSION_PATTERN + r&quot;\s*$&quot;, re.VERBOSE | re.IGNORECASE)
_key: CmpKey

def __init__(self, version: str) -&gt; None:
    &quot;&quot;&quot;Initialize a Version object.

    :param version:
        The string representation of a version which will be parsed and normalized
        before use.
    :raises InvalidVersion:
        If the ``version`` does not conform to PEP 440 in any way then this
        exception will be raised.
    &quot;&quot;&quot;

    # Validate the version and parse it into pieces
    match = self._regex.search(version)
    if not match:
        raise InvalidVersion(f&quot;Invalid version: {version!r}&quot;)

    # Store the parsed out pieces of the version
    self._version = _Version(
        epoch=int(match.group(&quot;epoch&quot;)) if match.group(&quot;epoch&quot;) else 0,
        release=tuple(int(i) for i in match.group(&quot;release&quot;).split(&quot;.&quot;)),
        pre=_parse_letter_version(match.group(&quot;pre_l&quot;), match.group(&quot;pre_n&quot;)),
        post=_parse_letter_version(
            match.group(&quot;post_l&quot;), match.group(&quot;post_n1&quot;) or match.group(&quot;post_n2&quot;)
        ),
        dev=_parse_letter_version(match.group(&quot;dev_l&quot;), match.group(&quot;dev_n&quot;)),
        local=_parse_local_version(match.group(&quot;local&quot;)),
    )

    # Generate a key which will be used for sorting
    self._key = _cmpkey(
        self._version.epoch,
        self._version.release,
        self._version.pre,
        self._version.post,
        self._version.dev,
        self._version.local,
    )

def __repr__(self) -&gt; str:
    &quot;&quot;&quot;A representation of the Version that shows all internal state.

    &gt;&gt;&gt; Version(&#39;1.0.0&#39;)
    &lt;Version(&#39;1.0.0&#39;)&gt;
    &quot;&quot;&quot;
    return f&quot;&lt;Version(&#39;{self}&#39;)&gt;&quot;

def __str__(self) -&gt; str:
    &quot;&quot;&quot;A string representation of the version that can be round-tripped.

    &gt;&gt;&gt; str(Version(&quot;1.0a5&quot;))
    &#39;1.0a5&#39;
    &quot;&quot;&quot;
    parts = []

    # Epoch
    if self.epoch != 0:
        parts.append(f&quot;{self.epoch}!&quot;)

    # Release segment
    parts.append(&quot;.&quot;.join(str(x) for x in self.release))

    # Pre-release
    if self.pre is not None:
        parts.append(&quot;&quot;.join(str(x) for x in self.pre))

    # Post-release
    if self.post is not None:
        parts.append(f&quot;.post{self.post}&quot;)

    # Development release
    if self.dev is not None:
        parts.append(f&quot;.dev{self.dev}&quot;)

    # Local version segment
    if self.local is not None:
        parts.append(f&quot;+{self.local}&quot;)

    return &quot;&quot;.join(parts)

@property
def epoch(self) -&gt; int:
    &quot;&quot;&quot;The epoch of the version.

    &gt;&gt;&gt; Version(&quot;2.0.0&quot;).epoch
    0
    &gt;&gt;&gt; Version(&quot;1!2.0.0&quot;).epoch
    1
    &quot;&quot;&quot;
    return self._version.epoch

@property
def release(self) -&gt; tuple[int, ...]:
    &quot;&quot;&quot;The components of the &quot;release&quot; segment of the version.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).release
    (1, 2, 3)
    &gt;&gt;&gt; Version(&quot;2.0.0&quot;).release
    (2, 0, 0)
    &gt;&gt;&gt; Version(&quot;1!2.0.0.post0&quot;).release
    (2, 0, 0)

    Includes trailing zeroes but not the epoch or any pre-release / development /
    post-release suffixes.
    &quot;&quot;&quot;
    return self._version.release

@property
def pre(self) -&gt; tuple[str, int] | None:
    &quot;&quot;&quot;The pre-release segment of the version.

    &gt;&gt;&gt; print(Version(&quot;1.2.3&quot;).pre)
    None
    &gt;&gt;&gt; Version(&quot;1.2.3a1&quot;).pre
    (&#39;a&#39;, 1)
    &gt;&gt;&gt; Version(&quot;1.2.3b1&quot;).pre
    (&#39;b&#39;, 1)
    &gt;&gt;&gt; Version(&quot;1.2.3rc1&quot;).pre
    (&#39;rc&#39;, 1)
    &quot;&quot;&quot;
    return self._version.pre

@property
def post(self) -&gt; int | None:
    &quot;&quot;&quot;The post-release number of the version.

    &gt;&gt;&gt; print(Version(&quot;1.2.3&quot;).post)
    None
    &gt;&gt;&gt; Version(&quot;1.2.3.post1&quot;).post
    1
    &quot;&quot;&quot;
    return self._version.post[1] if self._version.post else None

@property
def dev(self) -&gt; int | None:
    &quot;&quot;&quot;The development number of the version.

    &gt;&gt;&gt; print(Version(&quot;1.2.3&quot;).dev)
    None
    &gt;&gt;&gt; Version(&quot;1.2.3.dev1&quot;).dev
    1
    &quot;&quot;&quot;
    return self._version.dev[1] if self._version.dev else None

@property
def local(self) -&gt; str | None:
    &quot;&quot;&quot;The local version segment of the version.

    &gt;&gt;&gt; print(Version(&quot;1.2.3&quot;).local)
    None
    &gt;&gt;&gt; Version(&quot;1.2.3+abc&quot;).local
    &#39;abc&#39;
    &quot;&quot;&quot;
    if self._version.local:
        return &quot;.&quot;.join(str(x) for x in self._version.local)
    else:
        return None

@property
def public(self) -&gt; str:
    &quot;&quot;&quot;The public portion of the version.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).public
    &#39;1.2.3&#39;
    &gt;&gt;&gt; Version(&quot;1.2.3+abc&quot;).public
    &#39;1.2.3&#39;
    &gt;&gt;&gt; Version(&quot;1!1.2.3dev1+abc&quot;).public
    &#39;1!1.2.3.dev1&#39;
    &quot;&quot;&quot;
    return str(self).split(&quot;+&quot;, 1)[0]

@property
def base_version(self) -&gt; str:
    &quot;&quot;&quot;The &quot;base version&quot; of the version.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).base_version
    &#39;1.2.3&#39;
    &gt;&gt;&gt; Version(&quot;1.2.3+abc&quot;).base_version
    &#39;1.2.3&#39;
    &gt;&gt;&gt; Version(&quot;1!1.2.3dev1+abc&quot;).base_version
    &#39;1!1.2.3&#39;

    The &quot;base version&quot; is the public version of the project without any pre or post
    release markers.
    &quot;&quot;&quot;
    parts = []

    # Epoch
    if self.epoch != 0:
        parts.append(f&quot;{self.epoch}!&quot;)

    # Release segment
    parts.append(&quot;.&quot;.join(str(x) for x in self.release))

    return &quot;&quot;.join(parts)

@property
def is_prerelease(self) -&gt; bool:
    &quot;&quot;&quot;Whether this version is a pre-release.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).is_prerelease
    False
    &gt;&gt;&gt; Version(&quot;1.2.3a1&quot;).is_prerelease
    True
    &gt;&gt;&gt; Version(&quot;1.2.3b1&quot;).is_prerelease
    True
    &gt;&gt;&gt; Version(&quot;1.2.3rc1&quot;).is_prerelease
    True
    &gt;&gt;&gt; Version(&quot;1.2.3dev1&quot;).is_prerelease
    True
    &quot;&quot;&quot;
    return self.dev is not None or self.pre is not None

@property
def is_postrelease(self) -&gt; bool:
    &quot;&quot;&quot;Whether this version is a post-release.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).is_postrelease
    False
    &gt;&gt;&gt; Version(&quot;1.2.3.post1&quot;).is_postrelease
    True
    &quot;&quot;&quot;
    return self.post is not None

@property
def is_devrelease(self) -&gt; bool:
    &quot;&quot;&quot;Whether this version is a development release.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).is_devrelease
    False
    &gt;&gt;&gt; Version(&quot;1.2.3.dev1&quot;).is_devrelease
    True
    &quot;&quot;&quot;
    return self.dev is not None

@property
def major(self) -&gt; int:
    &quot;&quot;&quot;The first item of :attr:`release` or ``0`` if unavailable.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).major
    1
    &quot;&quot;&quot;
    return self.release[0] if len(self.release) &gt;= 1 else 0

@property
def minor(self) -&gt; int:
    &quot;&quot;&quot;The second item of :attr:`release` or ``0`` if unavailable.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).minor
    2
    &gt;&gt;&gt; Version(&quot;1&quot;).minor
    0
    &quot;&quot;&quot;
    return self.release[1] if len(self.release) &gt;= 2 else 0

@property
def micro(self) -&gt; int:
    &quot;&quot;&quot;The third item of :attr:`release` or ``0`` if unavailable.

    &gt;&gt;&gt; Version(&quot;1.2.3&quot;).micro
    3
    &gt;&gt;&gt; Version(&quot;1&quot;).micro
    0
    &quot;&quot;&quot;
    return self.release[2] if len(self.release) &gt;= 3 else 0
</pre></div>
</div>
<p>class _TrimmedRelease(Version):
&#64;property
def release(self) -&gt; tuple[int, …]:
“””
Release segment without any trailing zeros.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    &gt;&gt;&gt; _TrimmedRelease(&#39;1.0.0&#39;).release
    (1,)
    &gt;&gt;&gt; _TrimmedRelease(&#39;0.0&#39;).release
    (0,)
    &quot;&quot;&quot;
    rel = super().release
    nonzeros = (index for index, val in enumerate(rel) if val)
    last_nonzero = max(nonzeros, default=0)
    return rel[: last_nonzero + 1]
</pre></div>
</div>
<p>def _parse_letter_version(
letter: str | None, number: str | bytes | SupportsInt | None
) -&gt; tuple[str, int] | None:
if letter:
# We consider there to be an implicit 0 in a pre-release if there is
# not a numeral associated with it.
if number is None:
number = 0</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    # We normalize any letters to their lower case form
    letter = letter.lower()

    # We consider some words to be alternate spellings of other words and
    # in those cases we want to normalize the spellings to our preferred
    # spelling.
    if letter == &quot;alpha&quot;:
        letter = &quot;a&quot;
    elif letter == &quot;beta&quot;:
        letter = &quot;b&quot;
    elif letter in [&quot;c&quot;, &quot;pre&quot;, &quot;preview&quot;]:
        letter = &quot;rc&quot;
    elif letter in [&quot;rev&quot;, &quot;r&quot;]:
        letter = &quot;post&quot;

    return letter, int(number)

assert not letter
if number:
    # We assume if we are given a number, but we are not given a letter
    # then this is using the implicit post release syntax (e.g. 1.0-1)
    letter = &quot;post&quot;

    return letter, int(number)

return None
</pre></div>
</div>
<p><em>local_version_separators = re.compile(r”[.</em>-]”)</p>
<p>def _parse_local_version(local: str | None) -&gt; LocalType | None:
“””
Takes a string like abc.1.twelve and turns it into (“abc”, 1, “twelve”).
“””
if local is not None:
return tuple(
part.lower() if not part.isdigit() else int(part)
for part in _local_version_separators.split(local)
)
return None</p>
<p>def _cmpkey(
epoch: int,
release: tuple[int, …],
pre: tuple[str, int] | None,
post: tuple[str, int] | None,
dev: tuple[str, int] | None,
local: LocalType | None,
) -&gt; CmpKey:
# When we compare a release version, we want to compare it with all of the
# trailing zeros removed. So we’ll use a reverse the list, drop all the now
# leading zeros until we come to something non zero, then take the rest
# re-reverse it back into the correct order and make it a tuple and use
# that for our sorting key.
_release = tuple(
reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))
)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># We need to &quot;trick&quot; the sorting algorithm to put 1.0.dev0 before 1.0a0.
# We&#39;ll do this by abusing the pre segment, but we _only_ want to do this
# if there is not a pre or a post segment. If we have one of those then
# the normal sorting rules will handle this case correctly.
if pre is None and post is None and dev is not None:
    _pre: CmpPrePostDevType = NegativeInfinity
# Versions without a pre-release (except as noted above) should sort after
# those with one.
elif pre is None:
    _pre = Infinity
else:
    _pre = pre

# Versions without a post segment should sort before those with one.
if post is None:
    _post: CmpPrePostDevType = NegativeInfinity

else:
    _post = post

# Versions without a development segment should sort after those with one.
if dev is None:
    _dev: CmpPrePostDevType = Infinity

else:
    _dev = dev

if local is None:
    # Versions without a local segment should sort before those with one.
    _local: CmpLocalType = NegativeInfinity
else:
    # Versions with a local segment need that segment parsed to implement
    # the sorting rules in PEP440.
    # - Alpha numeric segments sort before numeric segments
    # - Alpha numeric segments sort lexicographically
    # - Numeric segments sort numerically
    # - Shorter versions sort before longer versions when the prefixes
    #   match exactly
    _local = tuple(
        (i, &quot;&quot;) if isinstance(i, int) else (NegativeInfinity, i) for i in local
    )

return epoch, _release, _pre, _post, _dev, _local
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>