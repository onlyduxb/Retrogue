

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/req/req_install.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import functools
import logging
import os
import shutil
import sys
import uuid
import zipfile
from collections.abc import Collection, Iterable
from optparse import Values
from pathlib import Path
from typing import Any</p>
<p>from pip._vendor.packaging.markers import Marker
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import SpecifierSet
from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version
from pip._vendor.pyproject_hooks import BuildBackendHookCaller</p>
<p>from pip._internal.build_env import BuildEnvironment, NoOpBuildEnvironment
from pip._internal.exceptions import InstallationError, PreviousBuildDirError
from pip._internal.locations import get_scheme
from pip._internal.metadata import (
BaseDistribution,
get_default_environment,
get_directory_distribution,
get_wheel_distribution,
)
from pip._internal.metadata.base import FilesystemWheel
from pip._internal.models.direct_url import DirectUrl
from pip._internal.models.link import Link
from pip._internal.operations.build.metadata import generate_metadata
from pip._internal.operations.build.metadata_editable import generate_editable_metadata
from pip._internal.operations.install.wheel import install_wheel
from pip._internal.pyproject import load_pyproject_toml, make_pyproject_path
from pip._internal.req.req_uninstall import UninstallPathSet
from pip._internal.utils.deprecation import deprecated
from pip._internal.utils.hashes import Hashes
from pip._internal.utils.misc import (
ConfiguredBuildBackendHookCaller,
ask_path_exists,
backup_dir,
display_path,
hide_url,
is_installable_dir,
redact_auth_from_requirement,
redact_auth_from_url,
)
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.subprocess import runner_with_spinner_message
from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
from pip._internal.utils.unpacking import unpack_file
from pip._internal.utils.virtualenv import running_under_virtualenv
from pip._internal.vcs import vcs</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>class InstallRequirement:
“””
Represents something that may be installed later on, may have information
about where to fetch the relevant requirement and also contains logic for
installing the said requirement.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    req: Requirement | None,
    comes_from: str | InstallRequirement | None,
    editable: bool = False,
    link: Link | None = None,
    markers: Marker | None = None,
    isolated: bool = False,
    *,
    hash_options: dict[str, list[str]] | None = None,
    config_settings: dict[str, str | list[str]] | None = None,
    constraint: bool = False,
    extras: Collection[str] = (),
    user_supplied: bool = False,
    permit_editable_wheels: bool = False,
) -&gt; None:
    assert req is None or isinstance(req, Requirement), req
    self.req = req
    self.comes_from = comes_from
    self.constraint = constraint
    self.editable = editable
    self.permit_editable_wheels = permit_editable_wheels

    # source_dir is the local directory where the linked requirement is
    # located, or unpacked. In case unpacking is needed, creating and
    # populating source_dir is done by the RequirementPreparer. Note this
    # is not necessarily the directory where pyproject.toml or setup.py is
    # located - that one is obtained via unpacked_source_directory.
    self.source_dir: str | None = None
    if self.editable:
        assert link
        if link.is_file:
            self.source_dir = os.path.normpath(os.path.abspath(link.file_path))

    # original_link is the direct URL that was provided by the user for the
    # requirement, either directly or via a constraints file.
    if link is None and req and req.url:
        # PEP 508 URL requirement
        link = Link(req.url)
    self.link = self.original_link = link

    # When this InstallRequirement is a wheel obtained from the cache of locally
    # built wheels, this is the source link corresponding to the cache entry, which
    # was used to download and build the cached wheel.
    self.cached_wheel_source_link: Link | None = None

    # Information about the location of the artifact that was downloaded . This
    # property is guaranteed to be set in resolver results.
    self.download_info: DirectUrl | None = None

    # Path to any downloaded or already-existing package.
    self.local_file_path: str | None = None
    if self.link and self.link.is_file:
        self.local_file_path = self.link.file_path

    if extras:
        self.extras = extras
    elif req:
        self.extras = req.extras
    else:
        self.extras = set()
    if markers is None and req:
        markers = req.marker
    self.markers = markers

    # This holds the Distribution object if this requirement is already installed.
    self.satisfied_by: BaseDistribution | None = None
    # Whether the installation process should try to uninstall an existing
    # distribution before installing this requirement.
    self.should_reinstall = False
    # Temporary build location
    self._temp_build_dir: TempDirectory | None = None
    # Set to True after successful installation
    self.install_succeeded: bool | None = None
    # Supplied options
    self.hash_options = hash_options if hash_options else {}
    self.config_settings = config_settings
    # Set to True after successful preparation of this requirement
    self.prepared = False
    # User supplied requirement are explicitly requested for installation
    # by the user via CLI arguments or requirements files, as opposed to,
    # e.g. dependencies, extras or constraints.
    self.user_supplied = user_supplied

    self.isolated = isolated
    self.build_env: BuildEnvironment = NoOpBuildEnvironment()

    # For PEP 517, the directory where we request the project metadata
    # gets stored. We need this to pass to build_wheel, so the backend
    # can ensure that the wheel matches the metadata (see the PEP for
    # details).
    self.metadata_directory: str | None = None

    # The cached metadata distribution that this requirement represents.
    # See get_dist / set_dist.
    self._distribution: BaseDistribution | None = None

    # The static build requirements (from pyproject.toml)
    self.pyproject_requires: list[str] | None = None

    # Build requirements that we will check are available
    self.requirements_to_check: list[str] = []

    # The PEP 517 backend we should use to build the project
    self.pep517_backend: BuildBackendHookCaller | None = None

    # This requirement needs more preparation before it can be built
    self.needs_more_preparation = False

    # This requirement needs to be unpacked before it can be installed.
    self._archive_source: Path | None = None

def __str__(self) -&gt; str:
    if self.req:
        s = redact_auth_from_requirement(self.req)
        if self.link:
            s += f&quot; from {redact_auth_from_url(self.link.url)}&quot;
    elif self.link:
        s = redact_auth_from_url(self.link.url)
    else:
        s = &quot;&lt;InstallRequirement&gt;&quot;
    if self.satisfied_by is not None:
        if self.satisfied_by.location is not None:
            location = display_path(self.satisfied_by.location)
        else:
            location = &quot;&lt;memory&gt;&quot;
        s += f&quot; in {location}&quot;
    if self.comes_from:
        if isinstance(self.comes_from, str):
            comes_from: str | None = self.comes_from
        else:
            comes_from = self.comes_from.from_path()
        if comes_from:
            s += f&quot; (from {comes_from})&quot;
    return s

def __repr__(self) -&gt; str:
    return (
        f&quot;&lt;{self.__class__.__name__} object: &quot;
        f&quot;{str(self)} editable={self.editable!r}&gt;&quot;
    )

def format_debug(self) -&gt; str:
    &quot;&quot;&quot;An un-tested helper for getting state, for debugging.&quot;&quot;&quot;
    attributes = vars(self)
    names = sorted(attributes)

    state = (f&quot;{attr}={attributes[attr]!r}&quot; for attr in sorted(names))
    return &quot;&lt;{name} object: {{{state}}}&gt;&quot;.format(
        name=self.__class__.__name__,
        state=&quot;, &quot;.join(state),
    )

# Things that are valid for all kinds of requirements?
@property
def name(self) -&gt; str | None:
    if self.req is None:
        return None
    return self.req.name

@functools.cached_property
def supports_pyproject_editable(self) -&gt; bool:
    assert self.pep517_backend
    with self.build_env:
        runner = runner_with_spinner_message(
            &quot;Checking if build backend supports build_editable&quot;
        )
        with self.pep517_backend.subprocess_runner(runner):
            return &quot;build_editable&quot; in self.pep517_backend._supported_features()

@property
def specifier(self) -&gt; SpecifierSet:
    assert self.req is not None
    return self.req.specifier

@property
def is_direct(self) -&gt; bool:
    &quot;&quot;&quot;Whether this requirement was specified as a direct URL.&quot;&quot;&quot;
    return self.original_link is not None

@property
def is_pinned(self) -&gt; bool:
    &quot;&quot;&quot;Return whether I am pinned to an exact version.

    For example, some-package==1.2 is pinned; some-package&gt;1.2 is not.
    &quot;&quot;&quot;
    assert self.req is not None
    specifiers = self.req.specifier
    return len(specifiers) == 1 and next(iter(specifiers)).operator in {&quot;==&quot;, &quot;===&quot;}

def match_markers(self, extras_requested: Iterable[str] | None = None) -&gt; bool:
    if not extras_requested:
        # Provide an extra to safely evaluate the markers
        # without matching any extra
        extras_requested = (&quot;&quot;,)
    if self.markers is not None:
        return any(
            self.markers.evaluate({&quot;extra&quot;: extra}) for extra in extras_requested
        )
    else:
        return True

@property
def has_hash_options(self) -&gt; bool:
    &quot;&quot;&quot;Return whether any known-good hashes are specified as options.

    These activate --require-hashes mode; hashes specified as part of a
    URL do not.

    &quot;&quot;&quot;
    return bool(self.hash_options)

def hashes(self, trust_internet: bool = True) -&gt; Hashes:
    &quot;&quot;&quot;Return a hash-comparer that considers my option- and URL-based
    hashes to be known-good.

    Hashes in URLs--ones embedded in the requirements file, not ones
    downloaded from an index server--are almost peers with ones from
    flags. They satisfy --require-hashes (whether it was implicitly or
    explicitly activated) but do not activate it. md5 and sha224 are not
    allowed in flags, which should nudge people toward good algos. We
    always OR all hashes together, even ones from URLs.

    :param trust_internet: Whether to trust URL-based (#md5=...) hashes
        downloaded from the internet, as by populate_link()

    &quot;&quot;&quot;
    good_hashes = self.hash_options.copy()
    if trust_internet:
        link = self.link
    elif self.is_direct and self.user_supplied:
        link = self.original_link
    else:
        link = None
    if link and link.hash:
        assert link.hash_name is not None
        good_hashes.setdefault(link.hash_name, []).append(link.hash)
    return Hashes(good_hashes)

def from_path(self) -&gt; str | None:
    &quot;&quot;&quot;Format a nice indicator to show where this &quot;comes from&quot; &quot;&quot;&quot;
    if self.req is None:
        return None
    s = str(self.req)
    if self.comes_from:
        comes_from: str | None
        if isinstance(self.comes_from, str):
            comes_from = self.comes_from
        else:
            comes_from = self.comes_from.from_path()
        if comes_from:
            s += &quot;-&gt;&quot; + comes_from
    return s

def ensure_build_location(
    self, build_dir: str, autodelete: bool, parallel_builds: bool
) -&gt; str:
    assert build_dir is not None
    if self._temp_build_dir is not None:
        assert self._temp_build_dir.path
        return self._temp_build_dir.path
    if self.req is None:
        # Some systems have /tmp as a symlink which confuses custom
        # builds (such as numpy). Thus, we ensure that the real path
        # is returned.
        self._temp_build_dir = TempDirectory(
            kind=tempdir_kinds.REQ_BUILD, globally_managed=True
        )

        return self._temp_build_dir.path

    # This is the only remaining place where we manually determine the path
    # for the temporary directory. It is only needed for editables where
    # it is the value of the --src option.

    # When parallel builds are enabled, add a UUID to the build directory
    # name so multiple builds do not interfere with each other.
    dir_name: str = canonicalize_name(self.req.name)
    if parallel_builds:
        dir_name = f&quot;{dir_name}_{uuid.uuid4().hex}&quot;

    # FIXME: Is there a better place to create the build_dir? (hg and bzr
    # need this)
    if not os.path.exists(build_dir):
        logger.debug(&quot;Creating directory %s&quot;, build_dir)
        os.makedirs(build_dir)
    actual_build_dir = os.path.join(build_dir, dir_name)
    # `None` indicates that we respect the globally-configured deletion
    # settings, which is what we actually want when auto-deleting.
    delete_arg = None if autodelete else False
    return TempDirectory(
        path=actual_build_dir,
        delete=delete_arg,
        kind=tempdir_kinds.REQ_BUILD,
        globally_managed=True,
    ).path

def _set_requirement(self) -&gt; None:
    &quot;&quot;&quot;Set requirement after generating metadata.&quot;&quot;&quot;
    assert self.req is None
    assert self.metadata is not None
    assert self.source_dir is not None

    # Construct a Requirement object from the generated metadata
    if isinstance(parse_version(self.metadata[&quot;Version&quot;]), Version):
        op = &quot;==&quot;
    else:
        op = &quot;===&quot;

    self.req = get_requirement(
        &quot;&quot;.join(
            [
                self.metadata[&quot;Name&quot;],
                op,
                self.metadata[&quot;Version&quot;],
            ]
        )
    )

def warn_on_mismatching_name(self) -&gt; None:
    assert self.req is not None
    metadata_name = canonicalize_name(self.metadata[&quot;Name&quot;])
    if canonicalize_name(self.req.name) == metadata_name:
        # Everything is fine.
        return

    # If we&#39;re here, there&#39;s a mismatch. Log a warning about it.
    logger.warning(
        &quot;Generating metadata for package %s &quot;
        &quot;produced metadata for project name %s. Fix your &quot;
        &quot;#egg=%s fragments.&quot;,
        self.name,
        metadata_name,
        self.name,
    )
    self.req = get_requirement(metadata_name)

def check_if_exists(self, use_user_site: bool) -&gt; None:
    &quot;&quot;&quot;Find an installed distribution that satisfies or conflicts
    with this requirement, and set self.satisfied_by or
    self.should_reinstall appropriately.
    &quot;&quot;&quot;
    if self.req is None:
        return
    existing_dist = get_default_environment().get_distribution(self.req.name)
    if not existing_dist:
        return

    version_compatible = self.req.specifier.contains(
        existing_dist.version,
        prereleases=True,
    )
    if not version_compatible:
        self.satisfied_by = None
        if use_user_site:
            if existing_dist.in_usersite:
                self.should_reinstall = True
            elif running_under_virtualenv() and existing_dist.in_site_packages:
                raise InstallationError(
                    f&quot;Will not install to the user site because it will &quot;
                    f&quot;lack sys.path precedence to {existing_dist.raw_name} &quot;
                    f&quot;in {existing_dist.location}&quot;
                )
        else:
            self.should_reinstall = True
    else:
        if self.editable:
            self.should_reinstall = True
            # when installing editables, nothing pre-existing should ever
            # satisfy
            self.satisfied_by = None
        else:
            self.satisfied_by = existing_dist

# Things valid for wheels
@property
def is_wheel(self) -&gt; bool:
    if not self.link:
        return False
    return self.link.is_wheel

@property
def is_wheel_from_cache(self) -&gt; bool:
    # When True, it means that this InstallRequirement is a local wheel file in the
    # cache of locally built wheels.
    return self.cached_wheel_source_link is not None

# Things valid for sdists
@property
def unpacked_source_directory(self) -&gt; str:
    assert self.source_dir, f&quot;No source dir for {self}&quot;
    return os.path.join(
        self.source_dir, self.link and self.link.subdirectory_fragment or &quot;&quot;
    )

@property
def setup_py_path(self) -&gt; str:
    assert self.source_dir, f&quot;No source dir for {self}&quot;
    setup_py = os.path.join(self.unpacked_source_directory, &quot;setup.py&quot;)

    return setup_py

@property
def pyproject_toml_path(self) -&gt; str:
    assert self.source_dir, f&quot;No source dir for {self}&quot;
    return make_pyproject_path(self.unpacked_source_directory)

def load_pyproject_toml(self) -&gt; None:
    &quot;&quot;&quot;Load the pyproject.toml file.

    After calling this routine, all of the attributes related to PEP 517
    processing for this requirement have been set.
    &quot;&quot;&quot;
    pyproject_toml_data = load_pyproject_toml(
        self.pyproject_toml_path, self.setup_py_path, str(self)
    )
    assert pyproject_toml_data
    requires, backend, check, backend_path = pyproject_toml_data
    self.requirements_to_check = check
    self.pyproject_requires = requires
    self.pep517_backend = ConfiguredBuildBackendHookCaller(
        self,
        self.unpacked_source_directory,
        backend,
        backend_path=backend_path,
    )

def editable_sanity_check(self) -&gt; None:
    &quot;&quot;&quot;Check that an editable requirement if valid for use with PEP 517/518.

    This verifies that an editable has a build backend that supports PEP 660.
    &quot;&quot;&quot;
    if self.editable and not self.supports_pyproject_editable:
        raise InstallationError(
            f&quot;Project {self} uses a build backend &quot;
            f&quot;that is missing the &#39;build_editable&#39; hook, so &quot;
            f&quot;it cannot be installed in editable mode. &quot;
            f&quot;Consider using a build backend that supports PEP 660.&quot;
        )

def prepare_metadata(self) -&gt; None:
    &quot;&quot;&quot;Ensure that project metadata is available.

    Under PEP 517 and PEP 660, call the backend hook to prepare the metadata.
    Under legacy processing, call setup.py egg-info.
    &quot;&quot;&quot;
    assert self.source_dir, f&quot;No source dir for {self}&quot;
    details = self.name or f&quot;from {self.link}&quot;

    assert self.pep517_backend is not None
    if (
        self.editable
        and self.permit_editable_wheels
        and self.supports_pyproject_editable
    ):
        self.metadata_directory = generate_editable_metadata(
            build_env=self.build_env,
            backend=self.pep517_backend,
            details=details,
        )
    else:
        self.metadata_directory = generate_metadata(
            build_env=self.build_env,
            backend=self.pep517_backend,
            details=details,
        )

    # Act on the newly generated metadata, based on the name and version.
    if not self.name:
        self._set_requirement()
    else:
        self.warn_on_mismatching_name()

    self.assert_source_matches_version()

@property
def metadata(self) -&gt; Any:
    if not hasattr(self, &quot;_metadata&quot;):
        self._metadata = self.get_dist().metadata

    return self._metadata

def set_dist(self, distribution: BaseDistribution) -&gt; None:
    self._distribution = distribution

def get_dist(self) -&gt; BaseDistribution:
    if self._distribution is not None:
        return self._distribution
    elif self.metadata_directory:
        return get_directory_distribution(self.metadata_directory)
    elif self.local_file_path and self.is_wheel:
        assert self.req is not None
        return get_wheel_distribution(
            FilesystemWheel(self.local_file_path),
            canonicalize_name(self.req.name),
        )
    raise AssertionError(
        f&quot;InstallRequirement {self} has no metadata directory and no wheel: &quot;
        f&quot;can&#39;t make a distribution.&quot;
    )

def assert_source_matches_version(self) -&gt; None:
    assert self.source_dir, f&quot;No source dir for {self}&quot;
    version = self.metadata[&quot;version&quot;]
    if self.req and self.req.specifier and version not in self.req.specifier:
        logger.warning(
            &quot;Requested %s, but installing version %s&quot;,
            self,
            version,
        )
    else:
        logger.debug(
            &quot;Source in %s has version %s, which satisfies requirement %s&quot;,
            display_path(self.source_dir),
            version,
            self,
        )

# For both source distributions and editables
def ensure_has_source_dir(
    self,
    parent_dir: str,
    autodelete: bool = False,
    parallel_builds: bool = False,
) -&gt; None:
    &quot;&quot;&quot;Ensure that a source_dir is set.

    This will create a temporary build dir if the name of the requirement
    isn&#39;t known yet.

    :param parent_dir: The ideal pip parent_dir for the source_dir.
        Generally src_dir for editables and build_dir for sdists.
    :return: self.source_dir
    &quot;&quot;&quot;
    if self.source_dir is None:
        self.source_dir = self.ensure_build_location(
            parent_dir,
            autodelete=autodelete,
            parallel_builds=parallel_builds,
        )

def needs_unpacked_archive(self, archive_source: Path) -&gt; None:
    assert self._archive_source is None
    self._archive_source = archive_source

def ensure_pristine_source_checkout(self) -&gt; None:
    &quot;&quot;&quot;Ensure the source directory has not yet been built in.&quot;&quot;&quot;
    assert self.source_dir is not None
    if self._archive_source is not None:
        unpack_file(str(self._archive_source), self.source_dir)
    elif is_installable_dir(self.source_dir):
        # If a checkout exists, it&#39;s unwise to keep going.
        # version inconsistencies are logged later, but do not fail
        # the installation.
        raise PreviousBuildDirError(
            f&quot;pip can&#39;t proceed with requirements &#39;{self}&#39; due to a &quot;
            f&quot;pre-existing build directory ({self.source_dir}). This is likely &quot;
            &quot;due to a previous installation that failed . pip is &quot;
            &quot;being responsible and not assuming it can delete this. &quot;
            &quot;Please delete it and try again.&quot;
        )

# For editable installations
def update_editable(self) -&gt; None:
    if not self.link:
        logger.debug(
            &quot;Cannot update repository at %s; repository location is unknown&quot;,
            self.source_dir,
        )
        return
    assert self.editable
    assert self.source_dir
    if self.link.scheme == &quot;file&quot;:
        # Static paths don&#39;t get updated
        return
    vcs_backend = vcs.get_backend_for_scheme(self.link.scheme)
    # Editable requirements are validated in Requirement constructors.
    # So here, if it&#39;s neither a path nor a valid VCS URL, it&#39;s a bug.
    assert vcs_backend, f&quot;Unsupported VCS URL {self.link.url}&quot;
    hidden_url = hide_url(self.link.url)
    vcs_backend.obtain(self.source_dir, url=hidden_url, verbosity=0)

# Top-level Actions
def uninstall(
    self, auto_confirm: bool = False, verbose: bool = False
) -&gt; UninstallPathSet | None:
    &quot;&quot;&quot;
    Uninstall the distribution currently satisfying this requirement.

    Prompts before removing or modifying files unless
    ``auto_confirm`` is True.

    Refuses to delete or modify files outside of ``sys.prefix`` -
    thus uninstallation within a virtual environment can only
    modify that virtual environment, even if the virtualenv is
    linked to global site-packages.

    &quot;&quot;&quot;
    assert self.req
    dist = get_default_environment().get_distribution(self.req.name)
    if not dist:
        logger.warning(&quot;Skipping %s as it is not installed.&quot;, self.name)
        return None
    logger.info(&quot;Found existing installation: %s&quot;, dist)

    uninstalled_pathset = UninstallPathSet.from_dist(dist)
    uninstalled_pathset.remove(auto_confirm, verbose)
    return uninstalled_pathset

def _get_archive_name(self, path: str, parentdir: str, rootdir: str) -&gt; str:
    def _clean_zip_name(name: str, prefix: str) -&gt; str:
        assert name.startswith(
            prefix + os.path.sep
        ), f&quot;name {name!r} doesn&#39;t start with prefix {prefix!r}&quot;
        name = name[len(prefix) + 1 :]
        name = name.replace(os.path.sep, &quot;/&quot;)
        return name

    assert self.req is not None
    path = os.path.join(parentdir, path)
    name = _clean_zip_name(path, rootdir)
    return self.req.name + &quot;/&quot; + name

def archive(self, build_dir: str | None) -&gt; None:
    &quot;&quot;&quot;Saves archive to provided build_dir.

    Used for saving downloaded VCS requirements as part of `pip download`.
    &quot;&quot;&quot;
    assert self.source_dir
    if build_dir is None:
        return

    create_archive = True
    archive_name = &quot;{}-{}.zip&quot;.format(self.name, self.metadata[&quot;version&quot;])
    archive_path = os.path.join(build_dir, archive_name)

    if os.path.exists(archive_path):
        response = ask_path_exists(
            f&quot;The file {display_path(archive_path)} exists. (i)gnore, (w)ipe, &quot;
            &quot;(b)ackup, (a)bort &quot;,
            (&quot;i&quot;, &quot;w&quot;, &quot;b&quot;, &quot;a&quot;),
        )
        if response == &quot;i&quot;:
            create_archive = False
        elif response == &quot;w&quot;:
            logger.warning(&quot;Deleting %s&quot;, display_path(archive_path))
            os.remove(archive_path)
        elif response == &quot;b&quot;:
            dest_file = backup_dir(archive_path)
            logger.warning(
                &quot;Backing up %s to %s&quot;,
                display_path(archive_path),
                display_path(dest_file),
            )
            shutil.move(archive_path, dest_file)
        elif response == &quot;a&quot;:
            sys.exit(-1)

    if not create_archive:
        return

    zip_output = zipfile.ZipFile(
        archive_path,
        &quot;w&quot;,
        zipfile.ZIP_DEFLATED,
        allowZip64=True,
    )
    with zip_output:
        dir = os.path.normcase(os.path.abspath(self.unpacked_source_directory))
        for dirpath, dirnames, filenames in os.walk(dir):
            for dirname in dirnames:
                dir_arcname = self._get_archive_name(
                    dirname,
                    parentdir=dirpath,
                    rootdir=dir,
                )
                zipdir = zipfile.ZipInfo(dir_arcname + &quot;/&quot;)
                zipdir.external_attr = 0x1ED &lt;&lt; 16  # 0o755
                zip_output.writestr(zipdir, &quot;&quot;)
            for filename in filenames:
                file_arcname = self._get_archive_name(
                    filename,
                    parentdir=dirpath,
                    rootdir=dir,
                )
                filename = os.path.join(dirpath, filename)
                zip_output.write(filename, file_arcname)

    logger.info(&quot;Saved %s&quot;, display_path(archive_path))

def install(
    self,
    root: str | None = None,
    home: str | None = None,
    prefix: str | None = None,
    warn_script_location: bool = True,
    use_user_site: bool = False,
    pycompile: bool = True,
) -&gt; None:
    assert self.req is not None
    scheme = get_scheme(
        self.req.name,
        user=use_user_site,
        home=home,
        root=root,
        isolated=self.isolated,
        prefix=prefix,
    )

    assert self.is_wheel
    assert self.local_file_path

    install_wheel(
        self.req.name,
        self.local_file_path,
        scheme=scheme,
        req_description=str(self.req),
        pycompile=pycompile,
        warn_script_location=warn_script_location,
        direct_url=self.download_info if self.is_direct else None,
        requested=self.user_supplied,
    )
    self.install_succeeded = True
</pre></div>
</div>
<p>def check_invalid_constraint_type(req: InstallRequirement) -&gt; str:
# Check for unsupported forms
problem = “”
if not req.name:
problem = “Unnamed requirements are not allowed as constraints”
elif req.editable:
problem = “Editable requirements are not allowed as constraints”
elif req.extras:
problem = “Constraints cannot have extras”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if problem:
    deprecated(
        reason=(
            &quot;Constraints are only allowed to take the form of a package &quot;
            &quot;name and a version specifier. Other forms were originally &quot;
            &quot;permitted as an accident of the implementation, but were &quot;
            &quot;undocumented. The new implementation of the resolver no &quot;
            &quot;longer supports these forms.&quot;
        ),
        replacement=&quot;replacing the constraint with a requirement&quot;,
        # No plan yet for when the new resolver becomes default
        gone_in=None,
        issue=8210,
    )

return problem
</pre></div>
</div>
<p>def _has_option(options: Values, reqs: list[InstallRequirement], option: str) -&gt; bool:
if getattr(options, option, None):
return True
for req in reqs:
if getattr(req, option, None):
return True
return False</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>