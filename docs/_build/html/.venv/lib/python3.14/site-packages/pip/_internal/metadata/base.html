

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/metadata/base.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import csv
import email.message
import functools
import json
import logging
import pathlib
import re
import zipfile
from collections.abc import Collection, Container, Iterable, Iterator
from typing import (
IO,
Any,
NamedTuple,
Protocol,
Union,
)</p>
<p>from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version</p>
<p>from pip._internal.exceptions import NoneMetadataError
from pip._internal.locations import site_packages, user_site
from pip._internal.models.direct_url import (
DIRECT_URL_METADATA_NAME,
DirectUrl,
DirectUrlValidationError,
)
from pip._internal.utils.compat import stdlib_pkgs  # TODO: Move definition here.
from pip._internal.utils.egg_link import egg_link_path_from_sys_path
from pip._internal.utils.misc import is_local, normalize_path
from pip._internal.utils.urls import url_to_path</p>
<p>from ._json import msg_to_json</p>
<p>InfoPath = Union[str, pathlib.PurePath]</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>class BaseEntryPoint(Protocol):
&#64;property
def name(self) -&gt; str:
raise NotImplementedError()</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@property
def value(self) -&gt; str:
    raise NotImplementedError()

@property
def group(self) -&gt; str:
    raise NotImplementedError()
</pre></div>
</div>
<p>def _convert_installed_files_path(
entry: tuple[str, …],
info: tuple[str, …],
) -&gt; str:
“””Convert a legacy installed-files.txt path into modern RECORD path.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The legacy format stores paths relative to the info directory, while the
modern format stores paths relative to the package root, e.g. the
site-packages directory.

:param entry: Path parts of the installed-files.txt entry.
:param info: Path parts of the egg-info directory relative to package root.
:returns: The converted entry.

For best compatibility with symlinks, this does not use ``abspath()`` or
``Path.resolve()``, but tries to work with path parts:

1. While ``entry`` starts with ``..``, remove the equal amounts of parts
   from ``info``; if ``info`` is empty, start appending ``..`` instead.
2. Join the two directly.
&quot;&quot;&quot;
while entry and entry[0] == &quot;..&quot;:
    if not info or info[-1] == &quot;..&quot;:
        info += (&quot;..&quot;,)
    else:
        info = info[:-1]
    entry = entry[1:]
return str(pathlib.Path(*info, *entry))
</pre></div>
</div>
<p>class RequiresEntry(NamedTuple):
requirement: str
extra: str
marker: str</p>
<p>class BaseDistribution(Protocol):
&#64;classmethod
def from_directory(cls, directory: str) -&gt; BaseDistribution:
“””Load the distribution from a metadata directory.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    :param directory: Path to a metadata directory, e.g. ``.dist-info``.
    &quot;&quot;&quot;
    raise NotImplementedError()

@classmethod
def from_metadata_file_contents(
    cls,
    metadata_contents: bytes,
    filename: str,
    project_name: str,
) -&gt; BaseDistribution:
    &quot;&quot;&quot;Load the distribution from the contents of a METADATA file.

    This is used to implement PEP 658 by generating a &quot;shallow&quot; dist object that can
    be used for resolution without downloading or building the actual dist yet.

    :param metadata_contents: The contents of a METADATA file.
    :param filename: File name for the dist with this metadata.
    :param project_name: Name of the project this dist represents.
    &quot;&quot;&quot;
    raise NotImplementedError()

@classmethod
def from_wheel(cls, wheel: Wheel, name: str) -&gt; BaseDistribution:
    &quot;&quot;&quot;Load the distribution from a given wheel.

    :param wheel: A concrete wheel definition.
    :param name: File name of the wheel.

    :raises InvalidWheel: Whenever loading of the wheel causes a
        :py:exc:`zipfile.BadZipFile` exception to be thrown.
    :raises UnsupportedWheel: If the wheel is a valid zip, but malformed
        internally.
    &quot;&quot;&quot;
    raise NotImplementedError()

def __repr__(self) -&gt; str:
    return f&quot;{self.raw_name} {self.raw_version} ({self.location})&quot;

def __str__(self) -&gt; str:
    return f&quot;{self.raw_name} {self.raw_version}&quot;

@property
def location(self) -&gt; str | None:
    &quot;&quot;&quot;Where the distribution is loaded from.

    A string value is not necessarily a filesystem path, since distributions
    can be loaded from other sources, e.g. arbitrary zip archives. ``None``
    means the distribution is created in-memory.

    Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If
    this is a symbolic link, we want to preserve the relative path between
    it and files in the distribution.
    &quot;&quot;&quot;
    raise NotImplementedError()

@property
def editable_project_location(self) -&gt; str | None:
    &quot;&quot;&quot;The project location for editable distributions.

    This is the directory where pyproject.toml or setup.py is located.
    None if the distribution is not installed in editable mode.
    &quot;&quot;&quot;
    # TODO: this property is relatively costly to compute, memoize it ?
    direct_url = self.direct_url
    if direct_url:
        if direct_url.is_local_editable():
            return url_to_path(direct_url.url)
    else:
        # Search for an .egg-link file by walking sys.path, as it was
        # done before by dist_is_editable().
        egg_link_path = egg_link_path_from_sys_path(self.raw_name)
        if egg_link_path:
            # TODO: get project location from second line of egg_link file
            #       (https://github.com/pypa/pip/issues/10243)
            return self.location
    return None

@property
def installed_location(self) -&gt; str | None:
    &quot;&quot;&quot;The distribution&#39;s &quot;installed&quot; location.

    This should generally be a ``site-packages`` directory. This is
    usually ``dist.location``, except for legacy develop-installed packages,
    where ``dist.location`` is the source code location, and this is where
    the ``.egg-link`` file is.

    The returned location is normalized (in particular, with symlinks removed).
    &quot;&quot;&quot;
    raise NotImplementedError()

@property
def info_location(self) -&gt; str | None:
    &quot;&quot;&quot;Location of the .[egg|dist]-info directory or file.

    Similarly to ``location``, a string value is not necessarily a
    filesystem path. ``None`` means the distribution is created in-memory.

    For a modern .dist-info installation on disk, this should be something
    like ``{location}/{raw_name}-{version}.dist-info``.

    Do not canonicalize this value with e.g. ``pathlib.Path.resolve()``. If
    this is a symbolic link, we want to preserve the relative path between
    it and other files in the distribution.
    &quot;&quot;&quot;
    raise NotImplementedError()

@property
def installed_by_distutils(self) -&gt; bool:
    &quot;&quot;&quot;Whether this distribution is installed with legacy distutils format.

    A distribution installed with &quot;raw&quot; distutils not patched by setuptools
    uses one single file at ``info_location`` to store metadata. We need to
    treat this specially on uninstallation.
    &quot;&quot;&quot;
    info_location = self.info_location
    if not info_location:
        return False
    return pathlib.Path(info_location).is_file()

@property
def installed_as_egg(self) -&gt; bool:
    &quot;&quot;&quot;Whether this distribution is installed as an egg.

    This usually indicates the distribution was installed by (older versions
    of) easy_install.
    &quot;&quot;&quot;
    location = self.location
    if not location:
        return False
    # XXX if the distribution is a zipped egg, location has a trailing /
    # so we resort to pathlib.Path to check the suffix in a reliable way.
    return pathlib.Path(location).suffix == &quot;.egg&quot;

@property
def installed_with_setuptools_egg_info(self) -&gt; bool:
    &quot;&quot;&quot;Whether this distribution is installed with the ``.egg-info`` format.

    This usually indicates the distribution was installed with setuptools
    with an old pip version or with ``single-version-externally-managed``.

    Note that this ensure the metadata store is a directory. distutils can
    also installs an ``.egg-info``, but as a file, not a directory. This
    property is *False* for that case. Also see ``installed_by_distutils``.
    &quot;&quot;&quot;
    info_location = self.info_location
    if not info_location:
        return False
    if not info_location.endswith(&quot;.egg-info&quot;):
        return False
    return pathlib.Path(info_location).is_dir()

@property
def installed_with_dist_info(self) -&gt; bool:
    &quot;&quot;&quot;Whether this distribution is installed with the &quot;modern format&quot;.

    This indicates a &quot;modern&quot; installation, e.g. storing metadata in the
    ``.dist-info`` directory. This applies to installations made by
    setuptools (but through pip, not directly), or anything using the
    standardized build backend interface (PEP 517).
    &quot;&quot;&quot;
    info_location = self.info_location
    if not info_location:
        return False
    if not info_location.endswith(&quot;.dist-info&quot;):
        return False
    return pathlib.Path(info_location).is_dir()

@property
def canonical_name(self) -&gt; NormalizedName:
    raise NotImplementedError()

@property
def version(self) -&gt; Version:
    raise NotImplementedError()

@property
def raw_version(self) -&gt; str:
    raise NotImplementedError()

@property
def setuptools_filename(self) -&gt; str:
    &quot;&quot;&quot;Convert a project name to its setuptools-compatible filename.

    This is a copy of ``pkg_resources.to_filename()`` for compatibility.
    &quot;&quot;&quot;
    return self.raw_name.replace(&quot;-&quot;, &quot;_&quot;)

@property
def direct_url(self) -&gt; DirectUrl | None:
    &quot;&quot;&quot;Obtain a DirectUrl from this distribution.

    Returns None if the distribution has no `direct_url.json` metadata,
    or if `direct_url.json` is invalid.
    &quot;&quot;&quot;
    try:
        content = self.read_text(DIRECT_URL_METADATA_NAME)
    except FileNotFoundError:
        return None
    try:
        return DirectUrl.from_json(content)
    except (
        UnicodeDecodeError,
        json.JSONDecodeError,
        DirectUrlValidationError,
    ) as e:
        logger.warning(
            &quot;Error parsing %s for %s: %s&quot;,
            DIRECT_URL_METADATA_NAME,
            self.canonical_name,
            e,
        )
        return None

@property
def installer(self) -&gt; str:
    try:
        installer_text = self.read_text(&quot;INSTALLER&quot;)
    except (OSError, ValueError, NoneMetadataError):
        return &quot;&quot;  # Fail silently if the installer file cannot be read.
    for line in installer_text.splitlines():
        cleaned_line = line.strip()
        if cleaned_line:
            return cleaned_line
    return &quot;&quot;

@property
def requested(self) -&gt; bool:
    return self.is_file(&quot;REQUESTED&quot;)

@property
def editable(self) -&gt; bool:
    return bool(self.editable_project_location)

@property
def local(self) -&gt; bool:
    &quot;&quot;&quot;If distribution is installed in the current virtual environment.

    Always True if we&#39;re not in a virtualenv.
    &quot;&quot;&quot;
    if self.installed_location is None:
        return False
    return is_local(self.installed_location)

@property
def in_usersite(self) -&gt; bool:
    if self.installed_location is None or user_site is None:
        return False
    return self.installed_location.startswith(normalize_path(user_site))

@property
def in_site_packages(self) -&gt; bool:
    if self.installed_location is None or site_packages is None:
        return False
    return self.installed_location.startswith(normalize_path(site_packages))

def is_file(self, path: InfoPath) -&gt; bool:
    &quot;&quot;&quot;Check whether an entry in the info directory is a file.&quot;&quot;&quot;
    raise NotImplementedError()

def iter_distutils_script_names(self) -&gt; Iterator[str]:
    &quot;&quot;&quot;Find distutils &#39;scripts&#39; entries metadata.

    If &#39;scripts&#39; is supplied in ``setup.py``, distutils records those in the
    installed distribution&#39;s ``scripts`` directory, a file for each script.
    &quot;&quot;&quot;
    raise NotImplementedError()

def read_text(self, path: InfoPath) -&gt; str:
    &quot;&quot;&quot;Read a file in the info directory.

    :raise FileNotFoundError: If ``path`` does not exist in the directory.
    :raise NoneMetadataError: If ``path`` exists in the info directory, but
        cannot be read.
    &quot;&quot;&quot;
    raise NotImplementedError()

def iter_entry_points(self) -&gt; Iterable[BaseEntryPoint]:
    raise NotImplementedError()

def _metadata_impl(self) -&gt; email.message.Message:
    raise NotImplementedError()

@functools.cached_property
def metadata(self) -&gt; email.message.Message:
    &quot;&quot;&quot;Metadata of distribution parsed from e.g. METADATA or PKG-INFO.

    This should return an empty message if the metadata file is unavailable.

    :raises NoneMetadataError: If the metadata file is available, but does
        not contain valid metadata.
    &quot;&quot;&quot;
    metadata = self._metadata_impl()
    self._add_egg_info_requires(metadata)
    return metadata

@property
def metadata_dict(self) -&gt; dict[str, Any]:
    &quot;&quot;&quot;PEP 566 compliant JSON-serializable representation of METADATA or PKG-INFO.

    This should return an empty dict if the metadata file is unavailable.

    :raises NoneMetadataError: If the metadata file is available, but does
        not contain valid metadata.
    &quot;&quot;&quot;
    return msg_to_json(self.metadata)

@property
def metadata_version(self) -&gt; str | None:
    &quot;&quot;&quot;Value of &quot;Metadata-Version:&quot; in distribution metadata, if available.&quot;&quot;&quot;
    return self.metadata.get(&quot;Metadata-Version&quot;)

@property
def raw_name(self) -&gt; str:
    &quot;&quot;&quot;Value of &quot;Name:&quot; in distribution metadata.&quot;&quot;&quot;
    # The metadata should NEVER be missing the Name: key, but if it somehow
    # does, fall back to the known canonical name.
    return self.metadata.get(&quot;Name&quot;, self.canonical_name)

@property
def requires_python(self) -&gt; SpecifierSet:
    &quot;&quot;&quot;Value of &quot;Requires-Python:&quot; in distribution metadata.

    If the key does not exist or contains an invalid value, an empty
    SpecifierSet should be returned.
    &quot;&quot;&quot;
    value = self.metadata.get(&quot;Requires-Python&quot;)
    if value is None:
        return SpecifierSet()
    try:
        # Convert to str to satisfy the type checker; this can be a Header object.
        spec = SpecifierSet(str(value))
    except InvalidSpecifier as e:
        message = &quot;Package %r has an invalid Requires-Python: %s&quot;
        logger.warning(message, self.raw_name, e)
        return SpecifierSet()
    return spec

def iter_dependencies(self, extras: Collection[str] = ()) -&gt; Iterable[Requirement]:
    &quot;&quot;&quot;Dependencies of this distribution.

    For modern .dist-info distributions, this is the collection of
    &quot;Requires-Dist:&quot; entries in distribution metadata.
    &quot;&quot;&quot;
    raise NotImplementedError()

def iter_raw_dependencies(self) -&gt; Iterable[str]:
    &quot;&quot;&quot;Raw Requires-Dist metadata.&quot;&quot;&quot;
    return self.metadata.get_all(&quot;Requires-Dist&quot;, [])

def iter_provided_extras(self) -&gt; Iterable[NormalizedName]:
    &quot;&quot;&quot;Extras provided by this distribution.

    For modern .dist-info distributions, this is the collection of
    &quot;Provides-Extra:&quot; entries in distribution metadata.

    The return value of this function is expected to be normalised names,
    per PEP 685, with the returned value being handled appropriately by
    `iter_dependencies`.
    &quot;&quot;&quot;
    raise NotImplementedError()

def _iter_declared_entries_from_record(self) -&gt; Iterator[str] | None:
    try:
        text = self.read_text(&quot;RECORD&quot;)
    except FileNotFoundError:
        return None
    # This extra Path-str cast normalizes entries.
    return (str(pathlib.Path(row[0])) for row in csv.reader(text.splitlines()))

def _iter_declared_entries_from_legacy(self) -&gt; Iterator[str] | None:
    try:
        text = self.read_text(&quot;installed-files.txt&quot;)
    except FileNotFoundError:
        return None
    paths = (p for p in text.splitlines(keepends=False) if p)
    root = self.location
    info = self.info_location
    if root is None or info is None:
        return paths
    try:
        info_rel = pathlib.Path(info).relative_to(root)
    except ValueError:  # info is not relative to root.
        return paths
    if not info_rel.parts:  # info *is* root.
        return paths
    return (
        _convert_installed_files_path(pathlib.Path(p).parts, info_rel.parts)
        for p in paths
    )

def iter_declared_entries(self) -&gt; Iterator[str] | None:
    &quot;&quot;&quot;Iterate through file entries declared in this distribution.

    For modern .dist-info distributions, this is the files listed in the
    ``RECORD`` metadata file. For legacy setuptools distributions, this
    comes from ``installed-files.txt``, with entries normalized to be
    compatible with the format used by ``RECORD``.

    :return: An iterator for listed entries, or None if the distribution
        contains neither ``RECORD`` nor ``installed-files.txt``.
    &quot;&quot;&quot;
    return (
        self._iter_declared_entries_from_record()
        or self._iter_declared_entries_from_legacy()
    )

def _iter_requires_txt_entries(self) -&gt; Iterator[RequiresEntry]:
    &quot;&quot;&quot;Parse a ``requires.txt`` in an egg-info directory.

    This is an INI-ish format where an egg-info stores dependencies. A
    section name describes extra other environment markers, while each entry
    is an arbitrary string (not a key-value pair) representing a dependency
    as a requirement string (no markers).

    There is a construct in ``importlib.metadata`` called ``Sectioned`` that
    does mostly the same, but the format is currently considered private.
    &quot;&quot;&quot;
    try:
        content = self.read_text(&quot;requires.txt&quot;)
    except FileNotFoundError:
        return
    extra = marker = &quot;&quot;  # Section-less entries don&#39;t have markers.
    for line in content.splitlines():
        line = line.strip()
        if not line or line.startswith(&quot;#&quot;):  # Comment; ignored.
            continue
        if line.startswith(&quot;[&quot;) and line.endswith(&quot;]&quot;):  # A section header.
            extra, _, marker = line.strip(&quot;[]&quot;).partition(&quot;:&quot;)
            continue
        yield RequiresEntry(requirement=line, extra=extra, marker=marker)

def _iter_egg_info_extras(self) -&gt; Iterable[str]:
    &quot;&quot;&quot;Get extras from the egg-info directory.&quot;&quot;&quot;
    known_extras = {&quot;&quot;}
    for entry in self._iter_requires_txt_entries():
        extra = canonicalize_name(entry.extra)
        if extra in known_extras:
            continue
        known_extras.add(extra)
        yield extra

def _iter_egg_info_dependencies(self) -&gt; Iterable[str]:
    &quot;&quot;&quot;Get distribution dependencies from the egg-info directory.

    To ease parsing, this converts a legacy dependency entry into a PEP 508
    requirement string. Like ``_iter_requires_txt_entries()``, there is code
    in ``importlib.metadata`` that does mostly the same, but not do exactly
    what we need.

    Namely, ``importlib.metadata`` does not normalize the extra name before
    putting it into the requirement string, which causes marker comparison
    to fail because the dist-info format do normalize. This is consistent in
    all currently available PEP 517 backends, although not standardized.
    &quot;&quot;&quot;
    for entry in self._iter_requires_txt_entries():
        extra = canonicalize_name(entry.extra)
        if extra and entry.marker:
            marker = f&#39;({entry.marker}) and extra == &quot;{extra}&quot;&#39;
        elif extra:
            marker = f&#39;extra == &quot;{extra}&quot;&#39;
        elif entry.marker:
            marker = entry.marker
        else:
            marker = &quot;&quot;
        if marker:
            yield f&quot;{entry.requirement} ; {marker}&quot;
        else:
            yield entry.requirement

def _add_egg_info_requires(self, metadata: email.message.Message) -&gt; None:
    &quot;&quot;&quot;Add egg-info requires.txt information to the metadata.&quot;&quot;&quot;
    if not metadata.get_all(&quot;Requires-Dist&quot;):
        for dep in self._iter_egg_info_dependencies():
            metadata[&quot;Requires-Dist&quot;] = dep
    if not metadata.get_all(&quot;Provides-Extra&quot;):
        for extra in self._iter_egg_info_extras():
            metadata[&quot;Provides-Extra&quot;] = extra
</pre></div>
</div>
<p>class BaseEnvironment:
“””An environment containing distributions to introspect.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@classmethod
def default(cls) -&gt; BaseEnvironment:
    raise NotImplementedError()

@classmethod
def from_paths(cls, paths: list[str] | None) -&gt; BaseEnvironment:
    raise NotImplementedError()

def get_distribution(self, name: str) -&gt; BaseDistribution | None:
    &quot;&quot;&quot;Given a requirement name, return the installed distributions.

    The name may not be normalized. The implementation must canonicalize
    it for lookup.
    &quot;&quot;&quot;
    raise NotImplementedError()

def _iter_distributions(self) -&gt; Iterator[BaseDistribution]:
    &quot;&quot;&quot;Iterate through installed distributions.

    This function should be implemented by subclass, but never called
    directly. Use the public ``iter_distribution()`` instead, which
    implements additional logic to make sure the distributions are valid.
    &quot;&quot;&quot;
    raise NotImplementedError()

def iter_all_distributions(self) -&gt; Iterator[BaseDistribution]:
    &quot;&quot;&quot;Iterate through all installed distributions without any filtering.&quot;&quot;&quot;
    for dist in self._iter_distributions():
        # Make sure the distribution actually comes from a valid Python
        # packaging distribution. Pip&#39;s AdjacentTempDirectory leaves folders
        # e.g. ``~atplotlib.dist-info`` if cleanup was interrupted. The
        # valid project name pattern is taken from PEP 508.
        project_name_valid = re.match(
            r&quot;^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$&quot;,
            dist.canonical_name,
            flags=re.IGNORECASE,
        )
        if not project_name_valid:
            logger.warning(
                &quot;Ignoring invalid distribution %s (%s)&quot;,
                dist.canonical_name,
                dist.location,
            )
            continue
        yield dist

def iter_installed_distributions(
    self,
    local_only: bool = True,
    skip: Container[str] = stdlib_pkgs,
    include_editables: bool = True,
    editables_only: bool = False,
    user_only: bool = False,
) -&gt; Iterator[BaseDistribution]:
    &quot;&quot;&quot;Return a list of installed distributions.

    This is based on ``iter_all_distributions()`` with additional filtering
    options. Note that ``iter_installed_distributions()`` without arguments
    is *not* equal to ``iter_all_distributions()``, since some of the
    configurations exclude packages by default.

    :param local_only: If True (default), only return installations
    local to the current virtualenv, if in a virtualenv.
    :param skip: An iterable of canonicalized project names to ignore;
        defaults to ``stdlib_pkgs``.
    :param include_editables: If False, don&#39;t report editables.
    :param editables_only: If True, only report editables.
    :param user_only: If True, only report installations in the user
    site directory.
    &quot;&quot;&quot;
    it = self.iter_all_distributions()
    if local_only:
        it = (d for d in it if d.local)
    if not include_editables:
        it = (d for d in it if not d.editable)
    if editables_only:
        it = (d for d in it if d.editable)
    if user_only:
        it = (d for d in it if d.in_usersite)
    return (d for d in it if d.canonical_name not in skip)
</pre></div>
</div>
<p>class Wheel(Protocol):
location: str</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def as_zipfile(self) -&gt; zipfile.ZipFile:
    raise NotImplementedError()
</pre></div>
</div>
<p>class FilesystemWheel(Wheel):
def <strong>init</strong>(self, location: str) -&gt; None:
self.location = location</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def as_zipfile(self) -&gt; zipfile.ZipFile:
    return zipfile.ZipFile(self.location, allowZip64=True)
</pre></div>
</div>
<p>class MemoryWheel(Wheel):
def <strong>init</strong>(self, location: str, stream: IO[bytes]) -&gt; None:
self.location = location
self.stream = stream</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def as_zipfile(self) -&gt; zipfile.ZipFile:
    return zipfile.ZipFile(self.stream, allowZip64=True)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>