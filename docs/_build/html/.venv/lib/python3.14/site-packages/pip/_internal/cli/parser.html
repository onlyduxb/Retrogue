

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/cli/parser.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Base option parser setup”””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import logging
import optparse
import shutil
import sys
import textwrap
from collections.abc import Generator
from contextlib import suppress
from typing import Any, NoReturn</p>
<p>from pip._internal.cli.status_codes import UNKNOWN_ERROR
from pip._internal.configuration import Configuration, ConfigurationError
from pip._internal.utils.misc import redact_auth_from_url, strtobool</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
“””A prettier/less verbose help formatter for optparse.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
    # help position must be aligned with __init__.parseopts.description
    kwargs[&quot;max_help_position&quot;] = 30
    kwargs[&quot;indent_increment&quot;] = 1
    kwargs[&quot;width&quot;] = shutil.get_terminal_size()[0] - 2
    super().__init__(*args, **kwargs)

def format_option_strings(self, option: optparse.Option) -&gt; str:
    return self._format_option_strings(option)

def _format_option_strings(
    self, option: optparse.Option, mvarfmt: str = &quot; &lt;{}&gt;&quot;, optsep: str = &quot;, &quot;
) -&gt; str:
    &quot;&quot;&quot;
    Return a comma-separated list of option strings and metavars.

    :param option:  tuple of (short opt, long opt), e.g: (&#39;-f&#39;, &#39;--format&#39;)
    :param mvarfmt: metavar format string
    :param optsep:  separator
    &quot;&quot;&quot;
    opts = []

    if option._short_opts:
        opts.append(option._short_opts[0])
    if option._long_opts:
        opts.append(option._long_opts[0])
    if len(opts) &gt; 1:
        opts.insert(1, optsep)

    if option.takes_value():
        assert option.dest is not None
        metavar = option.metavar or option.dest.lower()
        opts.append(mvarfmt.format(metavar.lower()))

    return &quot;&quot;.join(opts)

def format_heading(self, heading: str) -&gt; str:
    if heading == &quot;Options&quot;:
        return &quot;&quot;
    return heading + &quot;:\n&quot;

def format_usage(self, usage: str) -&gt; str:
    &quot;&quot;&quot;
    Ensure there is only one newline between usage and the first heading
    if there is no description.
    &quot;&quot;&quot;
    msg = &quot;\nUsage: {}\n&quot;.format(self.indent_lines(textwrap.dedent(usage), &quot;  &quot;))
    return msg

def format_description(self, description: str | None) -&gt; str:
    # leave full control over description to us
    if description:
        if hasattr(self.parser, &quot;main&quot;):
            label = &quot;Commands&quot;
        else:
            label = &quot;Description&quot;
        # some doc strings have initial newlines, some don&#39;t
        description = description.lstrip(&quot;\n&quot;)
        # some doc strings have final newlines and spaces, some don&#39;t
        description = description.rstrip()
        # dedent, then reindent
        description = self.indent_lines(textwrap.dedent(description), &quot;  &quot;)
        description = f&quot;{label}:\n{description}\n&quot;
        return description
    else:
        return &quot;&quot;

def format_epilog(self, epilog: str | None) -&gt; str:
    # leave full control over epilog to us
    if epilog:
        return epilog
    else:
        return &quot;&quot;

def indent_lines(self, text: str, indent: str) -&gt; str:
    new_lines = [indent + line for line in text.split(&quot;\n&quot;)]
    return &quot;\n&quot;.join(new_lines)
</pre></div>
</div>
<p>class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
“””Custom help formatter for use in ConfigOptionParser.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is updates the defaults before expanding them, allowing
them to show up correctly in the help listing.

Also redact auth from url type options
&quot;&quot;&quot;

def expand_default(self, option: optparse.Option) -&gt; str:
    default_values = None
    if self.parser is not None:
        assert isinstance(self.parser, ConfigOptionParser)
        self.parser._update_defaults(self.parser.defaults)
        assert option.dest is not None
        default_values = self.parser.defaults.get(option.dest)
    help_text = super().expand_default(option)

    if default_values and option.metavar == &quot;URL&quot;:
        if isinstance(default_values, str):
            default_values = [default_values]

        # If its not a list, we should abort and just return the help text
        if not isinstance(default_values, list):
            default_values = []

        for val in default_values:
            help_text = help_text.replace(val, redact_auth_from_url(val))

    return help_text
</pre></div>
</div>
<p>class CustomOptionParser(optparse.OptionParser):
def insert_option_group(
self, idx: int, *args: Any, **kwargs: Any
) -&gt; optparse.OptionGroup:
“””Insert an OptionGroup at a given position.”””
group = self.add_option_group(*args, **kwargs)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    self.option_groups.pop()
    self.option_groups.insert(idx, group)

    return group

@property
def option_list_all(self) -&gt; list[optparse.Option]:
    &quot;&quot;&quot;Get a list of all options, including those in option groups.&quot;&quot;&quot;
    res = self.option_list[:]
    for i in self.option_groups:
        res.extend(i.option_list)

    return res
</pre></div>
</div>
<p>class ConfigOptionParser(CustomOptionParser):
“””Custom option parser which updates its defaults by checking the
configuration files and environmental variables”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    *args: Any,
    name: str,
    isolated: bool = False,
    **kwargs: Any,
) -&gt; None:
    self.name = name
    self.config = Configuration(isolated)

    assert self.name
    super().__init__(*args, **kwargs)

def check_default(self, option: optparse.Option, key: str, val: Any) -&gt; Any:
    try:
        return option.check_value(key, val)
    except optparse.OptionValueError as exc:
        print(f&quot;An error occurred during configuration: {exc}&quot;)
        sys.exit(3)

def _get_ordered_configuration_items(
    self,
) -&gt; Generator[tuple[str, Any], None, None]:
    # Configuration gives keys in an unordered manner. Order them.
    override_order = [&quot;global&quot;, self.name, &quot;:env:&quot;]

    # Pool the options into different groups
    section_items: dict[str, list[tuple[str, Any]]] = {
        name: [] for name in override_order
    }

    for _, value in self.config.items():  # noqa: PERF102
        for section_key, val in value.items():
            # ignore empty values
            if not val:
                logger.debug(
                    &quot;Ignoring configuration key &#39;%s&#39; as its value is empty.&quot;,
                    section_key,
                )
                continue

            section, key = section_key.split(&quot;.&quot;, 1)
            if section in override_order:
                section_items[section].append((key, val))

    # Yield each group in their override order
    for section in override_order:
        yield from section_items[section]

def _update_defaults(self, defaults: dict[str, Any]) -&gt; dict[str, Any]:
    &quot;&quot;&quot;Updates the given defaults with values from the config files and
    the environ. Does a little special handling for certain types of
    options (lists).&quot;&quot;&quot;

    # Accumulate complex default state.
    self.values = optparse.Values(self.defaults)
    late_eval = set()
    # Then set the options with those values
    for key, val in self._get_ordered_configuration_items():
        # &#39;--&#39; because configuration supports only long names
        option = self.get_option(&quot;--&quot; + key)

        # Ignore options not present in this parser. E.g. non-globals put
        # in [global] by users that want them to apply to all applicable
        # commands.
        if option is None:
            continue

        assert option.dest is not None

        if option.action in (&quot;store_true&quot;, &quot;store_false&quot;):
            try:
                val = strtobool(val)
            except ValueError:
                self.error(
                    f&quot;{val} is not a valid value for {key} option, &quot;
                    &quot;please specify a boolean value like yes/no, &quot;
                    &quot;true/false or 1/0 instead.&quot;
                )
        elif option.action == &quot;count&quot;:
            with suppress(ValueError):
                val = strtobool(val)
            with suppress(ValueError):
                val = int(val)
            if not isinstance(val, int) or val &lt; 0:
                self.error(
                    f&quot;{val} is not a valid value for {key} option, &quot;
                    &quot;please instead specify either a non-negative integer &quot;
                    &quot;or a boolean value like yes/no or false/true &quot;
                    &quot;which is equivalent to 1/0.&quot;
                )
        elif option.action == &quot;append&quot;:
            val = val.split()
            val = [self.check_default(option, key, v) for v in val]
        elif option.action == &quot;callback&quot;:
            assert option.callback is not None
            late_eval.add(option.dest)
            opt_str = option.get_opt_string()
            val = option.convert_value(opt_str, val)
            # From take_action
            args = option.callback_args or ()
            kwargs = option.callback_kwargs or {}
            option.callback(option, opt_str, val, self, *args, **kwargs)
        else:
            val = self.check_default(option, key, val)

        defaults[option.dest] = val

    for key in late_eval:
        defaults[key] = getattr(self.values, key)
    self.values = None
    return defaults

def get_default_values(self) -&gt; optparse.Values:
    &quot;&quot;&quot;Overriding to make updating the defaults after instantiation of
    the option parser possible, _update_defaults() does the dirty work.&quot;&quot;&quot;
    if not self.process_default_values:
        # Old, pre-Optik 1.5 behaviour.
        return optparse.Values(self.defaults)

    # Load the configuration, or error out in case of an error
    try:
        self.config.load()
    except ConfigurationError as err:
        self.exit(UNKNOWN_ERROR, str(err))

    defaults = self._update_defaults(self.defaults.copy())  # ours
    for option in self._get_all_options():
        assert option.dest is not None
        default = defaults.get(option.dest)
        if isinstance(default, str):
            opt_str = option.get_opt_string()
            defaults[option.dest] = option.check_value(opt_str, default)
    return optparse.Values(defaults)

def error(self, msg: str) -&gt; NoReturn:
    self.print_usage(sys.stderr)
    self.exit(UNKNOWN_ERROR, f&quot;{msg}\n&quot;)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>