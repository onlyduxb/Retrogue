

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/requests/cookies.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
requests.cookies</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
Compatibility code to be able to use `http.cookiejar.CookieJar` with requests.

requests.utils imports from here, so be careful with imports.
&quot;&quot;&quot;

import calendar
import copy
import time

from ._internal_utils import to_native_string
from .compat import Morsel, MutableMapping, cookielib, urlparse, urlunparse

try:
    import threading
except ImportError:
    import dummy_threading as threading


class MockRequest:
    &quot;&quot;&quot;Wraps a `requests.Request` to mimic a `urllib2.Request`.

    The code in `http.cookiejar.CookieJar` expects this interface in order to correctly
    manage cookie policies, i.e., determine whether a cookie can be set, given the
    domains of the request and the cookie.

    The original request object is read-only. The client is responsible for collecting
    the new headers via `get_new_headers()` and interpreting them appropriately. You
    probably want `get_cookie_header`, defined below.
    &quot;&quot;&quot;

    def __init__(self, request):
        self._r = request
        self._new_headers = {}
        self.type = urlparse(self._r.url).scheme

    def get_type(self):
        return self.type

    def get_host(self):
        return urlparse(self._r.url).netloc

    def get_origin_req_host(self):
        return self.get_host()

    def get_full_url(self):
        # Only return the response&#39;s URL if the user hadn&#39;t set the Host
        # header
        if not self._r.headers.get(&quot;Host&quot;):
            return self._r.url
        # If they did set it, retrieve it and reconstruct the expected domain
        host = to_native_string(self._r.headers[&quot;Host&quot;], encoding=&quot;utf-8&quot;)
        parsed = urlparse(self._r.url)
        # Reconstruct the URL as we expect it
        return urlunparse(
            [
                parsed.scheme,
                host,
                parsed.path,
                parsed.params,
                parsed.query,
                parsed.fragment,
            ]
        )

    def is_unverifiable(self):
        return True

    def has_header(self, name):
        return name in self._r.headers or name in self._new_headers

    def get_header(self, name, default=None):
        return self._r.headers.get(name, self._new_headers.get(name, default))

    def add_header(self, key, val):
        &quot;&quot;&quot;cookiejar has no legitimate use for this method; add it back if you find one.&quot;&quot;&quot;
        raise NotImplementedError(
            &quot;Cookie headers should be added with add_unredirected_header()&quot;
        )

    def add_unredirected_header(self, name, value):
        self._new_headers[name] = value

    def get_new_headers(self):
        return self._new_headers

    @property
    def unverifiable(self):
        return self.is_unverifiable()

    @property
    def origin_req_host(self):
        return self.get_origin_req_host()

    @property
    def host(self):
        return self.get_host()


class MockResponse:
    &quot;&quot;&quot;Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.

    ...what? Basically, expose the parsed HTTP headers from the server response
    the way `http.cookiejar` expects to see them.
    &quot;&quot;&quot;

    def __init__(self, headers):
        &quot;&quot;&quot;Make a MockResponse for `cookiejar` to read.

        :param headers: a httplib.HTTPMessage or analogous carrying the headers
        &quot;&quot;&quot;
        self._headers = headers

    def info(self):
        return self._headers

    def getheaders(self, name):
        self._headers.getheaders(name)


def extract_cookies_to_jar(jar, request, response):
    &quot;&quot;&quot;Extract the cookies from the response into a CookieJar.

    :param jar: http.cookiejar.CookieJar (not necessarily a RequestsCookieJar)
    :param request: our own requests.Request object
    :param response: urllib3.HTTPResponse object
    &quot;&quot;&quot;
    if not (hasattr(response, &quot;_original_response&quot;) and response._original_response):
        return
    # the _original_response field is the wrapped httplib.HTTPResponse object,
    req = MockRequest(request)
    # pull out the HTTPMessage with the headers and put it in the mock:
    res = MockResponse(response._original_response.msg)
    jar.extract_cookies(res, req)


def get_cookie_header(jar, request):
    &quot;&quot;&quot;
    Produce an appropriate Cookie header string to be sent with `request`, or None.

    :rtype: str
    &quot;&quot;&quot;
    r = MockRequest(request)
    jar.add_cookie_header(r)
    return r.get_new_headers().get(&quot;Cookie&quot;)


def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
    &quot;&quot;&quot;Unsets a cookie by name, by default over all domains and paths.

    Wraps CookieJar.clear(), is O(n).
    &quot;&quot;&quot;
    clearables = []
    for cookie in cookiejar:
        if cookie.name != name:
            continue
        if domain is not None and domain != cookie.domain:
            continue
        if path is not None and path != cookie.path:
            continue
        clearables.append((cookie.domain, cookie.path, cookie.name))

    for domain, path, name in clearables:
        cookiejar.clear(domain, path, name)


class CookieConflictError(RuntimeError):
    &quot;&quot;&quot;There are two cookies that meet the criteria specified in the cookie jar.
    Use .get and .set and include domain and path args in order to be more specific.
    &quot;&quot;&quot;


class RequestsCookieJar(cookielib.CookieJar, MutableMapping):
    &quot;&quot;&quot;Compatibility class; is a http.cookiejar.CookieJar, but exposes a dict
    interface.

    This is the CookieJar we create by default for requests and sessions that
    don&#39;t specify one, since some clients may expect response.cookies and
    session.cookies to support dict operations.

    Requests does not use the dict interface internally; it&#39;s just for
    compatibility with external client code. All requests code should work
    out of the box with externally provided instances of ``CookieJar``, e.g.
    ``LWPCookieJar`` and ``FileCookieJar``.

    Unlike a regular CookieJar, this class is pickleable.

    .. warning:: dictionary operations that are normally O(1) may be O(n).
    &quot;&quot;&quot;

    def get(self, name, default=None, domain=None, path=None):
        &quot;&quot;&quot;Dict-like get() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains.

        .. warning:: operation is O(n), not O(1).
        &quot;&quot;&quot;
        try:
            return self._find_no_duplicates(name, domain, path)
        except KeyError:
            return default

    def set(self, name, value, **kwargs):
        &quot;&quot;&quot;Dict-like set() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains.
        &quot;&quot;&quot;
        # support client code that unsets cookies by assignment of a None value:
        if value is None:
            remove_cookie_by_name(
                self, name, domain=kwargs.get(&quot;domain&quot;), path=kwargs.get(&quot;path&quot;)
            )
            return

        if isinstance(value, Morsel):
            c = morsel_to_cookie(value)
        else:
            c = create_cookie(name, value, **kwargs)
        self.set_cookie(c)
        return c

    def iterkeys(self):
        &quot;&quot;&quot;Dict-like iterkeys() that returns an iterator of names of cookies
        from the jar.

        .. seealso:: itervalues() and iteritems().
        &quot;&quot;&quot;
        for cookie in iter(self):
            yield cookie.name

    def keys(self):
        &quot;&quot;&quot;Dict-like keys() that returns a list of names of cookies from the
        jar.

        .. seealso:: values() and items().
        &quot;&quot;&quot;
        return list(self.iterkeys())

    def itervalues(self):
        &quot;&quot;&quot;Dict-like itervalues() that returns an iterator of values of cookies
        from the jar.

        .. seealso:: iterkeys() and iteritems().
        &quot;&quot;&quot;
        for cookie in iter(self):
            yield cookie.value

    def values(self):
        &quot;&quot;&quot;Dict-like values() that returns a list of values of cookies from the
        jar.

        .. seealso:: keys() and items().
        &quot;&quot;&quot;
        return list(self.itervalues())

    def iteritems(self):
        &quot;&quot;&quot;Dict-like iteritems() that returns an iterator of name-value tuples
        from the jar.

        .. seealso:: iterkeys() and itervalues().
        &quot;&quot;&quot;
        for cookie in iter(self):
            yield cookie.name, cookie.value

    def items(self):
        &quot;&quot;&quot;Dict-like items() that returns a list of name-value tuples from the
        jar. Allows client-code to call ``dict(RequestsCookieJar)`` and get a
        vanilla python dict of key value pairs.

        .. seealso:: keys() and values().
        &quot;&quot;&quot;
        return list(self.iteritems())

    def list_domains(self):
        &quot;&quot;&quot;Utility method to list all the domains in the jar.&quot;&quot;&quot;
        domains = []
        for cookie in iter(self):
            if cookie.domain not in domains:
                domains.append(cookie.domain)
        return domains

    def list_paths(self):
        &quot;&quot;&quot;Utility method to list all the paths in the jar.&quot;&quot;&quot;
        paths = []
        for cookie in iter(self):
            if cookie.path not in paths:
                paths.append(cookie.path)
        return paths

    def multiple_domains(self):
        &quot;&quot;&quot;Returns True if there are multiple domains in the jar.
        Returns False otherwise.

        :rtype: bool
        &quot;&quot;&quot;
        domains = []
        for cookie in iter(self):
            if cookie.domain is not None and cookie.domain in domains:
                return True
            domains.append(cookie.domain)
        return False  # there is only one domain in jar

    def get_dict(self, domain=None, path=None):
        &quot;&quot;&quot;Takes as an argument an optional domain and path and returns a plain
        old Python dict of name-value pairs of cookies that meet the
        requirements.

        :rtype: dict
        &quot;&quot;&quot;
        dictionary = {}
        for cookie in iter(self):
            if (domain is None or cookie.domain == domain) and (
                path is None or cookie.path == path
            ):
                dictionary[cookie.name] = cookie.value
        return dictionary

    def __contains__(self, name):
        try:
            return super().__contains__(name)
        except CookieConflictError:
            return True

    def __getitem__(self, name):
        &quot;&quot;&quot;Dict-like __getitem__() for compatibility with client code. Throws
        exception if there are more than one cookie with name. In that case,
        use the more explicit get() method instead.

        .. warning:: operation is O(n), not O(1).
        &quot;&quot;&quot;
        return self._find_no_duplicates(name)

    def __setitem__(self, name, value):
        &quot;&quot;&quot;Dict-like __setitem__ for compatibility with client code. Throws
        exception if there is already a cookie of that name in the jar. In that
        case, use the more explicit set() method instead.
        &quot;&quot;&quot;
        self.set(name, value)

    def __delitem__(self, name):
        &quot;&quot;&quot;Deletes a cookie given a name. Wraps ``http.cookiejar.CookieJar``&#39;s
        ``remove_cookie_by_name()``.
        &quot;&quot;&quot;
        remove_cookie_by_name(self, name)

    def set_cookie(self, cookie, *args, **kwargs):
        if (
            hasattr(cookie.value, &quot;startswith&quot;)
            and cookie.value.startswith(&#39;&quot;&#39;)
            and cookie.value.endswith(&#39;&quot;&#39;)
        ):
            cookie.value = cookie.value.replace(&#39;\\&quot;&#39;, &quot;&quot;)
        return super().set_cookie(cookie, *args, **kwargs)

    def update(self, other):
        &quot;&quot;&quot;Updates this jar with cookies from another CookieJar or dict-like&quot;&quot;&quot;
        if isinstance(other, cookielib.CookieJar):
            for cookie in other:
                self.set_cookie(copy.copy(cookie))
        else:
            super().update(other)

    def _find(self, name, domain=None, path=None):
        &quot;&quot;&quot;Requests uses this method internally to get cookie values.

        If there are conflicting cookies, _find arbitrarily chooses one.
        See _find_no_duplicates if you want an exception thrown if there are
        conflicting cookies.

        :param name: a string containing name of cookie
        :param domain: (optional) string containing domain of cookie
        :param path: (optional) string containing path of cookie
        :return: cookie.value
        &quot;&quot;&quot;
        for cookie in iter(self):
            if cookie.name == name:
                if domain is None or cookie.domain == domain:
                    if path is None or cookie.path == path:
                        return cookie.value

        raise KeyError(f&quot;name={name!r}, domain={domain!r}, path={path!r}&quot;)

    def _find_no_duplicates(self, name, domain=None, path=None):
        &quot;&quot;&quot;Both ``__get_item__`` and ``get`` call this function: it&#39;s never
        used elsewhere in Requests.

        :param name: a string containing name of cookie
        :param domain: (optional) string containing domain of cookie
        :param path: (optional) string containing path of cookie
        :raises KeyError: if cookie is not found
        :raises CookieConflictError: if there are multiple cookies
            that match name and optionally domain and path
        :return: cookie.value
        &quot;&quot;&quot;
        toReturn = None
        for cookie in iter(self):
            if cookie.name == name:
                if domain is None or cookie.domain == domain:
                    if path is None or cookie.path == path:
                        if toReturn is not None:
                            # if there are multiple cookies that meet passed in criteria
                            raise CookieConflictError(
                                f&quot;There are multiple cookies with name, {name!r}&quot;
                            )
                        # we will eventually return this as long as no cookie conflict
                        toReturn = cookie.value

        if toReturn:
            return toReturn
        raise KeyError(f&quot;name={name!r}, domain={domain!r}, path={path!r}&quot;)

    def __getstate__(self):
        &quot;&quot;&quot;Unlike a normal CookieJar, this class is pickleable.&quot;&quot;&quot;
        state = self.__dict__.copy()
        # remove the unpickleable RLock object
        state.pop(&quot;_cookies_lock&quot;)
        return state

    def __setstate__(self, state):
        &quot;&quot;&quot;Unlike a normal CookieJar, this class is pickleable.&quot;&quot;&quot;
        self.__dict__.update(state)
        if &quot;_cookies_lock&quot; not in self.__dict__:
            self._cookies_lock = threading.RLock()

    def copy(self):
        &quot;&quot;&quot;Return a copy of this RequestsCookieJar.&quot;&quot;&quot;
        new_cj = RequestsCookieJar()
        new_cj.set_policy(self.get_policy())
        new_cj.update(self)
        return new_cj

    def get_policy(self):
        &quot;&quot;&quot;Return the CookiePolicy instance used.&quot;&quot;&quot;
        return self._policy


def _copy_cookie_jar(jar):
    if jar is None:
        return None

    if hasattr(jar, &quot;copy&quot;):
        # We&#39;re dealing with an instance of RequestsCookieJar
        return jar.copy()
    # We&#39;re dealing with a generic CookieJar instance
    new_jar = copy.copy(jar)
    new_jar.clear()
    for cookie in jar:
        new_jar.set_cookie(copy.copy(cookie))
    return new_jar


def create_cookie(name, value, **kwargs):
    &quot;&quot;&quot;Make a cookie from underspecified parameters.

    By default, the pair of `name` and `value` will be set for the domain &#39;&#39;
    and sent on every request (this is sometimes called a &quot;supercookie&quot;).
    &quot;&quot;&quot;
    result = {
        &quot;version&quot;: 0,
        &quot;name&quot;: name,
        &quot;value&quot;: value,
        &quot;port&quot;: None,
        &quot;domain&quot;: &quot;&quot;,
        &quot;path&quot;: &quot;/&quot;,
        &quot;secure&quot;: False,
        &quot;expires&quot;: None,
        &quot;discard&quot;: True,
        &quot;comment&quot;: None,
        &quot;comment_url&quot;: None,
        &quot;rest&quot;: {&quot;HttpOnly&quot;: None},
        &quot;rfc2109&quot;: False,
    }

    badargs = set(kwargs) - set(result)
    if badargs:
        raise TypeError(
            f&quot;create_cookie() got unexpected keyword arguments: {list(badargs)}&quot;
        )

    result.update(kwargs)
    result[&quot;port_specified&quot;] = bool(result[&quot;port&quot;])
    result[&quot;domain_specified&quot;] = bool(result[&quot;domain&quot;])
    result[&quot;domain_initial_dot&quot;] = result[&quot;domain&quot;].startswith(&quot;.&quot;)
    result[&quot;path_specified&quot;] = bool(result[&quot;path&quot;])

    return cookielib.Cookie(**result)


def morsel_to_cookie(morsel):
    &quot;&quot;&quot;Convert a Morsel object into a Cookie containing the one k/v pair.&quot;&quot;&quot;

    expires = None
    if morsel[&quot;max-age&quot;]:
        try:
            expires = int(time.time() + int(morsel[&quot;max-age&quot;]))
        except ValueError:
            raise TypeError(f&quot;max-age: {morsel[&#39;max-age&#39;]} must be integer&quot;)
    elif morsel[&quot;expires&quot;]:
        time_template = &quot;%a, %d-%b-%Y %H:%M:%S GMT&quot;
        expires = calendar.timegm(time.strptime(morsel[&quot;expires&quot;], time_template))
    return create_cookie(
        comment=morsel[&quot;comment&quot;],
        comment_url=bool(morsel[&quot;comment&quot;]),
        discard=False,
        domain=morsel[&quot;domain&quot;],
        expires=expires,
        name=morsel.key,
        path=morsel[&quot;path&quot;],
        port=None,
        rest={&quot;HttpOnly&quot;: morsel[&quot;httponly&quot;]},
        rfc2109=False,
        secure=bool(morsel[&quot;secure&quot;]),
        value=morsel.value,
        version=morsel[&quot;version&quot;] or 0,
    )


def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
    &quot;&quot;&quot;Returns a CookieJar from a key/value dictionary.

    :param cookie_dict: Dict of key/values to insert into CookieJar.
    :param cookiejar: (optional) A cookiejar to add the cookies to.
    :param overwrite: (optional) If False, will not replace cookies
        already in the jar with new ones.
    :rtype: CookieJar
    &quot;&quot;&quot;
    if cookiejar is None:
        cookiejar = RequestsCookieJar()

    if cookie_dict is not None:
        names_from_jar = [cookie.name for cookie in cookiejar]
        for name in cookie_dict:
            if overwrite or (name not in names_from_jar):
                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))

    return cookiejar


def merge_cookies(cookiejar, cookies):
    &quot;&quot;&quot;Add cookies to cookiejar and returns a merged CookieJar.

    :param cookiejar: CookieJar object to add the cookies to.
    :param cookies: Dictionary or CookieJar object to be added.
    :rtype: CookieJar
    &quot;&quot;&quot;
    if not isinstance(cookiejar, cookielib.CookieJar):
        raise ValueError(&quot;You can only merge into CookieJar&quot;)

    if isinstance(cookies, dict):
        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)
    elif isinstance(cookies, cookielib.CookieJar):
        try:
            cookiejar.update(cookies)
        except AttributeError:
            for cookie_in_jar in cookies:
                cookiejar.set_cookie(cookie_in_jar)

    return cookiejar
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>