

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/resolution/resolvelib/resolver.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import contextlib
import functools
import logging
import os
from typing import TYPE_CHECKING, cast</p>
<p>from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.resolvelib import BaseReporter, ResolutionImpossible, ResolutionTooDeep
from pip._vendor.resolvelib import Resolver as RLResolver
from pip._vendor.resolvelib.structs import DirectedGraph</p>
<p>from pip._internal.cache import WheelCache
from pip._internal.exceptions import ResolutionTooDeepError
from pip._internal.index.package_finder import PackageFinder
from pip._internal.operations.prepare import RequirementPreparer
from pip._internal.req.constructors import install_req_extend_extras
from pip._internal.req.req_install import InstallRequirement
from pip._internal.req.req_set import RequirementSet
from pip._internal.resolution.base import BaseResolver, InstallRequirementProvider
from pip._internal.resolution.resolvelib.provider import PipProvider
from pip._internal.resolution.resolvelib.reporter import (
PipDebuggingReporter,
PipReporter,
)
from pip._internal.utils.packaging import get_requirement</p>
<p>from .base import Candidate, Requirement
from .factory import Factory</p>
<p>if TYPE_CHECKING:
from pip._vendor.resolvelib.resolvers import Result as RLResult</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Result = RLResult[Requirement, Candidate, str]
</pre></div>
</div>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>class Resolver(BaseResolver):
_allowed_strategies = {“eager”, “only-if-needed”, “to-satisfy-only”}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    preparer: RequirementPreparer,
    finder: PackageFinder,
    wheel_cache: WheelCache | None,
    make_install_req: InstallRequirementProvider,
    use_user_site: bool,
    ignore_dependencies: bool,
    ignore_installed: bool,
    ignore_requires_python: bool,
    force_reinstall: bool,
    upgrade_strategy: str,
    py_version_info: tuple[int, ...] | None = None,
):
    super().__init__()
    assert upgrade_strategy in self._allowed_strategies

    self.factory = Factory(
        finder=finder,
        preparer=preparer,
        make_install_req=make_install_req,
        wheel_cache=wheel_cache,
        use_user_site=use_user_site,
        force_reinstall=force_reinstall,
        ignore_installed=ignore_installed,
        ignore_requires_python=ignore_requires_python,
        py_version_info=py_version_info,
    )
    self.ignore_dependencies = ignore_dependencies
    self.upgrade_strategy = upgrade_strategy
    self._result: Result | None = None

def resolve(
    self, root_reqs: list[InstallRequirement], check_supported_wheels: bool
) -&gt; RequirementSet:
    collected = self.factory.collect_root_requirements(root_reqs)
    provider = PipProvider(
        factory=self.factory,
        constraints=collected.constraints,
        ignore_dependencies=self.ignore_dependencies,
        upgrade_strategy=self.upgrade_strategy,
        user_requested=collected.user_requested,
    )
    if &quot;PIP_RESOLVER_DEBUG&quot; in os.environ:
        reporter: BaseReporter[Requirement, Candidate, str] = PipDebuggingReporter()
    else:
        reporter = PipReporter(constraints=provider.constraints)

    resolver: RLResolver[Requirement, Candidate, str] = RLResolver(
        provider,
        reporter,
    )

    try:
        limit_how_complex_resolution_can_be = 200000
        result = self._result = resolver.resolve(
            collected.requirements, max_rounds=limit_how_complex_resolution_can_be
        )

    except ResolutionImpossible as e:
        error = self.factory.get_installation_error(
            cast(&quot;ResolutionImpossible[Requirement, Candidate]&quot;, e),
            collected.constraints,
        )
        raise error from e
    except ResolutionTooDeep:
        raise ResolutionTooDeepError from None

    req_set = RequirementSet(check_supported_wheels=check_supported_wheels)
    # process candidates with extras last to ensure their base equivalent is
    # already in the req_set if appropriate.
    # Python&#39;s sort is stable so using a binary key function keeps relative order
    # within both subsets.
    for candidate in sorted(
        result.mapping.values(), key=lambda c: c.name != c.project_name
    ):
        ireq = candidate.get_install_requirement()
        if ireq is None:
            if candidate.name != candidate.project_name:
                # extend existing req&#39;s extras
                with contextlib.suppress(KeyError):
                    req = req_set.get_requirement(candidate.project_name)
                    req_set.add_named_requirement(
                        install_req_extend_extras(
                            req, get_requirement(candidate.name).extras
                        )
                    )
            continue

        # Check if there is already an installation under the same name,
        # and set a flag for later stages to uninstall it, if needed.
        installed_dist = self.factory.get_dist_to_uninstall(candidate)
        if installed_dist is None:
            # There is no existing installation -- nothing to uninstall.
            ireq.should_reinstall = False
        elif self.factory.force_reinstall:
            # The --force-reinstall flag is set -- reinstall.
            ireq.should_reinstall = True
        elif installed_dist.version != candidate.version:
            # The installation is different in version -- reinstall.
            ireq.should_reinstall = True
        elif candidate.is_editable or installed_dist.editable:
            # The incoming distribution is editable, or different in
            # editable-ness to installation -- reinstall.
            ireq.should_reinstall = True
        elif candidate.source_link and candidate.source_link.is_file:
            # The incoming distribution is under file://
            if candidate.source_link.is_wheel:
                # is a local wheel -- do nothing.
                logger.info(
                    &quot;%s is already installed with the same version as the &quot;
                    &quot;provided wheel. Use --force-reinstall to force an &quot;
                    &quot;installation of the wheel.&quot;,
                    ireq.name,
                )
                continue

            # is a local sdist or path -- reinstall
            ireq.should_reinstall = True
        else:
            continue

        link = candidate.source_link
        if link and link.is_yanked:
            # The reason can contain non-ASCII characters, Unicode
            # is required for Python 2.
            msg = (
                &quot;The candidate selected for download or install is a &quot;
                &quot;yanked version: {name!r} candidate (version {version} &quot;
                &quot;at {link})\nReason for being yanked: {reason}&quot;
            ).format(
                name=candidate.name,
                version=candidate.version,
                link=link,
                reason=link.yanked_reason or &quot;&lt;none given&gt;&quot;,
            )
            logger.warning(msg)

        req_set.add_named_requirement(ireq)

    return req_set

def get_installation_order(
    self, req_set: RequirementSet
) -&gt; list[InstallRequirement]:
    &quot;&quot;&quot;Get order for installation of requirements in RequirementSet.

    The returned list contains a requirement before another that depends on
    it. This helps ensure that the environment is kept consistent as they
    get installed one-by-one.

    The current implementation creates a topological ordering of the
    dependency graph, giving more weight to packages with less
    or no dependencies, while breaking any cycles in the graph at
    arbitrary points. We make no guarantees about where the cycle
    would be broken, other than it *would* be broken.
    &quot;&quot;&quot;
    assert self._result is not None, &quot;must call resolve() first&quot;

    if not req_set.requirements:
        # Nothing is left to install, so we do not need an order.
        return []

    graph = self._result.graph
    weights = get_topological_weights(graph, set(req_set.requirements.keys()))

    sorted_items = sorted(
        req_set.requirements.items(),
        key=functools.partial(_req_set_item_sorter, weights=weights),
        reverse=True,
    )
    return [ireq for _, ireq in sorted_items]
</pre></div>
</div>
<p>def get_topological_weights(
graph: DirectedGraph[str | None], requirement_keys: set[str]
) -&gt; dict[str | None, int]:
“””Assign weights to each node based on how “deep” they are.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This implementation may change at any point in the future without prior
notice.

We first simplify the dependency graph by pruning any leaves and giving them
the highest weight: a package without any dependencies should be installed
first. This is done again and again in the same way, giving ever less weight
to the newly found leaves. The loop stops when no leaves are left: all
remaining packages have at least one dependency left in the graph.

Then we continue with the remaining graph, by taking the length for the
longest path to any node from root, ignoring any paths that contain a single
node twice (i.e. cycles). This is done through a depth-first search through
the graph, while keeping track of the path to the node.

Cycles in the graph result would result in node being revisited while also
being on its own path. In this case, take no action. This helps ensure we
don&#39;t get stuck in a cycle.

When assigning weight, the longer path (i.e. larger length) is preferred.

We are only interested in the weights of packages that are in the
requirement_keys.
&quot;&quot;&quot;
path: set[str | None] = set()
weights: dict[str | None, list[int]] = {}

def visit(node: str | None) -&gt; None:
    if node in path:
        # We hit a cycle, so we&#39;ll break it here.
        return

    # The walk is exponential and for pathologically connected graphs (which
    # are the ones most likely to contain cycles in the first place) it can
    # take until the heat-death of the universe. To counter this we limit
    # the number of attempts to visit (i.e. traverse through) any given
    # node. We choose a value here which gives decent enough coverage for
    # fairly well behaved graphs, and still limits the walk complexity to be
    # linear in nature.
    cur_weights = weights.get(node, [])
    if len(cur_weights) &gt;= 5:
        return

    # Time to visit the children!
    path.add(node)
    for child in graph.iter_children(node):
        visit(child)
    path.remove(node)

    if node not in requirement_keys:
        return

    cur_weights.append(len(path))
    weights[node] = cur_weights

# Simplify the graph, pruning leaves that have no dependencies. This is
# needed for large graphs (say over 200 packages) because the `visit`
# function is slower for large/densely connected graphs, taking minutes.
# See https://github.com/pypa/pip/issues/10557
# We repeat the pruning step until we have no more leaves to remove.
while True:
    leaves = set()
    for key in graph:
        if key is None:
            continue
        for _child in graph.iter_children(key):
            # This means we have at least one child
            break
        else:
            # No child.
            leaves.add(key)
    if not leaves:
        # We are done simplifying.
        break
    # Calculate the weight for the leaves.
    weight = len(graph) - 1
    for leaf in leaves:
        if leaf not in requirement_keys:
            continue
        weights[leaf] = [weight]
    # Remove the leaves from the graph, making it simpler.
    for leaf in leaves:
        graph.remove(leaf)

# Visit the remaining graph, this will only have nodes to handle if the
# graph had a cycle in it, which the pruning step above could not handle.
# `None` is guaranteed to be the root node by resolvelib.
visit(None)

# Sanity check: all requirement keys should be in the weights,
# and no other keys should be in the weights.
difference = set(weights.keys()).difference(requirement_keys)
assert not difference, difference

# Now give back all the weights, choosing the largest ones from what we
# accumulated.
return {node: max(wgts) for (node, wgts) in weights.items()}
</pre></div>
</div>
<p>def _req_set_item_sorter(
item: tuple[str, InstallRequirement],
weights: dict[str | None, int],
) -&gt; tuple[int, str]:
“””Key function used to sort install requirements for installation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Based on the &quot;weight&quot; mapping calculated in ``get_installation_order()``.
The canonical package name is returned as the second member as a tie-
breaker to ensure the result is predictable, which is useful in tests.
&quot;&quot;&quot;
name = canonicalize_name(item[0])
return weights[name], name
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>