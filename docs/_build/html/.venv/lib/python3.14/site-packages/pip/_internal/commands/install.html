

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Eagerly import self_outdated_check to avoid crashes. Otherwise, &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Eagerly import self_outdated_check to avoid crashes. Otherwise,</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/commands/install.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import errno
import json
import operator
import os
import shutil
import site
from optparse import SUPPRESS_HELP, Values
from pathlib import Path</p>
<p>from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.requests.exceptions import InvalidProxyURL
from pip._vendor.rich import print_json</p>
<section id="eagerly-import-self-outdated-check-to-avoid-crashes-otherwise">
<h1>Eagerly import self_outdated_check to avoid crashes. Otherwise,<a class="headerlink" href="#eagerly-import-self-outdated-check-to-avoid-crashes-otherwise" title="Link to this heading"></a></h1>
</section>
<section id="this-module-would-be-imported-after-pip-was-replaced-resulting">
<h1>this module would be imported <em>after</em> pip was replaced, resulting<a class="headerlink" href="#this-module-would-be-imported-after-pip-was-replaced-resulting" title="Link to this heading"></a></h1>
</section>
<section id="in-crashes-if-the-new-self-outdated-check-module-was-incompatible">
<h1>in crashes if the new self_outdated_check module was incompatible<a class="headerlink" href="#in-crashes-if-the-new-self-outdated-check-module-was-incompatible" title="Link to this heading"></a></h1>
</section>
<section id="with-the-rest-of-pip-that-s-already-imported-or-allowing-a">
<h1>with the rest of pip that’s already imported, or allowing a<a class="headerlink" href="#with-the-rest-of-pip-that-s-already-imported-or-allowing-a" title="Link to this heading"></a></h1>
</section>
<section id="wheel-to-execute-arbitrary-code-on-install-by-replacing">
<h1>wheel to execute arbitrary code on install by replacing<a class="headerlink" href="#wheel-to-execute-arbitrary-code-on-install-by-replacing" title="Link to this heading"></a></h1>
</section>
<section id="self-outdated-check">
<h1>self_outdated_check.<a class="headerlink" href="#self-outdated-check" title="Link to this heading"></a></h1>
<p>import pip._internal.self_outdated_check  # noqa: F401
from pip._internal.cache import WheelCache
from pip._internal.cli import cmdoptions
from pip._internal.cli.cmdoptions import make_target_python
from pip._internal.cli.req_command import (
RequirementCommand,
with_cleanup,
)
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.exceptions import (
CommandError,
InstallationError,
InstallWheelBuildError,
)
from pip._internal.locations import get_scheme
from pip._internal.metadata import get_environment
from pip._internal.models.installation_report import InstallationReport
from pip._internal.operations.build.build_tracker import get_build_tracker
from pip._internal.operations.check import ConflictDetails, check_install_conflicts
from pip._internal.req import install_given_reqs
from pip._internal.req.req_install import (
InstallRequirement,
)
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.filesystem import test_writable_dir
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import (
check_externally_managed,
ensure_dir,
get_pip_version,
protect_pip_from_modification_on_windows,
warn_if_run_as_root,
write_output,
)
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.virtualenv import (
running_under_virtualenv,
virtualenv_no_global,
)
from pip._internal.wheel_builder import build</p>
<p>logger = getLogger(<strong>name</strong>)</p>
<p>class InstallCommand(RequirementCommand):
“””
Install packages from:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- PyPI (and other indexes) using requirement specifiers.
- VCS project urls.
- Local project directories.
- Local or remote source archives.

pip also supports installing from &quot;requirements files&quot;, which provide
an easy way to specify a whole environment to be installed.
&quot;&quot;&quot;

usage = &quot;&quot;&quot;
  %prog [options] &lt;requirement specifier&gt; [package-index-options] ...
  %prog [options] -r &lt;requirements file&gt; [package-index-options] ...
  %prog [options] [-e] &lt;vcs project url&gt; ...
  %prog [options] [-e] &lt;local project path&gt; ...
  %prog [options] &lt;archive url/path&gt; ...&quot;&quot;&quot;

def add_options(self) -&gt; None:
    self.cmd_opts.add_option(cmdoptions.requirements())
    self.cmd_opts.add_option(cmdoptions.constraints())
    self.cmd_opts.add_option(cmdoptions.build_constraints())
    self.cmd_opts.add_option(cmdoptions.no_deps())
    self.cmd_opts.add_option(cmdoptions.pre())

    self.cmd_opts.add_option(cmdoptions.editable())
    self.cmd_opts.add_option(
        &quot;--dry-run&quot;,
        action=&quot;store_true&quot;,
        dest=&quot;dry_run&quot;,
        default=False,
        help=(
            &quot;Don&#39;t actually install anything, just print what would be. &quot;
            &quot;Can be used in combination with --ignore-installed &quot;
            &quot;to &#39;resolve&#39; the requirements.&quot;
        ),
    )
    self.cmd_opts.add_option(
        &quot;-t&quot;,
        &quot;--target&quot;,
        dest=&quot;target_dir&quot;,
        metavar=&quot;dir&quot;,
        default=None,
        help=(
            &quot;Install packages into &lt;dir&gt;. &quot;
            &quot;By default this will not replace existing files/folders in &quot;
            &quot;&lt;dir&gt;. Use --upgrade to replace existing packages in &lt;dir&gt; &quot;
            &quot;with new versions.&quot;
        ),
    )
    cmdoptions.add_target_python_options(self.cmd_opts)

    self.cmd_opts.add_option(
        &quot;--user&quot;,
        dest=&quot;use_user_site&quot;,
        action=&quot;store_true&quot;,
        help=(
            &quot;Install to the Python user install directory for your &quot;
            &quot;platform. Typically ~/.local/, or %APPDATA%\\Python on &quot;
            &quot;Windows. (See the Python documentation for site.USER_BASE &quot;
            &quot;for full details.)&quot;
        ),
    )
    self.cmd_opts.add_option(
        &quot;--no-user&quot;,
        dest=&quot;use_user_site&quot;,
        action=&quot;store_false&quot;,
        help=SUPPRESS_HELP,
    )
    self.cmd_opts.add_option(
        &quot;--root&quot;,
        dest=&quot;root_path&quot;,
        metavar=&quot;dir&quot;,
        default=None,
        help=&quot;Install everything relative to this alternate root directory.&quot;,
    )
    self.cmd_opts.add_option(
        &quot;--prefix&quot;,
        dest=&quot;prefix_path&quot;,
        metavar=&quot;dir&quot;,
        default=None,
        help=(
            &quot;Installation prefix where lib, bin and other top-level &quot;
            &quot;folders are placed. Note that the resulting installation may &quot;
            &quot;contain scripts and other resources which reference the &quot;
            &quot;Python interpreter of pip, and not that of ``--prefix``. &quot;
            &quot;See also the ``--python`` option if the intention is to &quot;
            &quot;install packages into another (possibly pip-free) &quot;
            &quot;environment.&quot;
        ),
    )

    self.cmd_opts.add_option(cmdoptions.src())

    self.cmd_opts.add_option(
        &quot;-U&quot;,
        &quot;--upgrade&quot;,
        dest=&quot;upgrade&quot;,
        action=&quot;store_true&quot;,
        help=(
            &quot;Upgrade all specified packages to the newest available &quot;
            &quot;version. The handling of dependencies depends on the &quot;
            &quot;upgrade-strategy used.&quot;
        ),
    )

    self.cmd_opts.add_option(
        &quot;--upgrade-strategy&quot;,
        dest=&quot;upgrade_strategy&quot;,
        default=&quot;only-if-needed&quot;,
        choices=[&quot;only-if-needed&quot;, &quot;eager&quot;],
        help=(
            &quot;Determines how dependency upgrading should be handled &quot;
            &quot;[default: %default]. &quot;
            &#39;&quot;eager&quot; - dependencies are upgraded regardless of &#39;
            &quot;whether the currently installed version satisfies the &quot;
            &quot;requirements of the upgraded package(s). &quot;
            &#39;&quot;only-if-needed&quot; -  are upgraded only when they do not &#39;
            &quot;satisfy the requirements of the upgraded package(s).&quot;
        ),
    )

    self.cmd_opts.add_option(
        &quot;--force-reinstall&quot;,
        dest=&quot;force_reinstall&quot;,
        action=&quot;store_true&quot;,
        help=&quot;Reinstall all packages even if they are already up-to-date.&quot;,
    )

    self.cmd_opts.add_option(
        &quot;-I&quot;,
        &quot;--ignore-installed&quot;,
        dest=&quot;ignore_installed&quot;,
        action=&quot;store_true&quot;,
        help=(
            &quot;Ignore the installed packages, overwriting them. &quot;
            &quot;This can break your system if the existing package &quot;
            &quot;is of a different version or was installed &quot;
            &quot;with a different package manager!&quot;
        ),
    )

    self.cmd_opts.add_option(cmdoptions.ignore_requires_python())
    self.cmd_opts.add_option(cmdoptions.no_build_isolation())
    self.cmd_opts.add_option(cmdoptions.use_pep517())
    self.cmd_opts.add_option(cmdoptions.check_build_deps())
    self.cmd_opts.add_option(cmdoptions.override_externally_managed())

    self.cmd_opts.add_option(cmdoptions.config_settings())

    self.cmd_opts.add_option(
        &quot;--compile&quot;,
        action=&quot;store_true&quot;,
        dest=&quot;compile&quot;,
        default=True,
        help=&quot;Compile Python source files to bytecode&quot;,
    )

    self.cmd_opts.add_option(
        &quot;--no-compile&quot;,
        action=&quot;store_false&quot;,
        dest=&quot;compile&quot;,
        help=&quot;Do not compile Python source files to bytecode&quot;,
    )

    self.cmd_opts.add_option(
        &quot;--no-warn-script-location&quot;,
        action=&quot;store_false&quot;,
        dest=&quot;warn_script_location&quot;,
        default=True,
        help=&quot;Do not warn when installing scripts outside PATH&quot;,
    )
    self.cmd_opts.add_option(
        &quot;--no-warn-conflicts&quot;,
        action=&quot;store_false&quot;,
        dest=&quot;warn_about_conflicts&quot;,
        default=True,
        help=&quot;Do not warn about broken dependencies&quot;,
    )
    self.cmd_opts.add_option(cmdoptions.no_binary())
    self.cmd_opts.add_option(cmdoptions.only_binary())
    self.cmd_opts.add_option(cmdoptions.prefer_binary())
    self.cmd_opts.add_option(cmdoptions.require_hashes())
    self.cmd_opts.add_option(cmdoptions.progress_bar())
    self.cmd_opts.add_option(cmdoptions.root_user_action())

    index_opts = cmdoptions.make_option_group(
        cmdoptions.index_group,
        self.parser,
    )

    self.parser.insert_option_group(0, index_opts)
    self.parser.insert_option_group(0, self.cmd_opts)

    self.cmd_opts.add_option(
        &quot;--report&quot;,
        dest=&quot;json_report_file&quot;,
        metavar=&quot;file&quot;,
        default=None,
        help=(
            &quot;Generate a JSON file describing what pip did to install &quot;
            &quot;the provided requirements. &quot;
            &quot;Can be used in combination with --dry-run and --ignore-installed &quot;
            &quot;to &#39;resolve&#39; the requirements. &quot;
            &quot;When - is used as file name it writes to stdout. &quot;
            &quot;When writing to stdout, please combine with the --quiet option &quot;
            &quot;to avoid mixing pip logging output with JSON output.&quot;
        ),
    )

@with_cleanup
def run(self, options: Values, args: list[str]) -&gt; int:
    if options.use_user_site and options.target_dir is not None:
        raise CommandError(&quot;Can not combine &#39;--user&#39; and &#39;--target&#39;&quot;)

    # Check whether the environment we&#39;re installing into is externally
    # managed, as specified in PEP 668. Specifying --root, --target, or
    # --prefix disables the check, since there&#39;s no reliable way to locate
    # the EXTERNALLY-MANAGED file for those cases. An exception is also
    # made specifically for &quot;--dry-run --report&quot; for convenience.
    installing_into_current_environment = (
        not (options.dry_run and options.json_report_file)
        and options.root_path is None
        and options.target_dir is None
        and options.prefix_path is None
    )
    if (
        installing_into_current_environment
        and not options.override_externally_managed
    ):
        check_externally_managed()

    upgrade_strategy = &quot;to-satisfy-only&quot;
    if options.upgrade:
        upgrade_strategy = options.upgrade_strategy

    cmdoptions.check_build_constraints(options)
    cmdoptions.check_dist_restriction(options, check_target=True)

    logger.verbose(&quot;Using %s&quot;, get_pip_version())
    options.use_user_site = decide_user_install(
        options.use_user_site,
        prefix_path=options.prefix_path,
        target_dir=options.target_dir,
        root_path=options.root_path,
        isolated_mode=options.isolated_mode,
    )

    target_temp_dir: TempDirectory | None = None
    target_temp_dir_path: str | None = None
    if options.target_dir:
        options.ignore_installed = True
        options.target_dir = os.path.abspath(options.target_dir)
        if (
            # fmt: off
            os.path.exists(options.target_dir) and
            not os.path.isdir(options.target_dir)
            # fmt: on
        ):
            raise CommandError(
                &quot;Target path exists but is not a directory, will not continue.&quot;
            )

        # Create a target directory for using with the target option
        target_temp_dir = TempDirectory(kind=&quot;target&quot;)
        target_temp_dir_path = target_temp_dir.path
        self.enter_context(target_temp_dir)

    session = self.get_default_session(options)

    target_python = make_target_python(options)
    finder = self._build_package_finder(
        options=options,
        session=session,
        target_python=target_python,
        ignore_requires_python=options.ignore_requires_python,
    )
    build_tracker = self.enter_context(get_build_tracker())

    directory = TempDirectory(
        delete=not options.no_clean,
        kind=&quot;install&quot;,
        globally_managed=True,
    )

    try:
        reqs = self.get_requirements(args, options, finder, session)

        wheel_cache = WheelCache(options.cache_dir)

        # Only when installing is it permitted to use PEP 660.
        # In other circumstances (pip wheel, pip download) we generate
        # regular (i.e. non editable) metadata and wheels.
        for req in reqs:
            req.permit_editable_wheels = True

        preparer = self.make_requirement_preparer(
            temp_build_dir=directory,
            options=options,
            build_tracker=build_tracker,
            session=session,
            finder=finder,
            use_user_site=options.use_user_site,
            verbosity=self.verbosity,
        )
        resolver = self.make_resolver(
            preparer=preparer,
            finder=finder,
            options=options,
            wheel_cache=wheel_cache,
            use_user_site=options.use_user_site,
            ignore_installed=options.ignore_installed,
            ignore_requires_python=options.ignore_requires_python,
            force_reinstall=options.force_reinstall,
            upgrade_strategy=upgrade_strategy,
            py_version_info=options.python_version,
        )

        self.trace_basic_info(finder)

        requirement_set = resolver.resolve(
            reqs, check_supported_wheels=not options.target_dir
        )

        if options.json_report_file:
            report = InstallationReport(requirement_set.requirements_to_install)
            if options.json_report_file == &quot;-&quot;:
                print_json(data=report.to_dict())
            else:
                with open(options.json_report_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
                    json.dump(report.to_dict(), f, indent=2, ensure_ascii=False)

        if options.dry_run:
            would_install_items = sorted(
                (r.metadata[&quot;name&quot;], r.metadata[&quot;version&quot;])
                for r in requirement_set.requirements_to_install
            )
            if would_install_items:
                write_output(
                    &quot;Would install %s&quot;,
                    &quot; &quot;.join(&quot;-&quot;.join(item) for item in would_install_items),
                )
            return SUCCESS

        # If there is any more preparation to do for the actual installation, do
        # so now. This includes actually downloading the files in the case that
        # we have been using PEP-658 metadata so far.
        preparer.prepare_linked_requirements_more(
            requirement_set.requirements.values()
        )

        try:
            pip_req = requirement_set.get_requirement(&quot;pip&quot;)
        except KeyError:
            modifying_pip = False
        else:
            # If we&#39;re not replacing an already installed pip,
            # we&#39;re not modifying it.
            modifying_pip = pip_req.satisfied_by is None
        protect_pip_from_modification_on_windows(modifying_pip=modifying_pip)

        reqs_to_build = [
            r for r in requirement_set.requirements_to_install if not r.is_wheel
        ]

        _, build_failures = build(
            reqs_to_build,
            wheel_cache=wheel_cache,
            verify=True,
        )

        if build_failures:
            raise InstallWheelBuildError(build_failures)

        to_install = resolver.get_installation_order(requirement_set)

        # Check for conflicts in the package set we&#39;re installing.
        conflicts: ConflictDetails | None = None
        should_warn_about_conflicts = (
            not options.ignore_dependencies and options.warn_about_conflicts
        )
        if should_warn_about_conflicts:
            conflicts = self._determine_conflicts(to_install)

        # Don&#39;t warn about script install locations if
        # --target or --prefix has been specified
        warn_script_location = options.warn_script_location
        if options.target_dir or options.prefix_path:
            warn_script_location = False

        installed = install_given_reqs(
            to_install,
            root=options.root_path,
            home=target_temp_dir_path,
            prefix=options.prefix_path,
            warn_script_location=warn_script_location,
            use_user_site=options.use_user_site,
            pycompile=options.compile,
            progress_bar=options.progress_bar,
        )

        lib_locations = get_lib_location_guesses(
            user=options.use_user_site,
            home=target_temp_dir_path,
            root=options.root_path,
            prefix=options.prefix_path,
            isolated=options.isolated_mode,
        )
        env = get_environment(lib_locations)

        # Display a summary of installed packages, with extra care to
        # display a package name as it was requested by the user.
        installed.sort(key=operator.attrgetter(&quot;name&quot;))
        summary = []
        installed_versions = {}
        for distribution in env.iter_all_distributions():
            installed_versions[distribution.canonical_name] = distribution.version
        for package in installed:
            display_name = package.name
            version = installed_versions.get(canonicalize_name(display_name), None)
            if version:
                text = f&quot;{display_name}-{version}&quot;
            else:
                text = display_name
            summary.append(text)

        if conflicts is not None:
            self._warn_about_conflicts(
                conflicts,
                resolver_variant=self.determine_resolver_variant(options),
            )

        installed_desc = &quot; &quot;.join(summary)
        if installed_desc:
            write_output(
                &quot;Successfully installed %s&quot;,
                installed_desc,
            )
    except OSError as error:
        show_traceback = self.verbosity &gt;= 1

        message = create_os_error_message(
            error,
            show_traceback,
            options.use_user_site,
        )
        logger.error(message, exc_info=show_traceback)

        return ERROR

    if options.target_dir:
        assert target_temp_dir
        self._handle_target_dir(
            options.target_dir, target_temp_dir, options.upgrade
        )
    if options.root_user_action == &quot;warn&quot;:
        warn_if_run_as_root()
    return SUCCESS

def _handle_target_dir(
    self, target_dir: str, target_temp_dir: TempDirectory, upgrade: bool
) -&gt; None:
    ensure_dir(target_dir)

    # Checking both purelib and platlib directories for installed
    # packages to be moved to target directory
    lib_dir_list = []

    # Checking both purelib and platlib directories for installed
    # packages to be moved to target directory
    scheme = get_scheme(&quot;&quot;, home=target_temp_dir.path)
    purelib_dir = scheme.purelib
    platlib_dir = scheme.platlib
    data_dir = scheme.data

    if os.path.exists(purelib_dir):
        lib_dir_list.append(purelib_dir)
    if os.path.exists(platlib_dir) and platlib_dir != purelib_dir:
        lib_dir_list.append(platlib_dir)
    if os.path.exists(data_dir):
        lib_dir_list.append(data_dir)

    for lib_dir in lib_dir_list:
        for item in os.listdir(lib_dir):
            if lib_dir == data_dir:
                ddir = os.path.join(data_dir, item)
                if any(s.startswith(ddir) for s in lib_dir_list[:-1]):
                    continue
            target_item_dir = os.path.join(target_dir, item)
            if os.path.exists(target_item_dir):
                if not upgrade:
                    logger.warning(
                        &quot;Target directory %s already exists. Specify &quot;
                        &quot;--upgrade to force replacement.&quot;,
                        target_item_dir,
                    )
                    continue
                if os.path.islink(target_item_dir):
                    logger.warning(
                        &quot;Target directory %s already exists and is &quot;
                        &quot;a link. pip will not automatically replace &quot;
                        &quot;links, please remove if replacement is &quot;
                        &quot;desired.&quot;,
                        target_item_dir,
                    )
                    continue
                if os.path.isdir(target_item_dir):
                    shutil.rmtree(target_item_dir)
                else:
                    os.remove(target_item_dir)

            shutil.move(os.path.join(lib_dir, item), target_item_dir)

def _determine_conflicts(
    self, to_install: list[InstallRequirement]
) -&gt; ConflictDetails | None:
    try:
        return check_install_conflicts(to_install)
    except Exception:
        logger.exception(
            &quot;Error while checking for conflicts. Please file an issue on &quot;
            &quot;pip&#39;s issue tracker: https://github.com/pypa/pip/issues/new&quot;
        )
        return None

def _warn_about_conflicts(
    self, conflict_details: ConflictDetails, resolver_variant: str
) -&gt; None:
    package_set, (missing, conflicting) = conflict_details
    if not missing and not conflicting:
        return

    parts: list[str] = []
    if resolver_variant == &quot;legacy&quot;:
        parts.append(
            &quot;pip&#39;s legacy dependency resolver does not consider dependency &quot;
            &quot;conflicts when selecting packages. This behaviour is the &quot;
            &quot;source of the following dependency conflicts.&quot;
        )
    else:
        assert resolver_variant == &quot;resolvelib&quot;
        parts.append(
            &quot;pip&#39;s dependency resolver does not currently take into account &quot;
            &quot;all the packages that are installed. This behaviour is the &quot;
            &quot;source of the following dependency conflicts.&quot;
        )

    # NOTE: There is some duplication here, with commands/check.py
    for project_name in missing:
        version = package_set[project_name][0]
        for dependency in missing[project_name]:
            message = (
                f&quot;{project_name} {version} requires {dependency[1]}, &quot;
                &quot;which is not installed.&quot;
            )
            parts.append(message)

    for project_name in conflicting:
        version = package_set[project_name][0]
        for dep_name, dep_version, req in conflicting[project_name]:
            message = (
                &quot;{name} {version} requires {requirement}, but {you} have &quot;
                &quot;{dep_name} {dep_version} which is incompatible.&quot;
            ).format(
                name=project_name,
                version=version,
                requirement=req,
                dep_name=dep_name,
                dep_version=dep_version,
                you=(&quot;you&quot; if resolver_variant == &quot;resolvelib&quot; else &quot;you&#39;ll&quot;),
            )
            parts.append(message)

    logger.critical(&quot;\n&quot;.join(parts))
</pre></div>
</div>
<p>def get_lib_location_guesses(
user: bool = False,
home: str | None = None,
root: str | None = None,
isolated: bool = False,
prefix: str | None = None,
) -&gt; list[str]:
scheme = get_scheme(
“”,
user=user,
home=home,
root=root,
isolated=isolated,
prefix=prefix,
)
return [scheme.purelib, scheme.platlib]</p>
<p>def site_packages_writable(root: str | None, isolated: bool) -&gt; bool:
return all(
test_writable_dir(d)
for d in set(get_lib_location_guesses(root=root, isolated=isolated))
)</p>
<p>def decide_user_install(
use_user_site: bool | None,
prefix_path: str | None = None,
target_dir: str | None = None,
root_path: str | None = None,
isolated_mode: bool = False,
) -&gt; bool:
“””Determine whether to do a user install based on the input options.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>If use_user_site is False, no additional checks are done.
If use_user_site is True, it is checked for compatibility with other
options.
If use_user_site is None, the default behaviour depends on the environment,
which is provided by the other arguments.
&quot;&quot;&quot;
# In some cases (config from tox), use_user_site can be set to an integer
# rather than a bool, which &#39;use_user_site is False&#39; wouldn&#39;t catch.
if (use_user_site is not None) and (not use_user_site):
    logger.debug(&quot;Non-user install by explicit request&quot;)
    return False

# If we have been asked for a user install explicitly, check compatibility.
if use_user_site:
    if prefix_path:
        raise CommandError(
            &quot;Can not combine &#39;--user&#39; and &#39;--prefix&#39; as they imply &quot;
            &quot;different installation locations&quot;
        )
    if virtualenv_no_global():
        raise InstallationError(
            &quot;Can not perform a &#39;--user&#39; install. User site-packages &quot;
            &quot;are not visible in this virtualenv.&quot;
        )
    # Catch all remaining cases which honour the site.ENABLE_USER_SITE
    # value, such as a plain Python installation (e.g. no virtualenv).
    if not site.ENABLE_USER_SITE:
        raise InstallationError(
            &quot;Can not perform a &#39;--user&#39; install. User site-packages &quot;
            &quot;are disabled for this Python.&quot;
        )
    logger.debug(&quot;User install by explicit request&quot;)
    return True

# If we are here, user installs have not been explicitly requested/avoided
assert use_user_site is None

# user install incompatible with --prefix/--target
if prefix_path or target_dir:
    logger.debug(&quot;Non-user install due to --prefix or --target option&quot;)
    return False

# If user installs are not enabled, choose a non-user install
if not site.ENABLE_USER_SITE:
    logger.debug(&quot;Non-user install because user site-packages disabled&quot;)
    return False

# If we have permission for a non-user install, do that,
# otherwise do a user install.
if site_packages_writable(root=root_path, isolated=isolated_mode):
    logger.debug(&quot;Non-user install because site-packages writeable&quot;)
    return False

logger.info(
    &quot;Defaulting to user installation because normal site-packages &quot;
    &quot;is not writeable&quot;
)
return True
</pre></div>
</div>
<p>def create_os_error_message(
error: OSError, show_traceback: bool, using_user_site: bool
) -&gt; str:
“””Format an error message for an OSError</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>It may occur anytime during the execution of the install command.
&quot;&quot;&quot;
parts = []

# Mention the error if we are not going to show a traceback
parts.append(&quot;Could not install packages due to an OSError&quot;)
if not show_traceback:
    parts.append(&quot;: &quot;)
    parts.append(str(error))
else:
    parts.append(&quot;.&quot;)

# Spilt the error indication from a helper message (if any)
parts[-1] += &quot;\n&quot;

# Suggest useful actions to the user:
#  (1) using user site-packages or (2) verifying the permissions
if error.errno == errno.EACCES:
    user_option_part = &quot;Consider using the `--user` option&quot;
    permissions_part = &quot;Check the permissions&quot;

    if not running_under_virtualenv() and not using_user_site:
        parts.extend(
            [
                user_option_part,
                &quot; or &quot;,
                permissions_part.lower(),
            ]
        )
    else:
        parts.append(permissions_part)
    parts.append(&quot;.\n&quot;)

# Suggest to check &quot;pip config debug&quot; in case of invalid proxy
if type(error) is InvalidProxyURL:
    parts.append(
        &#39;Consider checking your local proxy configuration with &quot;pip config debug&quot;&#39;
    )
    parts.append(&quot;.\n&quot;)

# On Windows, errors like EINVAL or ENOENT may occur
# if a file or folder name exceeds 255 characters,
# or if the full path exceeds 260 characters and long path support isn&#39;t enabled.
# This condition checks for such cases and adds a hint to the error output.

if WINDOWS and error.errno in (errno.EINVAL, errno.ENOENT) and error.filename:
    if any(len(part) &gt; 255 for part in Path(error.filename).parts):
        parts.append(
            &quot;HINT: This error might be caused by a file or folder name exceeding &quot;
            &quot;255 characters, which is a Windows limitation even if long paths &quot;
            &quot;are enabled.\n &quot;
        )
    if len(error.filename) &gt; 260:
        parts.append(
            &quot;HINT: This error might have occurred since &quot;
            &quot;this system does not have Windows Long Path &quot;
            &quot;support enabled. You can find information on &quot;
            &quot;how to enable this at &quot;
            &quot;https://pip.pypa.io/warnings/enable-long-paths\n&quot;
        )
return &quot;&quot;.join(parts).strip() + &quot;\n&quot;
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>