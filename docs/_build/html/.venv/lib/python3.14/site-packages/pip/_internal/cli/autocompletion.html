

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/cli/autocompletion.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Logic that powers autocompletion installed by <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">completion</span></code>.”””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import optparse
import os
import sys
from collections.abc import Iterable
from itertools import chain
from typing import Any</p>
<p>from pip._internal.cli.main_parser import create_main_parser
from pip._internal.commands import commands_dict, create_command
from pip._internal.metadata import get_default_environment</p>
<p>def autocomplete() -&gt; None:
“””Entry Point for completion of main and subcommand options.”””
# Don’t complete if user hasn’t sourced bash_completion file.
if “PIP_AUTO_COMPLETE” not in os.environ:
return
# Don’t complete if autocompletion environment variables
# are not present
if not os.environ.get(“COMP_WORDS”) or not os.environ.get(“COMP_CWORD”):
return
cwords = os.environ[“COMP_WORDS”].split()[1:]
cword = int(os.environ[“COMP_CWORD”])
try:
current = cwords[cword - 1]
except IndexError:
current = “”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parser = create_main_parser()
subcommands = list(commands_dict)
options = []

# subcommand
subcommand_name: str | None = None
for word in cwords:
    if word in subcommands:
        subcommand_name = word
        break
# subcommand options
if subcommand_name is not None:
    # special case: &#39;help&#39; subcommand has no options
    if subcommand_name == &quot;help&quot;:
        sys.exit(1)
    # special case: list locally installed dists for show and uninstall
    should_list_installed = not current.startswith(&quot;-&quot;) and subcommand_name in [
        &quot;show&quot;,
        &quot;uninstall&quot;,
    ]
    if should_list_installed:
        env = get_default_environment()
        lc = current.lower()
        installed = [
            dist.canonical_name
            for dist in env.iter_installed_distributions(local_only=True)
            if dist.canonical_name.startswith(lc)
            and dist.canonical_name not in cwords[1:]
        ]
        # if there are no dists installed, fall back to option completion
        if installed:
            for dist in installed:
                print(dist)
            sys.exit(1)

    should_list_installables = (
        not current.startswith(&quot;-&quot;) and subcommand_name == &quot;install&quot;
    )
    if should_list_installables:
        for path in auto_complete_paths(current, &quot;path&quot;):
            print(path)
        sys.exit(1)

    subcommand = create_command(subcommand_name)

    for opt in subcommand.parser.option_list_all:
        if opt.help != optparse.SUPPRESS_HELP:
            options += [
                (opt_str, opt.nargs) for opt_str in opt._long_opts + opt._short_opts
            ]

    # filter out previously specified options from available options
    prev_opts = [x.split(&quot;=&quot;)[0] for x in cwords[1 : cword - 1]]
    options = [(x, v) for (x, v) in options if x not in prev_opts]
    # filter options by current input
    options = [(k, v) for k, v in options if k.startswith(current)]
    # get completion type given cwords and available subcommand options
    completion_type = get_path_completion_type(
        cwords,
        cword,
        subcommand.parser.option_list_all,
    )
    # get completion files and directories if ``completion_type`` is
    # ``&lt;file&gt;``, ``&lt;dir&gt;`` or ``&lt;path&gt;``
    if completion_type:
        paths = auto_complete_paths(current, completion_type)
        options = [(path, 0) for path in paths]
    for option in options:
        opt_label = option[0]
        # append &#39;=&#39; to options which require args
        if option[1] and option[0][:2] == &quot;--&quot;:
            opt_label += &quot;=&quot;
        print(opt_label)

    # Complete sub-commands (unless one is already given).
    if not any(name in cwords for name in subcommand.handler_map()):
        for handler_name in subcommand.handler_map():
            if handler_name.startswith(current):
                print(handler_name)
else:
    # show main parser options only when necessary

    opts = [i.option_list for i in parser.option_groups]
    opts.append(parser.option_list)
    flattened_opts = chain.from_iterable(opts)
    if current.startswith(&quot;-&quot;):
        for opt in flattened_opts:
            if opt.help != optparse.SUPPRESS_HELP:
                subcommands += opt._long_opts + opt._short_opts
    else:
        # get completion type given cwords and all available options
        completion_type = get_path_completion_type(cwords, cword, flattened_opts)
        if completion_type:
            subcommands = list(auto_complete_paths(current, completion_type))

    print(&quot; &quot;.join([x for x in subcommands if x.startswith(current)]))
sys.exit(1)
</pre></div>
</div>
<p>def get_path_completion_type(
cwords: list[str], cword: int, opts: Iterable[Any]
) -&gt; str | None:
“””Get the type of path completion (<code class="docutils literal notranslate"><span class="pre">file</span></code>, <code class="docutils literal notranslate"><span class="pre">dir</span></code>, <code class="docutils literal notranslate"><span class="pre">path</span></code> or None)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param cwords: same as the environmental variable ``COMP_WORDS``
:param cword: same as the environmental variable ``COMP_CWORD``
:param opts: The available options to check
:return: path completion type (``file``, ``dir``, ``path`` or None)
&quot;&quot;&quot;
if cword &lt; 2 or not cwords[cword - 2].startswith(&quot;-&quot;):
    return None
for opt in opts:
    if opt.help == optparse.SUPPRESS_HELP:
        continue
    for o in str(opt).split(&quot;/&quot;):
        if cwords[cword - 2].split(&quot;=&quot;)[0] == o:
            if not opt.metavar or any(
                x in (&quot;path&quot;, &quot;file&quot;, &quot;dir&quot;) for x in opt.metavar.split(&quot;/&quot;)
            ):
                return opt.metavar
return None
</pre></div>
</div>
<p>def auto_complete_paths(current: str, completion_type: str) -&gt; Iterable[str]:
“””If <code class="docutils literal notranslate"><span class="pre">completion_type</span></code> is <code class="docutils literal notranslate"><span class="pre">file</span></code> or <code class="docutils literal notranslate"><span class="pre">path</span></code>, list all regular files
and directories starting with <code class="docutils literal notranslate"><span class="pre">current</span></code>; otherwise only list directories
starting with <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param current: The word to be completed
:param completion_type: path completion type(``file``, ``path`` or ``dir``)
:return: A generator of regular files and/or directories
&quot;&quot;&quot;
directory, filename = os.path.split(current)
current_path = os.path.abspath(directory)
# Don&#39;t complete paths if they can&#39;t be accessed
if not os.access(current_path, os.R_OK):
    return
filename = os.path.normcase(filename)
# list all files that start with ``filename``
file_list = (
    x for x in os.listdir(current_path) if os.path.normcase(x).startswith(filename)
)
for f in file_list:
    opt = os.path.join(current_path, f)
    comp_file = os.path.normcase(os.path.join(directory, f))
    # complete regular files when there is not ``&lt;dir&gt;`` after option
    # complete directories when there is ``&lt;file&gt;``, ``&lt;path&gt;`` or
    # ``&lt;dir&gt;``after option
    if completion_type != &quot;dir&quot; and os.path.isfile(opt):
        yield comp_file
    elif os.path.isdir(opt):
        yield os.path.join(comp_file, &quot;&quot;)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>