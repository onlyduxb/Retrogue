

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>From typeshed/stdlib/ssl.pyi &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">From typeshed/stdlib/ssl.pyi</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/truststore/_api.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>import contextlib
import os
import platform
import socket
import ssl
import sys
import threading
import typing</p>
<p>import _ssl</p>
<p>from ._ssl_constants import (
_original_SSLContext,
_original_super_SSLContext,
_truststore_SSLContext_dunder_class,
_truststore_SSLContext_super_class,
)</p>
<p>if platform.system() == “Windows”:
from ._windows import _configure_context, _verify_peercerts_impl
elif platform.system() == “Darwin”:
from ._macos import _configure_context, _verify_peercerts_impl
else:
from ._openssl import _configure_context, _verify_peercerts_impl</p>
<p>if typing.TYPE_CHECKING:
from typing_extensions import Buffer</p>
<section id="from-typeshed-stdlib-ssl-pyi">
<h1>From typeshed/stdlib/ssl.pyi<a class="headerlink" href="#from-typeshed-stdlib-ssl-pyi" title="Link to this heading"></a></h1>
<p>_StrOrBytesPath: typing.TypeAlias = str | bytes | os.PathLike[str] | os.PathLike[bytes]
_PasswordType: typing.TypeAlias = str | bytes | typing.Callable[[], str | bytes]</p>
<p>def inject_into_ssl() -&gt; None:
“””Injects the :class:<code class="docutils literal notranslate"><span class="pre">truststore.SSLContext</span></code> into the <code class="docutils literal notranslate"><span class="pre">ssl</span></code>
module by replacing :class:<code class="docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code>.
“””
setattr(ssl, “SSLContext”, SSLContext)
# urllib3 holds on to its own reference of ssl.SSLContext
# so we need to replace that reference too.
try:
import pip.<em>vendor.urllib3.util.ssl</em> as urllib3_ssl</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    setattr(urllib3_ssl, &quot;SSLContext&quot;, SSLContext)
except ImportError:
    pass

# requests starting with 2.32.0 added a preloaded SSL context to improve concurrent performance;
# this unfortunately leads to a RecursionError, which can be avoided by patching the preloaded SSL context with
# the truststore patched instance
# also see https://github.com/psf/requests/pull/6667
try:
    from pip._vendor.requests import adapters as requests_adapters

    preloaded_context = getattr(requests_adapters, &quot;_preloaded_ssl_context&quot;, None)
    if preloaded_context is not None:
        setattr(
            requests_adapters,
            &quot;_preloaded_ssl_context&quot;,
            SSLContext(ssl.PROTOCOL_TLS_CLIENT),
        )
except ImportError:
    pass
</pre></div>
</div>
<p>def extract_from_ssl() -&gt; None:
“””Restores the :class:<code class="docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code> class to its original state”””
setattr(ssl, “SSLContext”, _original_SSLContext)
try:
import pip.<em>vendor.urllib3.util.ssl</em> as urllib3_ssl</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    urllib3_ssl.SSLContext = _original_SSLContext
except ImportError:
    pass
</pre></div>
</div>
<p>class SSLContext(_truststore_SSLContext_super_class):  # type: ignore[misc]
“””SSLContext API that uses system certificates on all platforms”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@property  # type: ignore[misc]
def __class__(self) -&gt; type:
    # Dirty hack to get around isinstance() checks
    # for ssl.SSLContext instances in aiohttp/trustme
    # when using non-CPython implementations.
    return _truststore_SSLContext_dunder_class or SSLContext

def __init__(self, protocol: int = None) -&gt; None:  # type: ignore[assignment]
    self._ctx = _original_SSLContext(protocol)
    self._ctx_lock = threading.Lock()

    class TruststoreSSLObject(ssl.SSLObject):
        # This object exists because wrap_bio() doesn&#39;t
        # immediately do the handshake so we need to do
        # certificate verifications after SSLObject.do_handshake()

        def do_handshake(self) -&gt; None:
            ret = super().do_handshake()
            _verify_peercerts(self, server_hostname=self.server_hostname)
            return ret

    self._ctx.sslobject_class = TruststoreSSLObject

def wrap_socket(
    self,
    sock: socket.socket,
    server_side: bool = False,
    do_handshake_on_connect: bool = True,
    suppress_ragged_eofs: bool = True,
    server_hostname: str | None = None,
    session: ssl.SSLSession | None = None,
) -&gt; ssl.SSLSocket:

    # We need to lock around the .__enter__()
    # but we don&#39;t need to lock within the
    # context manager, so we need to expand the
    # syntactic sugar of the `with` statement.
    with contextlib.ExitStack() as stack:
        with self._ctx_lock:
            stack.enter_context(_configure_context(self._ctx))

        ssl_sock = self._ctx.wrap_socket(
            sock,
            server_side=server_side,
            server_hostname=server_hostname,
            do_handshake_on_connect=do_handshake_on_connect,
            suppress_ragged_eofs=suppress_ragged_eofs,
            session=session,
        )
    try:
        _verify_peercerts(ssl_sock, server_hostname=server_hostname)
    except Exception:
        ssl_sock.close()
        raise
    return ssl_sock

def wrap_bio(
    self,
    incoming: ssl.MemoryBIO,
    outgoing: ssl.MemoryBIO,
    server_side: bool = False,
    server_hostname: str | None = None,
    session: ssl.SSLSession | None = None,
) -&gt; ssl.SSLObject:
    with _configure_context(self._ctx):
        ssl_obj = self._ctx.wrap_bio(
            incoming,
            outgoing,
            server_hostname=server_hostname,
            server_side=server_side,
            session=session,
        )
    return ssl_obj

def load_verify_locations(
    self,
    cafile: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,
    capath: str | bytes | os.PathLike[str] | os.PathLike[bytes] | None = None,
    cadata: typing.Union[str, &quot;Buffer&quot;, None] = None,
) -&gt; None:
    return self._ctx.load_verify_locations(
        cafile=cafile, capath=capath, cadata=cadata
    )

def load_cert_chain(
    self,
    certfile: _StrOrBytesPath,
    keyfile: _StrOrBytesPath | None = None,
    password: _PasswordType | None = None,
) -&gt; None:
    return self._ctx.load_cert_chain(
        certfile=certfile, keyfile=keyfile, password=password
    )

def load_default_certs(
    self, purpose: ssl.Purpose = ssl.Purpose.SERVER_AUTH
) -&gt; None:
    return self._ctx.load_default_certs(purpose)

def set_alpn_protocols(self, alpn_protocols: typing.Iterable[str]) -&gt; None:
    return self._ctx.set_alpn_protocols(alpn_protocols)

def set_npn_protocols(self, npn_protocols: typing.Iterable[str]) -&gt; None:
    return self._ctx.set_npn_protocols(npn_protocols)

def set_ciphers(self, __cipherlist: str) -&gt; None:
    return self._ctx.set_ciphers(__cipherlist)

def get_ciphers(self) -&gt; typing.Any:
    return self._ctx.get_ciphers()

def session_stats(self) -&gt; dict[str, int]:
    return self._ctx.session_stats()

def cert_store_stats(self) -&gt; dict[str, int]:
    raise NotImplementedError()

def set_default_verify_paths(self) -&gt; None:
    self._ctx.set_default_verify_paths()

@typing.overload
def get_ca_certs(
    self, binary_form: typing.Literal[False] = ...
) -&gt; list[typing.Any]: ...

@typing.overload
def get_ca_certs(self, binary_form: typing.Literal[True] = ...) -&gt; list[bytes]: ...

@typing.overload
def get_ca_certs(self, binary_form: bool = ...) -&gt; typing.Any: ...

def get_ca_certs(self, binary_form: bool = False) -&gt; list[typing.Any] | list[bytes]:
    raise NotImplementedError()

@property
def check_hostname(self) -&gt; bool:
    return self._ctx.check_hostname

@check_hostname.setter
def check_hostname(self, value: bool) -&gt; None:
    self._ctx.check_hostname = value

@property
def hostname_checks_common_name(self) -&gt; bool:
    return self._ctx.hostname_checks_common_name

@hostname_checks_common_name.setter
def hostname_checks_common_name(self, value: bool) -&gt; None:
    self._ctx.hostname_checks_common_name = value

@property
def keylog_filename(self) -&gt; str:
    return self._ctx.keylog_filename

@keylog_filename.setter
def keylog_filename(self, value: str) -&gt; None:
    self._ctx.keylog_filename = value

@property
def maximum_version(self) -&gt; ssl.TLSVersion:
    return self._ctx.maximum_version

@maximum_version.setter
def maximum_version(self, value: ssl.TLSVersion) -&gt; None:
    _original_super_SSLContext.maximum_version.__set__(  # type: ignore[attr-defined]
        self._ctx, value
    )

@property
def minimum_version(self) -&gt; ssl.TLSVersion:
    return self._ctx.minimum_version

@minimum_version.setter
def minimum_version(self, value: ssl.TLSVersion) -&gt; None:
    _original_super_SSLContext.minimum_version.__set__(  # type: ignore[attr-defined]
        self._ctx, value
    )

@property
def options(self) -&gt; ssl.Options:
    return self._ctx.options

@options.setter
def options(self, value: ssl.Options) -&gt; None:
    _original_super_SSLContext.options.__set__(  # type: ignore[attr-defined]
        self._ctx, value
    )

@property
def post_handshake_auth(self) -&gt; bool:
    return self._ctx.post_handshake_auth

@post_handshake_auth.setter
def post_handshake_auth(self, value: bool) -&gt; None:
    self._ctx.post_handshake_auth = value

@property
def protocol(self) -&gt; ssl._SSLMethod:
    return self._ctx.protocol

@property
def security_level(self) -&gt; int:
    return self._ctx.security_level

@property
def verify_flags(self) -&gt; ssl.VerifyFlags:
    return self._ctx.verify_flags

@verify_flags.setter
def verify_flags(self, value: ssl.VerifyFlags) -&gt; None:
    _original_super_SSLContext.verify_flags.__set__(  # type: ignore[attr-defined]
        self._ctx, value
    )

@property
def verify_mode(self) -&gt; ssl.VerifyMode:
    return self._ctx.verify_mode

@verify_mode.setter
def verify_mode(self, value: ssl.VerifyMode) -&gt; None:
    _original_super_SSLContext.verify_mode.__set__(  # type: ignore[attr-defined]
        self._ctx, value
    )
</pre></div>
</div>
</section>
<section id="python-3-13-makes-get-unverified-chain-a-public-api-that-only-returns-der">
<h1>Python 3.13+ makes get_unverified_chain() a public API that only returns DER<a class="headerlink" href="#python-3-13-makes-get-unverified-chain-a-public-api-that-only-returns-der" title="Link to this heading"></a></h1>
</section>
<section id="encoded-certificates-we-detect-whether-we-need-to-call-public-bytes-for-3-10-3-12">
<h1>encoded certificates. We detect whether we need to call public_bytes() for 3.10-&gt;3.12<a class="headerlink" href="#encoded-certificates-we-detect-whether-we-need-to-call-public-bytes-for-3-10-3-12" title="Link to this heading"></a></h1>
</section>
<section id="pre-3-13-returned-none-instead-of-an-empty-list-from-get-unverified-chain">
<h1>Pre-3.13 returned None instead of an empty list from get_unverified_chain()<a class="headerlink" href="#pre-3-13-returned-none-instead-of-an-empty-list-from-get-unverified-chain" title="Link to this heading"></a></h1>
<p>if sys.version_info &gt;= (3, 13):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def _get_unverified_chain_bytes(sslobj: ssl.SSLObject) -&gt; list[bytes]:
    unverified_chain = sslobj.get_unverified_chain() or ()
    return [
        cert if isinstance(cert, bytes) else cert.public_bytes(_ssl.ENCODING_DER)
        for cert in unverified_chain
    ]
</pre></div>
</div>
<p>else:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def _get_unverified_chain_bytes(sslobj: ssl.SSLObject) -&gt; list[bytes]:
    unverified_chain = sslobj.get_unverified_chain() or ()  # type: ignore[attr-defined]
    return [cert.public_bytes(_ssl.ENCODING_DER) for cert in unverified_chain]
</pre></div>
</div>
<p>def _verify_peercerts(
sock_or_sslobj: ssl.SSLSocket | ssl.SSLObject, server_hostname: str | None
) -&gt; None:
“””
Verifies the peer certificates from an SSLSocket or SSLObject
against the certificates in the OS trust store.
“””
sslobj: ssl.SSLObject = sock_or_sslobj  # type: ignore[assignment]
try:
while not hasattr(sslobj, “get_unverified_chain”):
sslobj = sslobj._sslobj  # type: ignore[attr-defined]
except AttributeError:
pass</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cert_bytes = _get_unverified_chain_bytes(sslobj)
_verify_peercerts_impl(
    sock_or_sslobj.context, cert_bytes, server_hostname=server_hostname
)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>