

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>—- The actual constructors follow —- &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">—- The actual constructors follow —-</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/req/constructors.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Backing implementation for InstallRequirement’s various constructors</p>
<p>The idea here is that these formed a major chunk of InstallRequirement’s size
so, moving them and support code dedicated to them outside of that class
helps creates for better understandability for the rest of the code.</p>
<p>These are meant to be used elsewhere within pip to create instances of
InstallRequirement.
“””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import copy
import logging
import os
import re
from collections.abc import Collection
from dataclasses import dataclass</p>
<p>from pip._vendor.packaging.markers import Marker
from pip._vendor.packaging.requirements import InvalidRequirement, Requirement
from pip._vendor.packaging.specifiers import Specifier</p>
<p>from pip._internal.exceptions import InstallationError
from pip._internal.models.index import PyPI, TestPyPI
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.req.req_file import ParsedRequirement
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.filetypes import is_archive_file
from pip._internal.utils.misc import is_installable_dir
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.urls import path_to_url
from pip._internal.vcs import is_url, vcs</p>
<p><strong>all</strong> = [
“install_req_from_editable”,
“install_req_from_line”,
“parse_editable”,
]</p>
<p>logger = logging.getLogger(<strong>name</strong>)
operators = Specifier._operators.keys()</p>
<p>def _strip_extras(path: str) -&gt; tuple[str, str | None]:
m = re.match(r”^(.+)([<a href="#id4"><span class="problematic" id="id1">[^\]</span></a>]+])$”, path)
extras = None
if m:
path_no_extras = m.group(1).rstrip()
extras = m.group(2)
else:
path_no_extras = path</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>return path_no_extras, extras
</pre></div>
</div>
<p>def convert_extras(extras: str | None) -&gt; set[str]:
if not extras:
return set()
return get_requirement(“placeholder” + extras.lower()).extras</p>
<p>def _set_requirement_extras(req: Requirement, new_extras: set[str]) -&gt; Requirement:
“””
Returns a new requirement based on the given one, with the supplied extras. If the
given requirement already has extras those are replaced (or dropped if no new extras
are given).
“””
match: re.Match[str] | None = re.fullmatch(
# see https://peps.python.org/pep-0508/#complete-grammar
r”([\w\t .-]+)([<a href="#id5"><span class="problematic" id="id2">[^\]</span></a>]<em>])?(.</em>)”,
str(req),
flags=re.ASCII,
)
# ireq.req is a valid requirement so the regex should always match
assert (
match is not None
), f”regex match on requirement {req} failed, this should never happen”
pre: str | None = match.group(1)
post: str | None = match.group(3)
assert (
pre is not None and post is not None
), f”regex group selection for requirement {req} failed, this should never happen”
extras: str = “[{}]”.format(“,”.join(sorted(new_extras)) if new_extras else “”)
return get_requirement(f”{pre}{extras}{post}”)</p>
<p>def _parse_direct_url_editable(editable_req: str) -&gt; tuple[str | None, str, set[str]]:
try:
req = Requirement(editable_req)
except InvalidRequirement:
pass
else:
if req.url:
# Join the marker back into the name part. This will be parsed out
# later into a Requirement again.
if req.marker:
name = f”{req.name} ; {req.marker}”
else:
name = req.name
return (name, req.url, req.extras)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>raise ValueError
</pre></div>
</div>
<p>def _parse_pip_syntax_editable(editable_req: str) -&gt; tuple[str | None, str, set[str]]:
url = editable_req</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># If a file path is specified with extras, strip off the extras.
url_no_extras, extras = _strip_extras(url)

if os.path.isdir(url_no_extras):
    # Treating it as code that has already been checked out
    url_no_extras = path_to_url(url_no_extras)

if url_no_extras.lower().startswith(&quot;file:&quot;):
    package_name = Link(url_no_extras).egg_fragment
    if extras:
        return (
            package_name,
            url_no_extras,
            get_requirement(&quot;placeholder&quot; + extras.lower()).extras,
        )
    else:
        return package_name, url_no_extras, set()

for version_control in vcs:
    if url.lower().startswith(f&quot;{version_control}:&quot;):
        url = f&quot;{version_control}+{url}&quot;
        break

return Link(url).egg_fragment, url, set()
</pre></div>
</div>
<p>def parse_editable(editable_req: str) -&gt; tuple[str | None, str, set[str]]:
“””Parses an editable requirement into:
- a requirement name with environment markers
- an URL
- extras
Accepted requirements:
- svn+http://blahblah&#64;rev#egg=Foobar[baz]&amp;subdirectory=version_subdir
- local_path[some_extra]
- Foobar[extra] &#64; svn+http://blahblah&#64;rev#subdirectory=subdir ; markers
“””
try:
package_name, url, extras = _parse_direct_url_editable(editable_req)
except ValueError:
package_name, url, extras = _parse_pip_syntax_editable(editable_req)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>link = Link(url)

if not link.is_vcs and not link.url.startswith(&quot;file:&quot;):
    backends = &quot;, &quot;.join(vcs.all_schemes)
    raise InstallationError(
        f&quot;{editable_req} is not a valid editable requirement. &quot;
        f&quot;It should either be a path to a local project or a VCS URL &quot;
        f&quot;(beginning with {backends}).&quot;
    )

# The project name can be inferred from local file URIs easily.
if not package_name and not link.url.startswith(&quot;file:&quot;):
    raise InstallationError(
        f&quot;Could not detect requirement name for &#39;{editable_req}&#39;, &quot;
        &quot;please specify one with your_package_name @ URL&quot;
    )
return package_name, url, extras
</pre></div>
</div>
<p>def check_first_requirement_in_file(filename: str) -&gt; None:
“””Check if file is parsable as a requirements file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is heavily based on ``pkg_resources.parse_requirements``, but
simplified to just check the first meaningful line.

:raises InvalidRequirement: If the first meaningful line cannot be parsed
    as an requirement.
&quot;&quot;&quot;
with open(filename, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;) as f:
    # Create a steppable iterator, so we can handle \-continuations.
    lines = (
        line
        for line in (line.strip() for line in f)
        if line and not line.startswith(&quot;#&quot;)  # Skip blank lines/comments.
    )

    for line in lines:
        # Drop comments -- a hash without a space may be in a URL.
        if &quot; #&quot; in line:
            line = line[: line.find(&quot; #&quot;)]
        # If there is a line continuation, drop it, and append the next line.
        if line.endswith(&quot;\\&quot;):
            line = line[:-2].strip() + next(lines, &quot;&quot;)
        get_requirement(line)
        return
</pre></div>
</div>
<p>def deduce_helpful_msg(req: str) -&gt; str:
“””Returns helpful msg in case requirements file does not exist,
or cannot be parsed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:params req: Requirements file path
&quot;&quot;&quot;
if not os.path.exists(req):
    return f&quot; File &#39;{req}&#39; does not exist.&quot;
msg = &quot; The path does exist. &quot;
# Try to parse and check if it is a requirements file.
try:
    check_first_requirement_in_file(req)
except InvalidRequirement:
    logger.debug(&quot;Cannot parse &#39;%s&#39; as requirements file&quot;, req)
else:
    msg += (
        f&quot;The argument you provided &quot;
        f&quot;({req}) appears to be a&quot;
        f&quot; requirements file. If that is the&quot;
        f&quot; case, use the &#39;-r&#39; flag to install&quot;
        f&quot; the packages specified within it.&quot;
    )
return msg
</pre></div>
</div>
<p>&#64;dataclass(frozen=True)
class RequirementParts:
requirement: Requirement | None
link: Link | None
markers: Marker | None
extras: set[str]</p>
<p>def parse_req_from_editable(editable_req: str) -&gt; RequirementParts:
name, url, extras_override = parse_editable(editable_req)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if name is not None:
    try:
        req: Requirement | None = get_requirement(name)
    except InvalidRequirement as exc:
        raise InstallationError(f&quot;Invalid requirement: {name!r}: {exc}&quot;)
else:
    req = None

link = Link(url)

return RequirementParts(req, link, None, extras_override)
</pre></div>
</div>
<section id="the-actual-constructors-follow">
<h1>—- The actual constructors follow —-<a class="headerlink" href="#the-actual-constructors-follow" title="Link to this heading"></a></h1>
<p>def install_req_from_editable(
editable_req: str,
comes_from: InstallRequirement | str | None = None,
*,
isolated: bool = False,
hash_options: dict[str, list[str]] | None = None,
constraint: bool = False,
user_supplied: bool = False,
permit_editable_wheels: bool = False,
config_settings: dict[str, str | list[str]] | None = None,
) -&gt; InstallRequirement:
parts = parse_req_from_editable(editable_req)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>return InstallRequirement(
    parts.requirement,
    comes_from=comes_from,
    user_supplied=user_supplied,
    editable=True,
    permit_editable_wheels=permit_editable_wheels,
    link=parts.link,
    constraint=constraint,
    isolated=isolated,
    hash_options=hash_options,
    config_settings=config_settings,
    extras=parts.extras,
)
</pre></div>
</div>
<p>def _looks_like_path(name: str) -&gt; bool:
“””Checks whether the string “looks like” a path on the filesystem.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This does not check whether the target actually exists, only judge from the
appearance.

Returns true if any of the following conditions is true:
* a path separator is found (either os.path.sep or os.path.altsep);
* a dot is found (which represents the current directory).
&quot;&quot;&quot;
if os.path.sep in name:
    return True
if os.path.altsep is not None and os.path.altsep in name:
    return True
if name.startswith(&quot;.&quot;):
    return True
return False
</pre></div>
</div>
<p>def _get_url_from_path(path: str, name: str) -&gt; str | None:
“””
First, it checks whether a provided path is an installable directory. If it
is, returns the path.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>If false, check if the path is an archive file (such as a .whl).
The function checks if the path is a file. If false, if the path has
an @, it will treat it as a PEP 440 URL requirement and return the path.
&quot;&quot;&quot;
if _looks_like_path(name) and os.path.isdir(path):
    if is_installable_dir(path):
        return path_to_url(path)
    # TODO: The is_installable_dir test here might not be necessary
    #       now that it is done in load_pyproject_toml too.
    raise InstallationError(
        f&quot;Directory {name!r} is not installable. Neither &#39;setup.py&#39; &quot;
        &quot;nor &#39;pyproject.toml&#39; found.&quot;
    )
if not is_archive_file(path):
    return None
if os.path.isfile(path):
    return path_to_url(path)
urlreq_parts = name.split(&quot;@&quot;, 1)
if len(urlreq_parts) &gt;= 2 and not _looks_like_path(urlreq_parts[0]):
    # If the path contains &#39;@&#39; and the part before it does not look
    # like a path, try to treat it as a PEP 440 URL req instead.
    return None
logger.warning(
    &quot;Requirement %r looks like a filename, but the file does not exist&quot;,
    name,
)
return path_to_url(path)
</pre></div>
</div>
<p>def parse_req_from_line(name: str, line_source: str | None) -&gt; RequirementParts:
if is_url(name):
marker_sep = “; “
else:
marker_sep = “;”
if marker_sep in name:
name, markers_as_string = name.split(marker_sep, 1)
markers_as_string = markers_as_string.strip()
if not markers_as_string:
markers = None
else:
markers = Marker(markers_as_string)
else:
markers = None
name = name.strip()
req_as_string = None
path = os.path.normpath(os.path.abspath(name))
link = None
extras_as_string = None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if is_url(name):
    link = Link(name)
else:
    p, extras_as_string = _strip_extras(path)
    url = _get_url_from_path(p, name)
    if url is not None:
        link = Link(url)

# it&#39;s a local file, dir, or url
if link:
    # Handle relative file URLs
    if link.scheme == &quot;file&quot; and re.search(r&quot;\.\./&quot;, link.url):
        link = Link(path_to_url(os.path.normpath(os.path.abspath(link.path))))
    # wheel file
    if link.is_wheel:
        wheel = Wheel(link.filename)  # can raise InvalidWheelFilename
        req_as_string = f&quot;{wheel.name}=={wheel.version}&quot;
    else:
        # set the req to the egg fragment.  when it&#39;s not there, this
        # will become an &#39;unnamed&#39; requirement
        req_as_string = link.egg_fragment

# a requirement specifier
else:
    req_as_string = name

extras = convert_extras(extras_as_string)

def with_source(text: str) -&gt; str:
    if not line_source:
        return text
    return f&quot;{text} (from {line_source})&quot;

def _parse_req_string(req_as_string: str) -&gt; Requirement:
    try:
        return get_requirement(req_as_string)
    except InvalidRequirement as exc:
        if os.path.sep in req_as_string:
            add_msg = &quot;It looks like a path.&quot;
            add_msg += deduce_helpful_msg(req_as_string)
        elif &quot;=&quot; in req_as_string and not any(
            op in req_as_string for op in operators
        ):
            add_msg = &quot;= is not a valid operator. Did you mean == ?&quot;
        else:
            add_msg = &quot;&quot;
        msg = with_source(f&quot;Invalid requirement: {req_as_string!r}: {exc}&quot;)
        if add_msg:
            msg += f&quot;\nHint: {add_msg}&quot;
        raise InstallationError(msg)

if req_as_string is not None:
    req: Requirement | None = _parse_req_string(req_as_string)
else:
    req = None

return RequirementParts(req, link, markers, extras)
</pre></div>
</div>
<p>def install_req_from_line(
name: str,
comes_from: str | InstallRequirement | None = None,
*,
isolated: bool = False,
hash_options: dict[str, list[str]] | None = None,
constraint: bool = False,
line_source: str | None = None,
user_supplied: bool = False,
config_settings: dict[str, str | list[str]] | None = None,
) -&gt; InstallRequirement:
“””Creates an InstallRequirement from a name, which might be a
requirement, directory containing ‘setup.py’, filename, or URL.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param line_source: An optional string describing where the line is from,
    for logging purposes in case of an error.
&quot;&quot;&quot;
parts = parse_req_from_line(name, line_source)

return InstallRequirement(
    parts.requirement,
    comes_from,
    link=parts.link,
    markers=parts.markers,
    isolated=isolated,
    hash_options=hash_options,
    config_settings=config_settings,
    constraint=constraint,
    extras=parts.extras,
    user_supplied=user_supplied,
)
</pre></div>
</div>
<p>def install_req_from_req_string(
req_string: str,
comes_from: InstallRequirement | None = None,
isolated: bool = False,
user_supplied: bool = False,
) -&gt; InstallRequirement:
try:
req = get_requirement(req_string)
except InvalidRequirement as exc:
raise InstallationError(f”Invalid requirement: {req_string!r}: {exc}”)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>domains_not_allowed = [
    PyPI.file_storage_domain,
    TestPyPI.file_storage_domain,
]
if (
    req.url
    and comes_from
    and comes_from.link
    and comes_from.link.netloc in domains_not_allowed
):
    # Explicitly disallow pypi packages that depend on external urls
    raise InstallationError(
        &quot;Packages installed from PyPI cannot depend on packages &quot;
        &quot;which are not also hosted on PyPI.\n&quot;
        f&quot;{comes_from.name} depends on {req} &quot;
    )

return InstallRequirement(
    req,
    comes_from,
    isolated=isolated,
    user_supplied=user_supplied,
)
</pre></div>
</div>
<p>def install_req_from_parsed_requirement(
parsed_req: ParsedRequirement,
isolated: bool = False,
user_supplied: bool = False,
config_settings: dict[str, str | list[str]] | None = None,
) -&gt; InstallRequirement:
if parsed_req.is_editable:
req = install_req_from_editable(
parsed_req.requirement,
comes_from=parsed_req.comes_from,
constraint=parsed_req.constraint,
isolated=isolated,
user_supplied=user_supplied,
config_settings=config_settings,
)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>else:
    req = install_req_from_line(
        parsed_req.requirement,
        comes_from=parsed_req.comes_from,
        isolated=isolated,
        hash_options=(
            parsed_req.options.get(&quot;hashes&quot;, {}) if parsed_req.options else {}
        ),
        constraint=parsed_req.constraint,
        line_source=parsed_req.line_source,
        user_supplied=user_supplied,
        config_settings=config_settings,
    )
return req
</pre></div>
</div>
<p>def install_req_from_link_and_ireq(
link: Link, ireq: InstallRequirement
) -&gt; InstallRequirement:
return InstallRequirement(
req=ireq.req,
comes_from=ireq.comes_from,
editable=ireq.editable,
link=link,
markers=ireq.markers,
isolated=ireq.isolated,
hash_options=ireq.hash_options,
config_settings=ireq.config_settings,
user_supplied=ireq.user_supplied,
)</p>
<p>def install_req_drop_extras(ireq: InstallRequirement) -&gt; InstallRequirement:
“””
Creates a new InstallationRequirement using the given template but without
any extras. Sets the original requirement as the new one’s parent
(comes_from).
“””
return InstallRequirement(
req=(
_set_requirement_extras(ireq.req, set()) if ireq.req is not None else None
),
comes_from=ireq,
editable=ireq.editable,
link=ireq.link,
markers=ireq.markers,
isolated=ireq.isolated,
hash_options=ireq.hash_options,
constraint=ireq.constraint,
extras=[],
config_settings=ireq.config_settings,
user_supplied=ireq.user_supplied,
permit_editable_wheels=ireq.permit_editable_wheels,
)</p>
<p>def install_req_extend_extras(
ireq: InstallRequirement,
extras: Collection[str],
) -&gt; InstallRequirement:
“””
Returns a copy of an installation requirement with some additional extras.
Makes a shallow copy of the ireq object.
“””
result = copy.copy(ireq)
result.extras = {*ireq.extras, *extras}
result.req = (
_set_requirement_extras(ireq.req, result.extras)
if ireq.req is not None
else None
)
return result</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>