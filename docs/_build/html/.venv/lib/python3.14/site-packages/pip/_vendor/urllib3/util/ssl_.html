

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Maps the length of a digest to a possible hash function producing this digest &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Maps the length of a digest to a possible hash function producing this digest</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/util/ssl_.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import absolute_import</p>
<p>import hashlib
import hmac
import os
import sys
import warnings
from binascii import hexlify, unhexlify</p>
<p>from ..exceptions import (
InsecurePlatformWarning,
ProxySchemeUnsupported,
SNIMissingWarning,
SSLError,
)
from ..packages import six
from .url import BRACELESS_IPV6_ADDRZ_RE, IPV4_RE</p>
<p>SSLContext = None
SSLTransport = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False
ALPN_PROTOCOLS = [“http/1.1”]</p>
<section id="maps-the-length-of-a-digest-to-a-possible-hash-function-producing-this-digest">
<h1>Maps the length of a digest to a possible hash function producing this digest<a class="headerlink" href="#maps-the-length-of-a-digest-to-a-possible-hash-function-producing-this-digest" title="Link to this heading"></a></h1>
<p>HASHFUNC_MAP = {
length: getattr(hashlib, algorithm, None)
for length, algorithm in ((32, “md5”), (40, “sha1”), (64, “sha256”))
}</p>
<p>def _const_compare_digest_backport(a, b):
“””
Compare two digests of equal length in constant time.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The digests must be of type str/bytes.
Returns True if the digests match, and False otherwise.
&quot;&quot;&quot;
result = abs(len(a) - len(b))
for left, right in zip(bytearray(a), bytearray(b)):
    result |= left ^ right
return result == 0
</pre></div>
</div>
<p>_const_compare_digest = getattr(hmac, “compare_digest”, _const_compare_digest_backport)</p>
<p>try:  # Test for SSL features
import ssl
from ssl import CERT_REQUIRED, wrap_socket
except ImportError:
pass</p>
<p>try:
from ssl import HAS_SNI  # Has SNI?
except ImportError:
pass</p>
<p>try:
from .ssltransport import SSLTransport
except ImportError:
pass</p>
<p>try:  # Platform-specific: Python 3.6
from ssl import PROTOCOL_TLS</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PROTOCOL_SSLv23 = PROTOCOL_TLS
</pre></div>
</div>
<p>except ImportError:
try:
from ssl import PROTOCOL_SSLv23 as PROTOCOL_TLS</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    PROTOCOL_SSLv23 = PROTOCOL_TLS
except ImportError:
    PROTOCOL_SSLv23 = PROTOCOL_TLS = 2
</pre></div>
</div>
<p>try:
from ssl import PROTOCOL_TLS_CLIENT
except ImportError:
PROTOCOL_TLS_CLIENT = PROTOCOL_TLS</p>
<p>try:
from ssl import OP_NO_COMPRESSION, OP_NO_SSLv2, OP_NO_SSLv3
except ImportError:
OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
OP_NO_COMPRESSION = 0x20000</p>
<p>try:  # OP_NO_TICKET was added in Python 3.6
from ssl import OP_NO_TICKET
except ImportError:
OP_NO_TICKET = 0x4000</p>
</section>
<section id="a-secure-default">
<h1>A secure default.<a class="headerlink" href="#a-secure-default" title="Link to this heading"></a></h1>
</section>
<section id="sources-for-more-information-on-tls-ciphers">
<h1>Sources for more information on TLS ciphers:<a class="headerlink" href="#sources-for-more-information-on-tls-ciphers" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="https-wiki-mozilla-org-security-server-side-tls">
<h1>- https://wiki.mozilla.org/Security/Server_Side_TLS<a class="headerlink" href="#https-wiki-mozilla-org-security-server-side-tls" title="Link to this heading"></a></h1>
</section>
<section id="https-www-ssllabs-com-projects-best-practices-index-html">
<h1>- https://www.ssllabs.com/projects/best-practices/index.html<a class="headerlink" href="#https-www-ssllabs-com-projects-best-practices-index-html" title="Link to this heading"></a></h1>
</section>
<section id="https-hynek-me-articles-hardening-your-web-servers-ssl-ciphers">
<h1>- https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/<a class="headerlink" href="#https-hynek-me-articles-hardening-your-web-servers-ssl-ciphers" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
</section>
<section id="the-general-intent-is">
<h1>The general intent is:<a class="headerlink" href="#the-general-intent-is" title="Link to this heading"></a></h1>
</section>
<section id="prefer-cipher-suites-that-offer-perfect-forward-secrecy-dhe-ecdhe">
<h1>- prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),<a class="headerlink" href="#prefer-cipher-suites-that-offer-perfect-forward-secrecy-dhe-ecdhe" title="Link to this heading"></a></h1>
</section>
<section id="prefer-ecdhe-over-dhe-for-better-performance">
<h1>- prefer ECDHE over DHE for better performance,<a class="headerlink" href="#prefer-ecdhe-over-dhe-for-better-performance" title="Link to this heading"></a></h1>
</section>
<section id="prefer-any-aes-gcm-and-chacha20-over-any-aes-cbc-for-better-performance-and">
<h1>- prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and<a class="headerlink" href="#prefer-any-aes-gcm-and-chacha20-over-any-aes-cbc-for-better-performance-and" title="Link to this heading"></a></h1>
</section>
<section id="security">
<h1>security,<a class="headerlink" href="#security" title="Link to this heading"></a></h1>
</section>
<section id="prefer-aes-gcm-over-chacha20-because-hardware-accelerated-aes-is-common">
<h1>- prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,<a class="headerlink" href="#prefer-aes-gcm-over-chacha20-because-hardware-accelerated-aes-is-common" title="Link to this heading"></a></h1>
</section>
<section id="disable-null-authentication-md5-macs-dss-and-other">
<h1>- disable NULL authentication, MD5 MACs, DSS, and other<a class="headerlink" href="#disable-null-authentication-md5-macs-dss-and-other" title="Link to this heading"></a></h1>
</section>
<section id="insecure-ciphers-for-security-reasons">
<h1>insecure ciphers for security reasons.<a class="headerlink" href="#insecure-ciphers-for-security-reasons" title="Link to this heading"></a></h1>
</section>
<section id="note-tls-1-3-cipher-suites-are-managed-through-a-different-interface">
<h1>- NOTE: TLS 1.3 cipher suites are managed through a different interface<a class="headerlink" href="#note-tls-1-3-cipher-suites-are-managed-through-a-different-interface" title="Link to this heading"></a></h1>
</section>
<section id="not-exposed-by-cpython-yet-and-are-enabled-by-default-if-they-re-available">
<h1>not exposed by CPython (yet!) and are enabled by default if they’re available.<a class="headerlink" href="#not-exposed-by-cpython-yet-and-are-enabled-by-default-if-they-re-available" title="Link to this heading"></a></h1>
<p>DEFAULT_CIPHERS = “:”.join(
[
“ECDHE+AESGCM”,
“ECDHE+CHACHA20”,
“DHE+AESGCM”,
“DHE+CHACHA20”,
“ECDH+AESGCM”,
“DH+AESGCM”,
“ECDH+AES”,
“DH+AES”,
“RSA+AESGCM”,
“RSA+AES”,
“!aNULL”,
“!eNULL”,
“!MD5”,
“!DSS”,
]
)</p>
<p>try:
from ssl import SSLContext  # Modern SSL?
except ImportError:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class SSLContext(object):  # Platform-specific: Python 2
    def __init__(self, protocol_version):
        self.protocol = protocol_version
        # Use default values from a real SSLContext
        self.check_hostname = False
        self.verify_mode = ssl.CERT_NONE
        self.ca_certs = None
        self.options = 0
        self.certfile = None
        self.keyfile = None
        self.ciphers = None

    def load_cert_chain(self, certfile, keyfile):
        self.certfile = certfile
        self.keyfile = keyfile

    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        self.ca_certs = cafile

        if capath is not None:
            raise SSLError(&quot;CA directories not supported in older Pythons&quot;)

        if cadata is not None:
            raise SSLError(&quot;CA data not supported in older Pythons&quot;)

    def set_ciphers(self, cipher_suite):
        self.ciphers = cipher_suite

    def wrap_socket(self, socket, server_hostname=None, server_side=False):
        warnings.warn(
            &quot;A true SSLContext object is not available. This prevents &quot;
            &quot;urllib3 from configuring SSL appropriately and may cause &quot;
            &quot;certain SSL connections to fail. You can upgrade to a newer &quot;
            &quot;version of Python to solve this. For more information, see &quot;
            &quot;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&quot;
            &quot;#ssl-warnings&quot;,
            InsecurePlatformWarning,
        )
        kwargs = {
            &quot;keyfile&quot;: self.keyfile,
            &quot;certfile&quot;: self.certfile,
            &quot;ca_certs&quot;: self.ca_certs,
            &quot;cert_reqs&quot;: self.verify_mode,
            &quot;ssl_version&quot;: self.protocol,
            &quot;server_side&quot;: server_side,
        }
        return wrap_socket(socket, ciphers=self.ciphers, **kwargs)
</pre></div>
</div>
<p>def assert_fingerprint(cert, fingerprint):
“””
Checks if given fingerprint matches the supplied certificate.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param cert:
    Certificate as bytes object.
:param fingerprint:
    Fingerprint as string of hexdigits, can be interspersed by colons.
&quot;&quot;&quot;

fingerprint = fingerprint.replace(&quot;:&quot;, &quot;&quot;).lower()
digest_length = len(fingerprint)
if digest_length not in HASHFUNC_MAP:
    raise SSLError(&quot;Fingerprint of invalid length: {0}&quot;.format(fingerprint))
hashfunc = HASHFUNC_MAP.get(digest_length)
if hashfunc is None:
    raise SSLError(
        &quot;Hash function implementation unavailable for fingerprint length: {0}&quot;.format(
            digest_length
        )
    )

# We need encode() here for py32; works on py2 and p33.
fingerprint_bytes = unhexlify(fingerprint.encode())

cert_digest = hashfunc(cert).digest()

if not _const_compare_digest(cert_digest, fingerprint_bytes):
    raise SSLError(
        &#39;Fingerprints did not match. Expected &quot;{0}&quot;, got &quot;{1}&quot;.&#39;.format(
            fingerprint, hexlify(cert_digest)
        )
    )
</pre></div>
</div>
<p>def resolve_cert_reqs(candidate):
“””
Resolves the argument to a numeric constant, which can be passed to
the wrap_socket function/method from the ssl module.
Defaults to :data:<code class="docutils literal notranslate"><span class="pre">ssl.CERT_REQUIRED</span></code>.
If given a string it is assumed to be the name of the constant in the
:mod:<code class="docutils literal notranslate"><span class="pre">ssl</span></code> module or its abbreviation.
(So you can specify <code class="docutils literal notranslate"><span class="pre">REQUIRED</span></code> instead of <code class="docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code>.
If it’s neither <code class="docutils literal notranslate"><span class="pre">None</span></code> nor a string we assume it is already the numeric
constant which can directly be passed to wrap_socket.
“””
if candidate is None:
return CERT_REQUIRED</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if isinstance(candidate, str):
    res = getattr(ssl, candidate, None)
    if res is None:
        res = getattr(ssl, &quot;CERT_&quot; + candidate)
    return res

return candidate
</pre></div>
</div>
<p>def resolve_ssl_version(candidate):
“””
like resolve_cert_reqs
“””
if candidate is None:
return PROTOCOL_TLS</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if isinstance(candidate, str):
    res = getattr(ssl, candidate, None)
    if res is None:
        res = getattr(ssl, &quot;PROTOCOL_&quot; + candidate)
    return res

return candidate
</pre></div>
</div>
<p>def create_urllib3_context(
ssl_version=None, cert_reqs=None, options=None, ciphers=None
):
“””All arguments have the same meaning as <code class="docutils literal notranslate"><span class="pre">ssl_wrap_socket</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>By default, this function does a lot of the same work that
``ssl.create_default_context`` does on Python 3.4+. It:

- Disables SSLv2, SSLv3, and compression
- Sets a restricted set of server ciphers

If you wish to enable SSLv3, you can do::

    from pip._vendor.urllib3.util import ssl_
    context = ssl_.create_urllib3_context()
    context.options &amp;= ~ssl_.OP_NO_SSLv3

You can do the same to enable compression (substituting ``COMPRESSION``
for ``SSLv3`` in the last line above).

:param ssl_version:
    The desired protocol version to use. This will default to
    PROTOCOL_SSLv23 which will negotiate the highest protocol that both
    the server and your installation of OpenSSL support.
:param cert_reqs:
    Whether to require the certificate verification. This defaults to
    ``ssl.CERT_REQUIRED``.
:param options:
    Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
    ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.
:param ciphers:
    Which cipher suites to allow the server to select.
:returns:
    Constructed SSLContext object with specified options
:rtype: SSLContext
&quot;&quot;&quot;
# PROTOCOL_TLS is deprecated in Python 3.10
if not ssl_version or ssl_version == PROTOCOL_TLS:
    ssl_version = PROTOCOL_TLS_CLIENT

context = SSLContext(ssl_version)

context.set_ciphers(ciphers or DEFAULT_CIPHERS)

# Setting the default here, as we may have no ssl module on import
cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

if options is None:
    options = 0
    # SSLv2 is easily broken and is considered harmful and dangerous
    options |= OP_NO_SSLv2
    # SSLv3 has several problems and is now dangerous
    options |= OP_NO_SSLv3
    # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
    # (issue #309)
    options |= OP_NO_COMPRESSION
    # TLSv1.2 only. Unless set explicitly, do not request tickets.
    # This may save some bandwidth on wire, and although the ticket is encrypted,
    # there is a risk associated with it being on wire,
    # if the server is not rotating its ticketing keys properly.
    options |= OP_NO_TICKET

context.options |= options

# Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is
# necessary for conditional client cert authentication with TLS 1.3.
# The attribute is None for OpenSSL &lt;= 1.1.0 or does not exist in older
# versions of Python.  We only enable on Python 3.7.4+ or if certificate
# verification is enabled to work around Python issue #37428
# See: https://bugs.python.org/issue37428
if (cert_reqs == ssl.CERT_REQUIRED or sys.version_info &gt;= (3, 7, 4)) and getattr(
    context, &quot;post_handshake_auth&quot;, None
) is not None:
    context.post_handshake_auth = True

def disable_check_hostname():
    if (
        getattr(context, &quot;check_hostname&quot;, None) is not None
    ):  # Platform-specific: Python 3.2
        # We do our own verification, including fingerprints and alternative
        # hostnames. So disable it here
        context.check_hostname = False

# The order of the below lines setting verify_mode and check_hostname
# matter due to safe-guards SSLContext has to prevent an SSLContext with
# check_hostname=True, verify_mode=NONE/OPTIONAL. This is made even more
# complex because we don&#39;t know whether PROTOCOL_TLS_CLIENT will be used
# or not so we don&#39;t know the initial state of the freshly created SSLContext.
if cert_reqs == ssl.CERT_REQUIRED:
    context.verify_mode = cert_reqs
    disable_check_hostname()
else:
    disable_check_hostname()
    context.verify_mode = cert_reqs

# Enable logging of TLS session keys via defacto standard environment variable
# &#39;SSLKEYLOGFILE&#39;, if the feature is available (Python 3.8+). Skip empty values.
if hasattr(context, &quot;keylog_filename&quot;):
    sslkeylogfile = os.environ.get(&quot;SSLKEYLOGFILE&quot;)
    if sslkeylogfile:
        context.keylog_filename = sslkeylogfile

return context
</pre></div>
</div>
<p>def ssl_wrap_socket(
sock,
keyfile=None,
certfile=None,
cert_reqs=None,
ca_certs=None,
server_hostname=None,
ssl_version=None,
ciphers=None,
ssl_context=None,
ca_cert_dir=None,
key_password=None,
ca_cert_data=None,
tls_in_tls=False,
):
“””
All arguments except for server_hostname, ssl_context, and ca_cert_dir have
the same meaning as they do when using :func:<code class="docutils literal notranslate"><span class="pre">ssl.wrap_socket</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param server_hostname:
    When SNI is supported, the expected hostname of the certificate
:param ssl_context:
    A pre-made :class:`SSLContext` object. If none is provided, one will
    be created using :func:`create_urllib3_context`.
:param ciphers:
    A string of ciphers we wish the client to support.
:param ca_cert_dir:
    A directory containing CA certificates in multiple separate files, as
    supported by OpenSSL&#39;s -CApath flag or the capath argument to
    SSLContext.load_verify_locations().
:param key_password:
    Optional password if the keyfile is encrypted.
:param ca_cert_data:
    Optional string containing CA certificates in PEM format suitable for
    passing as the cadata parameter to SSLContext.load_verify_locations()
:param tls_in_tls:
    Use SSLTransport to wrap the existing socket.
&quot;&quot;&quot;
context = ssl_context
if context is None:
    # Note: This branch of code and all the variables in it are no longer
    # used by urllib3 itself. We should consider deprecating and removing
    # this code.
    context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)

if ca_certs or ca_cert_dir or ca_cert_data:
    try:
        context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)
    except (IOError, OSError) as e:
        raise SSLError(e)

elif ssl_context is None and hasattr(context, &quot;load_default_certs&quot;):
    # try to load OS default certs; works well on Windows (require Python3.4+)
    context.load_default_certs()

# Attempt to detect if we get the goofy behavior of the
# keyfile being encrypted and OpenSSL asking for the
# passphrase via the terminal and instead error out.
if keyfile and key_password is None and _is_key_file_encrypted(keyfile):
    raise SSLError(&quot;Client private key is encrypted, password is required&quot;)

if certfile:
    if key_password is None:
        context.load_cert_chain(certfile, keyfile)
    else:
        context.load_cert_chain(certfile, keyfile, key_password)

try:
    if hasattr(context, &quot;set_alpn_protocols&quot;):
        context.set_alpn_protocols(ALPN_PROTOCOLS)
except NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols
    pass

# If we detect server_hostname is an IP address then the SNI
# extension should not be used according to RFC3546 Section 3.1
use_sni_hostname = server_hostname and not is_ipaddress(server_hostname)
# SecureTransport uses server_hostname in certificate verification.
send_sni = (use_sni_hostname and HAS_SNI) or (
    IS_SECURETRANSPORT and server_hostname
)
# Do not warn the user if server_hostname is an invalid SNI hostname.
if not HAS_SNI and use_sni_hostname:
    warnings.warn(
        &quot;An HTTPS request has been made, but the SNI (Server Name &quot;
        &quot;Indication) extension to TLS is not available on this platform. &quot;
        &quot;This may cause the server to present an incorrect TLS &quot;
        &quot;certificate, which can cause validation failures. You can upgrade to &quot;
        &quot;a newer version of Python to solve this. For more information, see &quot;
        &quot;https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html&quot;
        &quot;#ssl-warnings&quot;,
        SNIMissingWarning,
    )

if send_sni:
    ssl_sock = _ssl_wrap_socket_impl(
        sock, context, tls_in_tls, server_hostname=server_hostname
    )
else:
    ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)
return ssl_sock
</pre></div>
</div>
<p>def is_ipaddress(hostname):
“””Detects whether the hostname given is an IPv4 or IPv6 address.
Also detects IPv6 addresses with Zone IDs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param str hostname: Hostname to examine.
:return: True if the hostname is an IP address, False otherwise.
&quot;&quot;&quot;
if not six.PY2 and isinstance(hostname, bytes):
    # IDN A-label bytes are ASCII compatible.
    hostname = hostname.decode(&quot;ascii&quot;)
return bool(IPV4_RE.match(hostname) or BRACELESS_IPV6_ADDRZ_RE.match(hostname))
</pre></div>
</div>
<p>def _is_key_file_encrypted(key_file):
“””Detects if a key file is encrypted or not.”””
with open(key_file, “r”) as f:
for line in f:
# Look for Proc-Type: 4,ENCRYPTED
if “ENCRYPTED” in line:
return True</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>return False
</pre></div>
</div>
<p>def _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname=None):
if tls_in_tls:
if not SSLTransport:
# Import error, ssl is not available.
raise ProxySchemeUnsupported(
“TLS in TLS requires support for the ‘ssl’ module”
)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)
    return SSLTransport(sock, ssl_context, server_hostname)

if server_hostname:
    return ssl_context.wrap_socket(sock, server_hostname=server_hostname)
else:
    return ssl_context.wrap_socket(sock)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>