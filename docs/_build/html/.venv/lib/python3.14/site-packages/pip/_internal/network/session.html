

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Import ssl from compat so the initial import occurs in only one place. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Import ssl from compat so the initial import occurs in only one place.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/network/session.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””PipSession and supporting code, containing all pip-specific
network request configuration and behavior.
“””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import email.utils
import functools
import io
import ipaddress
import json
import logging
import mimetypes
import os
import platform
import shutil
import subprocess
import sys
import urllib.parse
import warnings
from collections.abc import Generator, Mapping, Sequence
from typing import (
TYPE_CHECKING,
Any,
Optional,
Union,
)</p>
<p>from pip._vendor import requests, urllib3
from pip._vendor.cachecontrol import CacheControlAdapter as _BaseCacheControlAdapter
from pip._vendor.requests.adapters import DEFAULT_POOLBLOCK, BaseAdapter
from pip._vendor.requests.adapters import HTTPAdapter as _BaseHTTPAdapter
from pip._vendor.requests.models import PreparedRequest, Response
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.urllib3.connectionpool import ConnectionPool
from pip._vendor.urllib3.exceptions import InsecureRequestWarning</p>
<p>from pip import <strong>version</strong>
from pip._internal.metadata import get_default_environment
from pip._internal.models.link import Link
from pip._internal.network.auth import MultiDomainBasicAuth
from pip._internal.network.cache import SafeFileCache</p>
<section id="import-ssl-from-compat-so-the-initial-import-occurs-in-only-one-place">
<h1>Import ssl from compat so the initial import occurs in only one place.<a class="headerlink" href="#import-ssl-from-compat-so-the-initial-import-occurs-in-only-one-place" title="Link to this heading"></a></h1>
<p>from pip._internal.utils.compat import has_tls
from pip._internal.utils.glibc import libc_ver
from pip._internal.utils.misc import build_url_from_netloc, parse_netloc
from pip._internal.utils.urls import url_to_path</p>
<p>if TYPE_CHECKING:
from ssl import SSLContext</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pip._vendor.urllib3.poolmanager import PoolManager
from pip._vendor.urllib3.proxymanager import ProxyManager
</pre></div>
</div>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>SecureOrigin = tuple[str, str, Optional[Union[int, str]]]</p>
</section>
<section id="ignore-warning-raised-when-using-trusted-host">
<h1>Ignore warning raised when using –trusted-host.<a class="headerlink" href="#ignore-warning-raised-when-using-trusted-host" title="Link to this heading"></a></h1>
<p>warnings.filterwarnings(“ignore”, category=InsecureRequestWarning)</p>
<p>SECURE_ORIGINS: list[SecureOrigin] = [
# protocol, hostname, port
# Taken from Chrome’s list of secure origins (See: http://bit.ly/1qrySKC)
(“https”, “<em>”, “</em>”),
(”<em>”, “localhost”, “</em>”),
(”<em>”, “127.0.0.0/8”, “</em>”),
(”<em>”, “::1/128”, “</em>”),
(“file”, “<em>”, None),
# ssh is always secure.
(“ssh”, “</em>”, “*”),
]</p>
</section>
<section id="these-are-environment-variables-present-when-running-under-various">
<h1>These are environment variables present when running under various<a class="headerlink" href="#these-are-environment-variables-present-when-running-under-various" title="Link to this heading"></a></h1>
</section>
<section id="ci-systems-for-each-variable-some-ci-systems-that-use-the-variable">
<h1>CI systems.  For each variable, some CI systems that use the variable<a class="headerlink" href="#ci-systems-for-each-variable-some-ci-systems-that-use-the-variable" title="Link to this heading"></a></h1>
</section>
<section id="are-indicated-the-collection-was-chosen-so-that-for-each-of-a-number">
<h1>are indicated.  The collection was chosen so that for each of a number<a class="headerlink" href="#are-indicated-the-collection-was-chosen-so-that-for-each-of-a-number" title="Link to this heading"></a></h1>
</section>
<section id="of-popular-systems-at-least-one-of-the-environment-variables-is-used">
<h1>of popular systems, at least one of the environment variables is used.<a class="headerlink" href="#of-popular-systems-at-least-one-of-the-environment-variables-is-used" title="Link to this heading"></a></h1>
</section>
<section id="this-list-is-used-to-provide-some-indication-of-and-lower-bound-for">
<h1>This list is used to provide some indication of and lower bound for<a class="headerlink" href="#this-list-is-used-to-provide-some-indication-of-and-lower-bound-for" title="Link to this heading"></a></h1>
</section>
<section id="ci-traffic-to-pypi-thus-it-is-okay-if-the-list-is-not-comprehensive">
<h1>CI traffic to PyPI.  Thus, it is okay if the list is not comprehensive.<a class="headerlink" href="#ci-traffic-to-pypi-thus-it-is-okay-if-the-list-is-not-comprehensive" title="Link to this heading"></a></h1>
</section>
<section id="for-more-background-see-https-github-com-pypa-pip-issues-5499">
<h1>For more background, see: https://github.com/pypa/pip/issues/5499<a class="headerlink" href="#for-more-background-see-https-github-com-pypa-pip-issues-5499" title="Link to this heading"></a></h1>
<p>CI_ENVIRONMENT_VARIABLES = (
# Azure Pipelines
“BUILD_BUILDID”,
# Jenkins
“BUILD_ID”,
# AppVeyor, CircleCI, Codeship, Gitlab CI, Shippable, Travis CI
“CI”,
# Explicit environment variable.
“PIP_IS_CI”,
)</p>
<p>def looks_like_ci() -&gt; bool:
“””
Return whether it looks like pip is running under CI.
“””
# We don’t use the method of checking for a tty (e.g. using isatty())
# because some CI systems mimic a tty (e.g. Travis CI).  Thus that
# method doesn’t provide definitive information in either direction.
return any(name in os.environ for name in CI_ENVIRONMENT_VARIABLES)</p>
<p>&#64;functools.lru_cache(maxsize=1)
def user_agent() -&gt; str:
“””
Return a string representing the user agent.
“””
data: dict[str, Any] = {
“installer”: {“name”: “pip”, “version”: <strong>version</strong>},
“python”: platform.python_version(),
“implementation”: {
“name”: platform.python_implementation(),
},
}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if data[&quot;implementation&quot;][&quot;name&quot;] == &quot;CPython&quot;:
    data[&quot;implementation&quot;][&quot;version&quot;] = platform.python_version()
elif data[&quot;implementation&quot;][&quot;name&quot;] == &quot;PyPy&quot;:
    pypy_version_info = sys.pypy_version_info  # type: ignore
    if pypy_version_info.releaselevel == &quot;final&quot;:
        pypy_version_info = pypy_version_info[:3]
    data[&quot;implementation&quot;][&quot;version&quot;] = &quot;.&quot;.join(
        [str(x) for x in pypy_version_info]
    )
elif data[&quot;implementation&quot;][&quot;name&quot;] == &quot;Jython&quot;:
    # Complete Guess
    data[&quot;implementation&quot;][&quot;version&quot;] = platform.python_version()
elif data[&quot;implementation&quot;][&quot;name&quot;] == &quot;IronPython&quot;:
    # Complete Guess
    data[&quot;implementation&quot;][&quot;version&quot;] = platform.python_version()

if sys.platform.startswith(&quot;linux&quot;):
    from pip._vendor import distro

    linux_distribution = distro.name(), distro.version(), distro.codename()
    distro_infos: dict[str, Any] = dict(
        filter(
            lambda x: x[1],
            zip([&quot;name&quot;, &quot;version&quot;, &quot;id&quot;], linux_distribution),
        )
    )
    libc = dict(
        filter(
            lambda x: x[1],
            zip([&quot;lib&quot;, &quot;version&quot;], libc_ver()),
        )
    )
    if libc:
        distro_infos[&quot;libc&quot;] = libc
    if distro_infos:
        data[&quot;distro&quot;] = distro_infos

if sys.platform.startswith(&quot;darwin&quot;) and platform.mac_ver()[0]:
    data[&quot;distro&quot;] = {&quot;name&quot;: &quot;macOS&quot;, &quot;version&quot;: platform.mac_ver()[0]}

if platform.system():
    data.setdefault(&quot;system&quot;, {})[&quot;name&quot;] = platform.system()

if platform.release():
    data.setdefault(&quot;system&quot;, {})[&quot;release&quot;] = platform.release()

if platform.machine():
    data[&quot;cpu&quot;] = platform.machine()

if has_tls():
    import _ssl as ssl

    data[&quot;openssl_version&quot;] = ssl.OPENSSL_VERSION

setuptools_dist = get_default_environment().get_distribution(&quot;setuptools&quot;)
if setuptools_dist is not None:
    data[&quot;setuptools_version&quot;] = str(setuptools_dist.version)

if shutil.which(&quot;rustc&quot;) is not None:
    # If for any reason `rustc --version` fails, silently ignore it
    try:
        rustc_output = subprocess.check_output(
            [&quot;rustc&quot;, &quot;--version&quot;], stderr=subprocess.STDOUT, timeout=0.5
        )
    except Exception:
        pass
    else:
        if rustc_output.startswith(b&quot;rustc &quot;):
            # The format of `rustc --version` is:
            # `b&#39;rustc 1.52.1 (9bc8c42bb 2021-05-09)\n&#39;`
            # We extract just the middle (1.52.1) part
            data[&quot;rustc_version&quot;] = rustc_output.split(b&quot; &quot;)[1].decode()

# Use None rather than False so as not to give the impression that
# pip knows it is not being run under CI.  Rather, it is a null or
# inconclusive result.  Also, we include some value rather than no
# value to make it easier to know that the check has been run.
data[&quot;ci&quot;] = True if looks_like_ci() else None

user_data = os.environ.get(&quot;PIP_USER_AGENT_USER_DATA&quot;)
if user_data is not None:
    data[&quot;user_data&quot;] = user_data

return &quot;{data[installer][name]}/{data[installer][version]} {json}&quot;.format(
    data=data,
    json=json.dumps(data, separators=(&quot;,&quot;, &quot;:&quot;), sort_keys=True),
)
</pre></div>
</div>
<p>class LocalFSAdapter(BaseAdapter):
def send(
self,
request: PreparedRequest,
stream: bool = False,
timeout: float | tuple[float, float] | None = None,
verify: bool | str = True,
cert: str | tuple[str, str] | None = None,
proxies: Mapping[str, str] | None = None,
) -&gt; Response:
pathname = url_to_path(request.url)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    resp = Response()
    resp.status_code = 200
    resp.url = request.url

    try:
        stats = os.stat(pathname)
    except OSError as exc:
        # format the exception raised as a io.BytesIO object,
        # to return a better error message:
        resp.status_code = 404
        resp.reason = type(exc).__name__
        resp.raw = io.BytesIO(f&quot;{resp.reason}: {exc}&quot;.encode())
    else:
        modified = email.utils.formatdate(stats.st_mtime, usegmt=True)
        content_type = mimetypes.guess_type(pathname)[0] or &quot;text/plain&quot;
        resp.headers = CaseInsensitiveDict(
            {
                &quot;Content-Type&quot;: content_type,
                &quot;Content-Length&quot;: stats.st_size,
                &quot;Last-Modified&quot;: modified,
            }
        )

        resp.raw = open(pathname, &quot;rb&quot;)
        resp.close = resp.raw.close

    return resp

def close(self) -&gt; None:
    pass
</pre></div>
</div>
<p>class _SSLContextAdapterMixin:
“””Mixin to add the <code class="docutils literal notranslate"><span class="pre">ssl_context</span></code> constructor argument to HTTP adapters.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The additional argument is forwarded directly to the pool manager. This allows us
to dynamically decide what SSL store to use at runtime, which is used to implement
the optional ``truststore`` backend.
&quot;&quot;&quot;

def __init__(
    self,
    *,
    ssl_context: SSLContext | None = None,
    **kwargs: Any,
) -&gt; None:
    self._ssl_context = ssl_context
    super().__init__(**kwargs)

def init_poolmanager(
    self,
    connections: int,
    maxsize: int,
    block: bool = DEFAULT_POOLBLOCK,
    **pool_kwargs: Any,
) -&gt; PoolManager:
    if self._ssl_context is not None:
        pool_kwargs.setdefault(&quot;ssl_context&quot;, self._ssl_context)
    return super().init_poolmanager(  # type: ignore[misc]
        connections=connections,
        maxsize=maxsize,
        block=block,
        **pool_kwargs,
    )

def proxy_manager_for(self, proxy: str, **proxy_kwargs: Any) -&gt; ProxyManager:
    # Proxy manager replaces the pool manager, so inject our SSL
    # context here too. https://github.com/pypa/pip/issues/13288
    if self._ssl_context is not None:
        proxy_kwargs.setdefault(&quot;ssl_context&quot;, self._ssl_context)
    return super().proxy_manager_for(proxy, **proxy_kwargs)  # type: ignore[misc]
</pre></div>
</div>
<p>class HTTPAdapter(_SSLContextAdapterMixin, _BaseHTTPAdapter):
pass</p>
<p>class CacheControlAdapter(_SSLContextAdapterMixin, _BaseCacheControlAdapter):
pass</p>
<p>class InsecureHTTPAdapter(HTTPAdapter):
def cert_verify(
self,
conn: ConnectionPool,
url: str,
verify: bool | str,
cert: str | tuple[str, str] | None,
) -&gt; None:
super().cert_verify(conn=conn, url=url, verify=False, cert=cert)</p>
<p>class InsecureCacheControlAdapter(CacheControlAdapter):
def cert_verify(
self,
conn: ConnectionPool,
url: str,
verify: bool | str,
cert: str | tuple[str, str] | None,
) -&gt; None:
super().cert_verify(conn=conn, url=url, verify=False, cert=cert)</p>
<p>class PipSession(requests.Session):
timeout: int | None = None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    *args: Any,
    retries: int = 0,
    cache: str | None = None,
    trusted_hosts: Sequence[str] = (),
    index_urls: list[str] | None = None,
    ssl_context: SSLContext | None = None,
    **kwargs: Any,
) -&gt; None:
    &quot;&quot;&quot;
    :param trusted_hosts: Domains not to emit warnings for when not using
        HTTPS.
    &quot;&quot;&quot;
    super().__init__(*args, **kwargs)

    # Namespace the attribute with &quot;pip_&quot; just in case to prevent
    # possible conflicts with the base class.
    self.pip_trusted_origins: list[tuple[str, int | None]] = []
    self.pip_proxy = None

    # Attach our User Agent to the request
    self.headers[&quot;User-Agent&quot;] = user_agent()

    # Attach our Authentication handler to the session
    self.auth = MultiDomainBasicAuth(index_urls=index_urls)

    # Create our urllib3.Retry instance which will allow us to customize
    # how we handle retries.
    retries = urllib3.Retry(
        # Set the total number of retries that a particular request can
        # have.
        total=retries,
        # A 503 error from PyPI typically means that the Fastly -&gt; Origin
        # connection got interrupted in some way. A 503 error in general
        # is typically considered a transient error so we&#39;ll go ahead and
        # retry it.
        # A 500 may indicate transient error in Amazon S3
        # A 502 may be a transient error from a CDN like CloudFlare or CloudFront
        # A 520 or 527 - may indicate transient error in CloudFlare
        status_forcelist=[500, 502, 503, 520, 527],
        # Add a small amount of back off between failed requests in
        # order to prevent hammering the service.
        backoff_factor=0.25,
    )  # type: ignore

    # Our Insecure HTTPAdapter disables HTTPS validation. It does not
    # support caching so we&#39;ll use it for all http:// URLs.
    # If caching is disabled, we will also use it for
    # https:// hosts that we&#39;ve marked as ignoring
    # TLS errors for (trusted-hosts).
    insecure_adapter = InsecureHTTPAdapter(max_retries=retries)

    # We want to _only_ cache responses on securely fetched origins or when
    # the host is specified as trusted. We do this because
    # we can&#39;t validate the response of an insecurely/untrusted fetched
    # origin, and we don&#39;t want someone to be able to poison the cache and
    # require manual eviction from the cache to fix it.
    if cache:
        secure_adapter = CacheControlAdapter(
            cache=SafeFileCache(cache),
            max_retries=retries,
            ssl_context=ssl_context,
        )
        self._trusted_host_adapter = InsecureCacheControlAdapter(
            cache=SafeFileCache(cache),
            max_retries=retries,
        )
    else:
        secure_adapter = HTTPAdapter(max_retries=retries, ssl_context=ssl_context)
        self._trusted_host_adapter = insecure_adapter

    self.mount(&quot;https://&quot;, secure_adapter)
    self.mount(&quot;http://&quot;, insecure_adapter)

    # Enable file:// urls
    self.mount(&quot;file://&quot;, LocalFSAdapter())

    for host in trusted_hosts:
        self.add_trusted_host(host, suppress_logging=True)

def update_index_urls(self, new_index_urls: list[str]) -&gt; None:
    &quot;&quot;&quot;
    :param new_index_urls: New index urls to update the authentication
        handler with.
    &quot;&quot;&quot;
    self.auth.index_urls = new_index_urls

def add_trusted_host(
    self, host: str, source: str | None = None, suppress_logging: bool = False
) -&gt; None:
    &quot;&quot;&quot;
    :param host: It is okay to provide a host that has previously been
        added.
    :param source: An optional source string, for logging where the host
        string came from.
    &quot;&quot;&quot;
    if not suppress_logging:
        msg = f&quot;adding trusted host: {host!r}&quot;
        if source is not None:
            msg += f&quot; (from {source})&quot;
        logger.info(msg)

    parsed_host, parsed_port = parse_netloc(host)
    if parsed_host is None:
        raise ValueError(f&quot;Trusted host URL must include a host part: {host!r}&quot;)
    if (parsed_host, parsed_port) not in self.pip_trusted_origins:
        self.pip_trusted_origins.append((parsed_host, parsed_port))

    self.mount(
        build_url_from_netloc(host, scheme=&quot;http&quot;) + &quot;/&quot;, self._trusted_host_adapter
    )
    self.mount(build_url_from_netloc(host) + &quot;/&quot;, self._trusted_host_adapter)
    if not parsed_port:
        self.mount(
            build_url_from_netloc(host, scheme=&quot;http&quot;) + &quot;:&quot;,
            self._trusted_host_adapter,
        )
        # Mount wildcard ports for the same host.
        self.mount(build_url_from_netloc(host) + &quot;:&quot;, self._trusted_host_adapter)

def iter_secure_origins(self) -&gt; Generator[SecureOrigin, None, None]:
    yield from SECURE_ORIGINS
    for host, port in self.pip_trusted_origins:
        yield (&quot;*&quot;, host, &quot;*&quot; if port is None else port)

def is_secure_origin(self, location: Link) -&gt; bool:
    # Determine if this url used a secure transport mechanism
    parsed = urllib.parse.urlparse(str(location))
    origin_protocol, origin_host, origin_port = (
        parsed.scheme,
        parsed.hostname,
        parsed.port,
    )

    # The protocol to use to see if the protocol matches.
    # Don&#39;t count the repository type as part of the protocol: in
    # cases such as &quot;git+ssh&quot;, only use &quot;ssh&quot;. (I.e., Only verify against
    # the last scheme.)
    origin_protocol = origin_protocol.rsplit(&quot;+&quot;, 1)[-1]

    # Determine if our origin is a secure origin by looking through our
    # hardcoded list of secure origins, as well as any additional ones
    # configured on this PackageFinder instance.
    for secure_origin in self.iter_secure_origins():
        secure_protocol, secure_host, secure_port = secure_origin
        if origin_protocol != secure_protocol and secure_protocol != &quot;*&quot;:
            continue

        try:
            addr = ipaddress.ip_address(origin_host or &quot;&quot;)
            network = ipaddress.ip_network(secure_host)
        except ValueError:
            # We don&#39;t have both a valid address or a valid network, so
            # we&#39;ll check this origin against hostnames.
            if (
                origin_host
                and origin_host.lower() != secure_host.lower()
                and secure_host != &quot;*&quot;
            ):
                continue
        else:
            # We have a valid address and network, so see if the address
            # is contained within the network.
            if addr not in network:
                continue

        # Check to see if the port matches.
        if (
            origin_port != secure_port
            and secure_port != &quot;*&quot;
            and secure_port is not None
        ):
            continue

        # If we&#39;ve gotten here, then this origin matches the current
        # secure origin and we should return True
        return True

    # If we&#39;ve gotten to this point, then the origin isn&#39;t secure and we
    # will not accept it as a valid location to search. We will however
    # log a warning that we are ignoring it.
    logger.warning(
        &quot;The repository located at %s is not a trusted or secure host and &quot;
        &quot;is being ignored. If this repository is available via HTTPS we &quot;
        &quot;recommend you use HTTPS instead, otherwise you may silence &quot;
        &quot;this warning and allow it anyway with &#39;--trusted-host %s&#39;.&quot;,
        origin_host,
        origin_host,
    )

    return False

def request(self, method: str, url: str, *args: Any, **kwargs: Any) -&gt; Response:
    # Allow setting a default timeout on a session
    kwargs.setdefault(&quot;timeout&quot;, self.timeout)
    # Allow setting a default proxies on a session
    kwargs.setdefault(&quot;proxies&quot;, self.proxies)

    # Dispatch the actual request
    return super().request(method, url, *args, **kwargs)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>