

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/rich/table.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from dataclasses import dataclass, field, replace
from typing import (
TYPE_CHECKING,
Dict,
Iterable,
List,
NamedTuple,
Optional,
Sequence,
Tuple,
Union,
)</p>
<p>from . import box, errors
from ._loop import loop_first_last, loop_last
from ._pick import pick_bool
from ._ratio import ratio_distribute, ratio_reduce
from .align import VerticalAlignMethod
from .jupyter import JupyterMixin
from .measure import Measurement
from .padding import Padding, PaddingDimensions
from .protocol import is_renderable
from .segment import Segment
from .style import Style, StyleType
from .text import Text, TextType</p>
<p>if TYPE_CHECKING:
from .console import (
Console,
ConsoleOptions,
JustifyMethod,
OverflowMethod,
RenderableType,
RenderResult,
)</p>
<p>&#64;dataclass
class Column:
“””Defines a column within a ~Table.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Args:
    title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.
    caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.
    width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.
    min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.
    box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.
    safe_box (Optional[bool], optional): Disable box characters that don&#39;t display on windows legacy terminal with *raster* fonts. Defaults to True.
    padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).
    collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.
    pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.
    expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.
    show_header (bool, optional): Show a header row. Defaults to True.
    show_footer (bool, optional): Show a footer row. Defaults to False.
    show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.
    show_lines (bool, optional): Draw lines between every row. Defaults to False.
    leading (int, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.
    style (Union[str, Style], optional): Default style for the table. Defaults to &quot;none&quot;.
    row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.
    header_style (Union[str, Style], optional): Style of the header. Defaults to &quot;table.header&quot;.
    footer_style (Union[str, Style], optional): Style of the footer. Defaults to &quot;table.footer&quot;.
    border_style (Union[str, Style], optional): Style of the border. Defaults to None.
    title_style (Union[str, Style], optional): Style of the title. Defaults to None.
    caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.
    title_justify (str, optional): Justify method for title. Defaults to &quot;center&quot;.
    caption_justify (str, optional): Justify method for caption. Defaults to &quot;center&quot;.
    highlight (bool, optional): Highlight cell contents (if str). Defaults to False.
&quot;&quot;&quot;

header: &quot;RenderableType&quot; = &quot;&quot;
&quot;&quot;&quot;RenderableType: Renderable for the header (typically a string)&quot;&quot;&quot;

footer: &quot;RenderableType&quot; = &quot;&quot;
&quot;&quot;&quot;RenderableType: Renderable for the footer (typically a string)&quot;&quot;&quot;

header_style: StyleType = &quot;&quot;
&quot;&quot;&quot;StyleType: The style of the header.&quot;&quot;&quot;

footer_style: StyleType = &quot;&quot;
&quot;&quot;&quot;StyleType: The style of the footer.&quot;&quot;&quot;

style: StyleType = &quot;&quot;
&quot;&quot;&quot;StyleType: The style of the column.&quot;&quot;&quot;

justify: &quot;JustifyMethod&quot; = &quot;left&quot;
&quot;&quot;&quot;str: How to justify text within the column (&quot;left&quot;, &quot;center&quot;, &quot;right&quot;, or &quot;full&quot;)&quot;&quot;&quot;

vertical: &quot;VerticalAlignMethod&quot; = &quot;top&quot;
&quot;&quot;&quot;str: How to vertically align content (&quot;top&quot;, &quot;middle&quot;, or &quot;bottom&quot;)&quot;&quot;&quot;

overflow: &quot;OverflowMethod&quot; = &quot;ellipsis&quot;
&quot;&quot;&quot;str: Overflow method.&quot;&quot;&quot;

width: Optional[int] = None
&quot;&quot;&quot;Optional[int]: Width of the column, or ``None`` (default) to auto calculate width.&quot;&quot;&quot;

min_width: Optional[int] = None
&quot;&quot;&quot;Optional[int]: Minimum width of column, or ``None`` for no minimum. Defaults to None.&quot;&quot;&quot;

max_width: Optional[int] = None
&quot;&quot;&quot;Optional[int]: Maximum width of column, or ``None`` for no maximum. Defaults to None.&quot;&quot;&quot;

ratio: Optional[int] = None
&quot;&quot;&quot;Optional[int]: Ratio to use when calculating column width, or ``None`` (default) to adapt to column contents.&quot;&quot;&quot;

no_wrap: bool = False
&quot;&quot;&quot;bool: Prevent wrapping of text within the column. Defaults to ``False``.&quot;&quot;&quot;

highlight: bool = False
&quot;&quot;&quot;bool: Apply highlighter to column. Defaults to ``False``.&quot;&quot;&quot;

_index: int = 0
&quot;&quot;&quot;Index of column.&quot;&quot;&quot;

_cells: List[&quot;RenderableType&quot;] = field(default_factory=list)

def copy(self) -&gt; &quot;Column&quot;:
    &quot;&quot;&quot;Return a copy of this Column.&quot;&quot;&quot;
    return replace(self, _cells=[])

@property
def cells(self) -&gt; Iterable[&quot;RenderableType&quot;]:
    &quot;&quot;&quot;Get all cells in the column, not including header.&quot;&quot;&quot;
    yield from self._cells

@property
def flexible(self) -&gt; bool:
    &quot;&quot;&quot;Check if this column is flexible.&quot;&quot;&quot;
    return self.ratio is not None
</pre></div>
</div>
<p>&#64;dataclass
class Row:
“””Information regarding a row.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>style: Optional[StyleType] = None
&quot;&quot;&quot;Style to apply to row.&quot;&quot;&quot;

end_section: bool = False
&quot;&quot;&quot;Indicated end of section, which will force a line beneath the row.&quot;&quot;&quot;
</pre></div>
</div>
<p>class _Cell(NamedTuple):
“””A single cell in a table.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>style: StyleType
&quot;&quot;&quot;Style to apply to cell.&quot;&quot;&quot;
renderable: &quot;RenderableType&quot;
&quot;&quot;&quot;Cell renderable.&quot;&quot;&quot;
vertical: VerticalAlignMethod
&quot;&quot;&quot;Cell vertical alignment.&quot;&quot;&quot;
</pre></div>
</div>
<p>class Table(JupyterMixin):
“””A console renderable to draw a table.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Args:
    *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.
    title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.
    caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.
    width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.
    min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.
    box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.
    safe_box (Optional[bool], optional): Disable box characters that don&#39;t display on windows legacy terminal with *raster* fonts. Defaults to True.
    padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).
    collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.
    pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.
    expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.
    show_header (bool, optional): Show a header row. Defaults to True.
    show_footer (bool, optional): Show a footer row. Defaults to False.
    show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.
    show_lines (bool, optional): Draw lines between every row. Defaults to False.
    leading (int, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.
    style (Union[str, Style], optional): Default style for the table. Defaults to &quot;none&quot;.
    row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.
    header_style (Union[str, Style], optional): Style of the header. Defaults to &quot;table.header&quot;.
    footer_style (Union[str, Style], optional): Style of the footer. Defaults to &quot;table.footer&quot;.
    border_style (Union[str, Style], optional): Style of the border. Defaults to None.
    title_style (Union[str, Style], optional): Style of the title. Defaults to None.
    caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.
    title_justify (str, optional): Justify method for title. Defaults to &quot;center&quot;.
    caption_justify (str, optional): Justify method for caption. Defaults to &quot;center&quot;.
    highlight (bool, optional): Highlight cell contents (if str). Defaults to False.
&quot;&quot;&quot;

columns: List[Column]
rows: List[Row]

def __init__(
    self,
    *headers: Union[Column, str],
    title: Optional[TextType] = None,
    caption: Optional[TextType] = None,
    width: Optional[int] = None,
    min_width: Optional[int] = None,
    box: Optional[box.Box] = box.HEAVY_HEAD,
    safe_box: Optional[bool] = None,
    padding: PaddingDimensions = (0, 1),
    collapse_padding: bool = False,
    pad_edge: bool = True,
    expand: bool = False,
    show_header: bool = True,
    show_footer: bool = False,
    show_edge: bool = True,
    show_lines: bool = False,
    leading: int = 0,
    style: StyleType = &quot;none&quot;,
    row_styles: Optional[Iterable[StyleType]] = None,
    header_style: Optional[StyleType] = &quot;table.header&quot;,
    footer_style: Optional[StyleType] = &quot;table.footer&quot;,
    border_style: Optional[StyleType] = None,
    title_style: Optional[StyleType] = None,
    caption_style: Optional[StyleType] = None,
    title_justify: &quot;JustifyMethod&quot; = &quot;center&quot;,
    caption_justify: &quot;JustifyMethod&quot; = &quot;center&quot;,
    highlight: bool = False,
) -&gt; None:
    self.columns: List[Column] = []
    self.rows: List[Row] = []
    self.title = title
    self.caption = caption
    self.width = width
    self.min_width = min_width
    self.box = box
    self.safe_box = safe_box
    self._padding = Padding.unpack(padding)
    self.pad_edge = pad_edge
    self._expand = expand
    self.show_header = show_header
    self.show_footer = show_footer
    self.show_edge = show_edge
    self.show_lines = show_lines
    self.leading = leading
    self.collapse_padding = collapse_padding
    self.style = style
    self.header_style = header_style or &quot;&quot;
    self.footer_style = footer_style or &quot;&quot;
    self.border_style = border_style
    self.title_style = title_style
    self.caption_style = caption_style
    self.title_justify: &quot;JustifyMethod&quot; = title_justify
    self.caption_justify: &quot;JustifyMethod&quot; = caption_justify
    self.highlight = highlight
    self.row_styles: Sequence[StyleType] = list(row_styles or [])
    append_column = self.columns.append
    for header in headers:
        if isinstance(header, str):
            self.add_column(header=header)
        else:
            header._index = len(self.columns)
            append_column(header)

@classmethod
def grid(
    cls,
    *headers: Union[Column, str],
    padding: PaddingDimensions = 0,
    collapse_padding: bool = True,
    pad_edge: bool = False,
    expand: bool = False,
) -&gt; &quot;Table&quot;:
    &quot;&quot;&quot;Get a table with no lines, headers, or footer.

    Args:
        *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.
        padding (PaddingDimensions, optional): Get padding around cells. Defaults to 0.
        collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to True.
        pad_edge (bool, optional): Enable padding around edges of table. Defaults to False.
        expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.

    Returns:
        Table: A table instance.
    &quot;&quot;&quot;
    return cls(
        *headers,
        box=None,
        padding=padding,
        collapse_padding=collapse_padding,
        show_header=False,
        show_footer=False,
        show_edge=False,
        pad_edge=pad_edge,
        expand=expand,
    )

@property
def expand(self) -&gt; bool:
    &quot;&quot;&quot;Setting a non-None self.width implies expand.&quot;&quot;&quot;
    return self._expand or self.width is not None

@expand.setter
def expand(self, expand: bool) -&gt; None:
    &quot;&quot;&quot;Set expand.&quot;&quot;&quot;
    self._expand = expand

@property
def _extra_width(self) -&gt; int:
    &quot;&quot;&quot;Get extra width to add to cell content.&quot;&quot;&quot;
    width = 0
    if self.box and self.show_edge:
        width += 2
    if self.box:
        width += len(self.columns) - 1
    return width

@property
def row_count(self) -&gt; int:
    &quot;&quot;&quot;Get the current number of rows.&quot;&quot;&quot;
    return len(self.rows)

def get_row_style(self, console: &quot;Console&quot;, index: int) -&gt; StyleType:
    &quot;&quot;&quot;Get the current row style.&quot;&quot;&quot;
    style = Style.null()
    if self.row_styles:
        style += console.get_style(self.row_styles[index % len(self.row_styles)])
    row_style = self.rows[index].style
    if row_style is not None:
        style += console.get_style(row_style)
    return style

def __rich_measure__(
    self, console: &quot;Console&quot;, options: &quot;ConsoleOptions&quot;
) -&gt; Measurement:
    max_width = options.max_width
    if self.width is not None:
        max_width = self.width
    if max_width &lt; 0:
        return Measurement(0, 0)

    extra_width = self._extra_width
    max_width = sum(
        self._calculate_column_widths(
            console, options.update_width(max_width - extra_width)
        )
    )
    _measure_column = self._measure_column

    measurements = [
        _measure_column(console, options.update_width(max_width), column)
        for column in self.columns
    ]
    minimum_width = (
        sum(measurement.minimum for measurement in measurements) + extra_width
    )
    maximum_width = (
        sum(measurement.maximum for measurement in measurements) + extra_width
        if (self.width is None)
        else self.width
    )
    measurement = Measurement(minimum_width, maximum_width)
    measurement = measurement.clamp(self.min_width)
    return measurement

@property
def padding(self) -&gt; Tuple[int, int, int, int]:
    &quot;&quot;&quot;Get cell padding.&quot;&quot;&quot;
    return self._padding

@padding.setter
def padding(self, padding: PaddingDimensions) -&gt; &quot;Table&quot;:
    &quot;&quot;&quot;Set cell padding.&quot;&quot;&quot;
    self._padding = Padding.unpack(padding)
    return self

def add_column(
    self,
    header: &quot;RenderableType&quot; = &quot;&quot;,
    footer: &quot;RenderableType&quot; = &quot;&quot;,
    *,
    header_style: Optional[StyleType] = None,
    highlight: Optional[bool] = None,
    footer_style: Optional[StyleType] = None,
    style: Optional[StyleType] = None,
    justify: &quot;JustifyMethod&quot; = &quot;left&quot;,
    vertical: &quot;VerticalAlignMethod&quot; = &quot;top&quot;,
    overflow: &quot;OverflowMethod&quot; = &quot;ellipsis&quot;,
    width: Optional[int] = None,
    min_width: Optional[int] = None,
    max_width: Optional[int] = None,
    ratio: Optional[int] = None,
    no_wrap: bool = False,
) -&gt; None:
    &quot;&quot;&quot;Add a column to the table.

    Args:
        header (RenderableType, optional): Text or renderable for the header.
            Defaults to &quot;&quot;.
        footer (RenderableType, optional): Text or renderable for the footer.
            Defaults to &quot;&quot;.
        header_style (Union[str, Style], optional): Style for the header, or None for default. Defaults to None.
        highlight (bool, optional): Whether to highlight the text. The default of None uses the value of the table (self) object.
        footer_style (Union[str, Style], optional): Style for the footer, or None for default. Defaults to None.
        style (Union[str, Style], optional): Style for the column cells, or None for default. Defaults to None.
        justify (JustifyMethod, optional): Alignment for cells. Defaults to &quot;left&quot;.
        vertical (VerticalAlignMethod, optional): Vertical alignment, one of &quot;top&quot;, &quot;middle&quot;, or &quot;bottom&quot;. Defaults to &quot;top&quot;.
        overflow (OverflowMethod): Overflow method: &quot;crop&quot;, &quot;fold&quot;, &quot;ellipsis&quot;. Defaults to &quot;ellipsis&quot;.
        width (int, optional): Desired width of column in characters, or None to fit to contents. Defaults to None.
        min_width (Optional[int], optional): Minimum width of column, or ``None`` for no minimum. Defaults to None.
        max_width (Optional[int], optional): Maximum width of column, or ``None`` for no maximum. Defaults to None.
        ratio (int, optional): Flexible ratio for the column (requires ``Table.expand`` or ``Table.width``). Defaults to None.
        no_wrap (bool, optional): Set to ``True`` to disable wrapping of this column.
    &quot;&quot;&quot;

    column = Column(
        _index=len(self.columns),
        header=header,
        footer=footer,
        header_style=header_style or &quot;&quot;,
        highlight=highlight if highlight is not None else self.highlight,
        footer_style=footer_style or &quot;&quot;,
        style=style or &quot;&quot;,
        justify=justify,
        vertical=vertical,
        overflow=overflow,
        width=width,
        min_width=min_width,
        max_width=max_width,
        ratio=ratio,
        no_wrap=no_wrap,
    )
    self.columns.append(column)

def add_row(
    self,
    *renderables: Optional[&quot;RenderableType&quot;],
    style: Optional[StyleType] = None,
    end_section: bool = False,
) -&gt; None:
    &quot;&quot;&quot;Add a row of renderables.

    Args:
        *renderables (None or renderable): Each cell in a row must be a renderable object (including str),
            or ``None`` for a blank cell.
        style (StyleType, optional): An optional style to apply to the entire row. Defaults to None.
        end_section (bool, optional): End a section and draw a line. Defaults to False.

    Raises:
        errors.NotRenderableError: If you add something that can&#39;t be rendered.
    &quot;&quot;&quot;

    def add_cell(column: Column, renderable: &quot;RenderableType&quot;) -&gt; None:
        column._cells.append(renderable)

    cell_renderables: List[Optional[&quot;RenderableType&quot;]] = list(renderables)

    columns = self.columns
    if len(cell_renderables) &lt; len(columns):
        cell_renderables = [
            *cell_renderables,
            *[None] * (len(columns) - len(cell_renderables)),
        ]
    for index, renderable in enumerate(cell_renderables):
        if index == len(columns):
            column = Column(_index=index, highlight=self.highlight)
            for _ in self.rows:
                add_cell(column, Text(&quot;&quot;))
            self.columns.append(column)
        else:
            column = columns[index]
        if renderable is None:
            add_cell(column, &quot;&quot;)
        elif is_renderable(renderable):
            add_cell(column, renderable)
        else:
            raise errors.NotRenderableError(
                f&quot;unable to render {type(renderable).__name__}; a string or other renderable object is required&quot;
            )
    self.rows.append(Row(style=style, end_section=end_section))

def add_section(self) -&gt; None:
    &quot;&quot;&quot;Add a new section (draw a line after current row).&quot;&quot;&quot;

    if self.rows:
        self.rows[-1].end_section = True

def __rich_console__(
    self, console: &quot;Console&quot;, options: &quot;ConsoleOptions&quot;
) -&gt; &quot;RenderResult&quot;:
    if not self.columns:
        yield Segment(&quot;\n&quot;)
        return

    max_width = options.max_width
    if self.width is not None:
        max_width = self.width

    extra_width = self._extra_width
    widths = self._calculate_column_widths(
        console, options.update_width(max_width - extra_width)
    )
    table_width = sum(widths) + extra_width

    render_options = options.update(
        width=table_width, highlight=self.highlight, height=None
    )

    def render_annotation(
        text: TextType, style: StyleType, justify: &quot;JustifyMethod&quot; = &quot;center&quot;
    ) -&gt; &quot;RenderResult&quot;:
        render_text = (
            console.render_str(text, style=style, highlight=False)
            if isinstance(text, str)
            else text
        )
        return console.render(
            render_text, options=render_options.update(justify=justify)
        )

    if self.title:
        yield from render_annotation(
            self.title,
            style=Style.pick_first(self.title_style, &quot;table.title&quot;),
            justify=self.title_justify,
        )
    yield from self._render(console, render_options, widths)
    if self.caption:
        yield from render_annotation(
            self.caption,
            style=Style.pick_first(self.caption_style, &quot;table.caption&quot;),
            justify=self.caption_justify,
        )

def _calculate_column_widths(
    self, console: &quot;Console&quot;, options: &quot;ConsoleOptions&quot;
) -&gt; List[int]:
    &quot;&quot;&quot;Calculate the widths of each column, including padding, not including borders.&quot;&quot;&quot;
    max_width = options.max_width
    columns = self.columns
    width_ranges = [
        self._measure_column(console, options, column) for column in columns
    ]
    widths = [_range.maximum or 1 for _range in width_ranges]
    get_padding_width = self._get_padding_width
    extra_width = self._extra_width
    if self.expand:
        ratios = [col.ratio or 0 for col in columns if col.flexible]
        if any(ratios):
            fixed_widths = [
                0 if column.flexible else _range.maximum
                for _range, column in zip(width_ranges, columns)
            ]
            flex_minimum = [
                (column.width or 1) + get_padding_width(column._index)
                for column in columns
                if column.flexible
            ]
            flexible_width = max_width - sum(fixed_widths)
            flex_widths = ratio_distribute(flexible_width, ratios, flex_minimum)
            iter_flex_widths = iter(flex_widths)
            for index, column in enumerate(columns):
                if column.flexible:
                    widths[index] = fixed_widths[index] + next(iter_flex_widths)
    table_width = sum(widths)

    if table_width &gt; max_width:
        widths = self._collapse_widths(
            widths,
            [(column.width is None and not column.no_wrap) for column in columns],
            max_width,
        )
        table_width = sum(widths)
        # last resort, reduce columns evenly
        if table_width &gt; max_width:
            excess_width = table_width - max_width
            widths = ratio_reduce(excess_width, [1] * len(widths), widths, widths)
            table_width = sum(widths)

        width_ranges = [
            self._measure_column(console, options.update_width(width), column)
            for width, column in zip(widths, columns)
        ]
        widths = [_range.maximum or 0 for _range in width_ranges]

    if (table_width &lt; max_width and self.expand) or (
        self.min_width is not None and table_width &lt; (self.min_width - extra_width)
    ):
        _max_width = (
            max_width
            if self.min_width is None
            else min(self.min_width - extra_width, max_width)
        )
        pad_widths = ratio_distribute(_max_width - table_width, widths)
        widths = [_width + pad for _width, pad in zip(widths, pad_widths)]

    return widths

@classmethod
def _collapse_widths(
    cls, widths: List[int], wrapable: List[bool], max_width: int
) -&gt; List[int]:
    &quot;&quot;&quot;Reduce widths so that the total is under max_width.

    Args:
        widths (List[int]): List of widths.
        wrapable (List[bool]): List of booleans that indicate if a column may shrink.
        max_width (int): Maximum width to reduce to.

    Returns:
        List[int]: A new list of widths.
    &quot;&quot;&quot;
    total_width = sum(widths)
    excess_width = total_width - max_width
    if any(wrapable):
        while total_width and excess_width &gt; 0:
            max_column = max(
                width for width, allow_wrap in zip(widths, wrapable) if allow_wrap
            )
            second_max_column = max(
                width if allow_wrap and width != max_column else 0
                for width, allow_wrap in zip(widths, wrapable)
            )
            column_difference = max_column - second_max_column
            ratios = [
                (1 if (width == max_column and allow_wrap) else 0)
                for width, allow_wrap in zip(widths, wrapable)
            ]
            if not any(ratios) or not column_difference:
                break
            max_reduce = [min(excess_width, column_difference)] * len(widths)
            widths = ratio_reduce(excess_width, ratios, max_reduce, widths)

            total_width = sum(widths)
            excess_width = total_width - max_width
    return widths

def _get_cells(
    self, console: &quot;Console&quot;, column_index: int, column: Column
) -&gt; Iterable[_Cell]:
    &quot;&quot;&quot;Get all the cells with padding and optional header.&quot;&quot;&quot;

    collapse_padding = self.collapse_padding
    pad_edge = self.pad_edge
    padding = self.padding
    any_padding = any(padding)

    first_column = column_index == 0
    last_column = column_index == len(self.columns) - 1

    _padding_cache: Dict[Tuple[bool, bool], Tuple[int, int, int, int]] = {}

    def get_padding(first_row: bool, last_row: bool) -&gt; Tuple[int, int, int, int]:
        cached = _padding_cache.get((first_row, last_row))
        if cached:
            return cached
        top, right, bottom, left = padding

        if collapse_padding:
            if not first_column:
                left = max(0, left - right)
            if not last_row:
                bottom = max(0, top - bottom)

        if not pad_edge:
            if first_column:
                left = 0
            if last_column:
                right = 0
            if first_row:
                top = 0
            if last_row:
                bottom = 0
        _padding = (top, right, bottom, left)
        _padding_cache[(first_row, last_row)] = _padding
        return _padding

    raw_cells: List[Tuple[StyleType, &quot;RenderableType&quot;]] = []
    _append = raw_cells.append
    get_style = console.get_style
    if self.show_header:
        header_style = get_style(self.header_style or &quot;&quot;) + get_style(
            column.header_style
        )
        _append((header_style, column.header))
    cell_style = get_style(column.style or &quot;&quot;)
    for cell in column.cells:
        _append((cell_style, cell))
    if self.show_footer:
        footer_style = get_style(self.footer_style or &quot;&quot;) + get_style(
            column.footer_style
        )
        _append((footer_style, column.footer))

    if any_padding:
        _Padding = Padding
        for first, last, (style, renderable) in loop_first_last(raw_cells):
            yield _Cell(
                style,
                _Padding(renderable, get_padding(first, last)),
                getattr(renderable, &quot;vertical&quot;, None) or column.vertical,
            )
    else:
        for style, renderable in raw_cells:
            yield _Cell(
                style,
                renderable,
                getattr(renderable, &quot;vertical&quot;, None) or column.vertical,
            )

def _get_padding_width(self, column_index: int) -&gt; int:
    &quot;&quot;&quot;Get extra width from padding.&quot;&quot;&quot;
    _, pad_right, _, pad_left = self.padding
    if self.collapse_padding:
        if column_index &gt; 0:
            pad_left = max(0, pad_left - pad_right)
    return pad_left + pad_right

def _measure_column(
    self,
    console: &quot;Console&quot;,
    options: &quot;ConsoleOptions&quot;,
    column: Column,
) -&gt; Measurement:
    &quot;&quot;&quot;Get the minimum and maximum width of the column.&quot;&quot;&quot;

    max_width = options.max_width
    if max_width &lt; 1:
        return Measurement(0, 0)

    padding_width = self._get_padding_width(column._index)

    if column.width is not None:
        # Fixed width column
        return Measurement(
            column.width + padding_width, column.width + padding_width
        ).with_maximum(max_width)
    # Flexible column, we need to measure contents
    min_widths: List[int] = []
    max_widths: List[int] = []
    append_min = min_widths.append
    append_max = max_widths.append
    get_render_width = Measurement.get
    for cell in self._get_cells(console, column._index, column):
        _min, _max = get_render_width(console, options, cell.renderable)
        append_min(_min)
        append_max(_max)

    measurement = Measurement(
        max(min_widths) if min_widths else 1,
        max(max_widths) if max_widths else max_width,
    ).with_maximum(max_width)
    measurement = measurement.clamp(
        None if column.min_width is None else column.min_width + padding_width,
        None if column.max_width is None else column.max_width + padding_width,
    )
    return measurement

def _render(
    self, console: &quot;Console&quot;, options: &quot;ConsoleOptions&quot;, widths: List[int]
) -&gt; &quot;RenderResult&quot;:
    table_style = console.get_style(self.style or &quot;&quot;)

    border_style = table_style + console.get_style(self.border_style or &quot;&quot;)
    _column_cells = (
        self._get_cells(console, column_index, column)
        for column_index, column in enumerate(self.columns)
    )
    row_cells: List[Tuple[_Cell, ...]] = list(zip(*_column_cells))
    _box = (
        self.box.substitute(
            options, safe=pick_bool(self.safe_box, console.safe_box)
        )
        if self.box
        else None
    )
    _box = _box.get_plain_headed_box() if _box and not self.show_header else _box

    new_line = Segment.line()

    columns = self.columns
    show_header = self.show_header
    show_footer = self.show_footer
    show_edge = self.show_edge
    show_lines = self.show_lines
    leading = self.leading

    _Segment = Segment
    if _box:
        box_segments = [
            (
                _Segment(_box.head_left, border_style),
                _Segment(_box.head_right, border_style),
                _Segment(_box.head_vertical, border_style),
            ),
            (
                _Segment(_box.mid_left, border_style),
                _Segment(_box.mid_right, border_style),
                _Segment(_box.mid_vertical, border_style),
            ),
            (
                _Segment(_box.foot_left, border_style),
                _Segment(_box.foot_right, border_style),
                _Segment(_box.foot_vertical, border_style),
            ),
        ]
        if show_edge:
            yield _Segment(_box.get_top(widths), border_style)
            yield new_line
    else:
        box_segments = []

    get_row_style = self.get_row_style
    get_style = console.get_style

    for index, (first, last, row_cell) in enumerate(loop_first_last(row_cells)):
        header_row = first and show_header
        footer_row = last and show_footer
        row = (
            self.rows[index - show_header]
            if (not header_row and not footer_row)
            else None
        )
        max_height = 1
        cells: List[List[List[Segment]]] = []
        if header_row or footer_row:
            row_style = Style.null()
        else:
            row_style = get_style(
                get_row_style(console, index - 1 if show_header else index)
            )
        for width, cell, column in zip(widths, row_cell, columns):
            render_options = options.update(
                width=width,
                justify=column.justify,
                no_wrap=column.no_wrap,
                overflow=column.overflow,
                height=None,
                highlight=column.highlight,
            )
            lines = console.render_lines(
                cell.renderable,
                render_options,
                style=get_style(cell.style) + row_style,
            )
            max_height = max(max_height, len(lines))
            cells.append(lines)

        row_height = max(len(cell) for cell in cells)

        def align_cell(
            cell: List[List[Segment]],
            vertical: &quot;VerticalAlignMethod&quot;,
            width: int,
            style: Style,
        ) -&gt; List[List[Segment]]:
            if header_row:
                vertical = &quot;bottom&quot;
            elif footer_row:
                vertical = &quot;top&quot;

            if vertical == &quot;top&quot;:
                return _Segment.align_top(cell, width, row_height, style)
            elif vertical == &quot;middle&quot;:
                return _Segment.align_middle(cell, width, row_height, style)
            return _Segment.align_bottom(cell, width, row_height, style)

        cells[:] = [
            _Segment.set_shape(
                align_cell(
                    cell,
                    _cell.vertical,
                    width,
                    get_style(_cell.style) + row_style,
                ),
                width,
                max_height,
            )
            for width, _cell, cell, column in zip(widths, row_cell, cells, columns)
        ]

        if _box:
            if last and show_footer:
                yield _Segment(
                    _box.get_row(widths, &quot;foot&quot;, edge=show_edge), border_style
                )
                yield new_line
            left, right, _divider = box_segments[0 if first else (2 if last else 1)]

            # If the column divider is whitespace also style it with the row background
            divider = (
                _divider
                if _divider.text.strip()
                else _Segment(
                    _divider.text, row_style.background_style + _divider.style
                )
            )
            for line_no in range(max_height):
                if show_edge:
                    yield left
                for last_cell, rendered_cell in loop_last(cells):
                    yield from rendered_cell[line_no]
                    if not last_cell:
                        yield divider
                if show_edge:
                    yield right
                yield new_line
        else:
            for line_no in range(max_height):
                for rendered_cell in cells:
                    yield from rendered_cell[line_no]
                yield new_line
        if _box and first and show_header:
            yield _Segment(
                _box.get_row(widths, &quot;head&quot;, edge=show_edge), border_style
            )
            yield new_line
        end_section = row and row.end_section
        if _box and (show_lines or leading or end_section):
            if (
                not last
                and not (show_footer and index &gt;= len(row_cells) - 2)
                and not (show_header and header_row)
            ):
                if leading:
                    yield _Segment(
                        _box.get_row(widths, &quot;mid&quot;, edge=show_edge) * leading,
                        border_style,
                    )
                else:
                    yield _Segment(
                        _box.get_row(widths, &quot;row&quot;, edge=show_edge), border_style
                    )
                yield new_line

    if _box and show_edge:
        yield _Segment(_box.get_bottom(widths), border_style)
        yield new_line
</pre></div>
</div>
<p>if <strong>name</strong> == “<strong>main</strong>”:  # pragma: no cover
from pip._vendor.rich.console import Console
from pip._vendor.rich.highlighter import ReprHighlighter</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from ._timer import timer

with timer(&quot;Table render&quot;):
    table = Table(
        title=&quot;Star Wars Movies&quot;,
        caption=&quot;Rich example table&quot;,
        caption_justify=&quot;right&quot;,
    )

    table.add_column(
        &quot;Released&quot;, header_style=&quot;bright_cyan&quot;, style=&quot;cyan&quot;, no_wrap=True
    )
    table.add_column(&quot;Title&quot;, style=&quot;magenta&quot;)
    table.add_column(&quot;Box Office&quot;, justify=&quot;right&quot;, style=&quot;green&quot;)

    table.add_row(
        &quot;Dec 20, 2019&quot;,
        &quot;Star Wars: The Rise of Skywalker&quot;,
        &quot;$952,110,690&quot;,
    )
    table.add_row(&quot;May 25, 2018&quot;, &quot;Solo: A Star Wars Story&quot;, &quot;$393,151,347&quot;)
    table.add_row(
        &quot;Dec 15, 2017&quot;,
        &quot;Star Wars Ep. V111: The Last Jedi&quot;,
        &quot;$1,332,539,889&quot;,
        style=&quot;on black&quot;,
        end_section=True,
    )
    table.add_row(
        &quot;Dec 16, 2016&quot;,
        &quot;Rogue One: A Star Wars Story&quot;,
        &quot;$1,332,439,889&quot;,
    )

    def header(text: str) -&gt; None:
        console.print()
        console.rule(highlight(text))
        console.print()

    console = Console()
    highlight = ReprHighlighter()
    header(&quot;Example Table&quot;)
    console.print(table, justify=&quot;center&quot;)

    table.expand = True
    header(&quot;expand=True&quot;)
    console.print(table)

    table.width = 50
    header(&quot;width=50&quot;)

    console.print(table, justify=&quot;center&quot;)

    table.width = None
    table.expand = False
    table.row_styles = [&quot;dim&quot;, &quot;none&quot;]
    header(&quot;row_styles=[&#39;dim&#39;, &#39;none&#39;]&quot;)

    console.print(table, justify=&quot;center&quot;)

    table.width = None
    table.expand = False
    table.row_styles = [&quot;dim&quot;, &quot;none&quot;]
    table.leading = 1
    header(&quot;leading=1, row_styles=[&#39;dim&#39;, &#39;none&#39;]&quot;)
    console.print(table, justify=&quot;center&quot;)

    table.width = None
    table.expand = False
    table.row_styles = [&quot;dim&quot;, &quot;none&quot;]
    table.show_lines = True
    table.leading = 0
    header(&quot;show_lines=True, row_styles=[&#39;dim&#39;, &#39;none&#39;]&quot;)
    console.print(table, justify=&quot;center&quot;)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>