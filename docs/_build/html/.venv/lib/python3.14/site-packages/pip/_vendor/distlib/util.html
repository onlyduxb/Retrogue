

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title> &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/distlib/util.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="copyright-c-2012-2023-the-python-software-foundation">
<h1>Copyright (C) 2012-2023 The Python Software Foundation.<a class="headerlink" href="#copyright-c-2012-2023-the-python-software-foundation" title="Link to this heading"></a></h1>
</section>
<section id="see-license-txt-and-contributors-txt">
<h1>See LICENSE.txt and CONTRIBUTORS.txt.<a class="headerlink" href="#see-license-txt-and-contributors-txt" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
<p>import codecs
from collections import deque
import contextlib
import csv
from glob import iglob as std_iglob
import io
import json
import logging
import os
import py_compile
import re
import socket
try:
import ssl
except ImportError:  # pragma: no cover
ssl = None
import subprocess
import sys
import tarfile
import tempfile
import textwrap</p>
<p>try:
import threading
except ImportError:  # pragma: no cover
import dummy_threading as threading
import time</p>
<p>from . import DistlibException
from .compat import (string_types, text_type, shutil, raw_input, StringIO, cache_from_source, urlopen, urljoin, httplib,
xmlrpclib, HTTPHandler, BaseConfigurator, valid_ident, Container, configparser, URLError, ZipFile,
fsdecode, unquote, urlparse)</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
</section>
<section id="id3">
<h1><a class="headerlink" href="#id3" title="Link to this heading"></a></h1>
</section>
<section id="requirement-parsing-code-as-per-pep-508">
<h1>Requirement parsing code as per PEP 508<a class="headerlink" href="#requirement-parsing-code-as-per-pep-508" title="Link to this heading"></a></h1>
</section>
<section id="id4">
<h1><a class="headerlink" href="#id4" title="Link to this heading"></a></h1>
<p>IDENTIFIER = re.compile(r’^([\w.-]+)\s*’)
VERSION_IDENTIFIER = re.compile(r’^([\w.<em>+-]+)\s</em>’)
COMPARE_OP = re.compile(r’^(&lt;=?|&gt;=?|={2,3}|[~!]=)\s*’)
MARKER_OP = re.compile(r’^((&lt;=?)|(&gt;=?)|={2,3}|[~!]=|in|not\s+in)\s*’)
OR = re.compile(r’^or\b\s*’)
AND = re.compile(r’^and\b\s*’)
NON_SPACE = re.compile(r’(\S+)\s*’)
STRING_CHUNK = re.compile(r’([\s\w.{}()*+#:;,/?!~`&#64;$%^&amp;=|&lt;&gt;[]-]+)’)</p>
<p>def parse_marker(marker_string):
“””
Parse a marker string and return a dictionary containing a marker expression.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The dictionary will contain keys &quot;op&quot;, &quot;lhs&quot; and &quot;rhs&quot; for non-terminals in
the expression grammar, or strings. A string contained in quotes is to be
interpreted as a literal string, and a string not contained in quotes is a
variable (such as os_name).
&quot;&quot;&quot;

def marker_var(remaining):
    # either identifier, or literal string
    m = IDENTIFIER.match(remaining)
    if m:
        result = m.groups()[0]
        remaining = remaining[m.end():]
    elif not remaining:
        raise SyntaxError(&#39;unexpected end of input&#39;)
    else:
        q = remaining[0]
        if q not in &#39;\&#39;&quot;&#39;:
            raise SyntaxError(&#39;invalid expression: %s&#39; % remaining)
        oq = &#39;\&#39;&quot;&#39;.replace(q, &#39;&#39;)
        remaining = remaining[1:]
        parts = [q]
        while remaining:
            # either a string chunk, or oq, or q to terminate
            if remaining[0] == q:
                break
            elif remaining[0] == oq:
                parts.append(oq)
                remaining = remaining[1:]
            else:
                m = STRING_CHUNK.match(remaining)
                if not m:
                    raise SyntaxError(&#39;error in string literal: %s&#39; % remaining)
                parts.append(m.groups()[0])
                remaining = remaining[m.end():]
        else:
            s = &#39;&#39;.join(parts)
            raise SyntaxError(&#39;unterminated string: %s&#39; % s)
        parts.append(q)
        result = &#39;&#39;.join(parts)
        remaining = remaining[1:].lstrip()  # skip past closing quote
    return result, remaining

def marker_expr(remaining):
    if remaining and remaining[0] == &#39;(&#39;:
        result, remaining = marker(remaining[1:].lstrip())
        if remaining[0] != &#39;)&#39;:
            raise SyntaxError(&#39;unterminated parenthesis: %s&#39; % remaining)
        remaining = remaining[1:].lstrip()
    else:
        lhs, remaining = marker_var(remaining)
        while remaining:
            m = MARKER_OP.match(remaining)
            if not m:
                break
            op = m.groups()[0]
            remaining = remaining[m.end():]
            rhs, remaining = marker_var(remaining)
            lhs = {&#39;op&#39;: op, &#39;lhs&#39;: lhs, &#39;rhs&#39;: rhs}
        result = lhs
    return result, remaining

def marker_and(remaining):
    lhs, remaining = marker_expr(remaining)
    while remaining:
        m = AND.match(remaining)
        if not m:
            break
        remaining = remaining[m.end():]
        rhs, remaining = marker_expr(remaining)
        lhs = {&#39;op&#39;: &#39;and&#39;, &#39;lhs&#39;: lhs, &#39;rhs&#39;: rhs}
    return lhs, remaining

def marker(remaining):
    lhs, remaining = marker_and(remaining)
    while remaining:
        m = OR.match(remaining)
        if not m:
            break
        remaining = remaining[m.end():]
        rhs, remaining = marker_and(remaining)
        lhs = {&#39;op&#39;: &#39;or&#39;, &#39;lhs&#39;: lhs, &#39;rhs&#39;: rhs}
    return lhs, remaining

return marker(marker_string)
</pre></div>
</div>
<p>def parse_requirement(req):
“””
Parse a requirement passed in as a string. Return a Container
whose attributes contain the various parts of the requirement.
“””
remaining = req.strip()
if not remaining or remaining.startswith(‘#’):
return None
m = IDENTIFIER.match(remaining)
if not m:
raise SyntaxError(‘name expected: %s’ % remaining)
distname = m.groups()[0]
remaining = remaining[m.end():]
extras = mark_expr = versions = uri = None
if remaining and remaining[0] == ‘[‘:
i = remaining.find(‘]’, 1)
if i &lt; 0:
raise SyntaxError(‘unterminated extra: %s’ % remaining)
s = remaining[1:i]
remaining = remaining[i + 1:].lstrip()
extras = []
while s:
m = IDENTIFIER.match(s)
if not m:
raise SyntaxError(‘malformed extra: %s’ % s)
extras.append(m.groups()[0])
s = s[m.end():]
if not s:
break
if s[0] != ‘,’:
raise SyntaxError(‘comma expected in extras: %s’ % s)
s = s[1:].lstrip()
if not extras:
extras = None
if remaining:
if remaining[0] == ‘&#64;’:
# it’s a URI
remaining = remaining[1:].lstrip()
m = NON_SPACE.match(remaining)
if not m:
raise SyntaxError(‘invalid URI: %s’ % remaining)
uri = m.groups()[0]
t = urlparse(uri)
# there are issues with Python and URL parsing, so this test
# is a bit crude. See bpo-20271, bpo-23505. Python doesn’t
# always parse invalid URLs correctly - it should raise
# exceptions for malformed URLs
if not (t.scheme and t.netloc):
raise SyntaxError(‘Invalid URL: %s’ % uri)
remaining = remaining[m.end():].lstrip()
else:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        def get_versions(ver_remaining):
            &quot;&quot;&quot;
            Return a list of operator, version tuples if any are
            specified, else None.
            &quot;&quot;&quot;
            m = COMPARE_OP.match(ver_remaining)
            versions = None
            if m:
                versions = []
                while True:
                    op = m.groups()[0]
                    ver_remaining = ver_remaining[m.end():]
                    m = VERSION_IDENTIFIER.match(ver_remaining)
                    if not m:
                        raise SyntaxError(&#39;invalid version: %s&#39; % ver_remaining)
                    v = m.groups()[0]
                    versions.append((op, v))
                    ver_remaining = ver_remaining[m.end():]
                    if not ver_remaining or ver_remaining[0] != &#39;,&#39;:
                        break
                    ver_remaining = ver_remaining[1:].lstrip()
                    # Some packages have a trailing comma which would break things
                    # See issue #148
                    if not ver_remaining:
                        break
                    m = COMPARE_OP.match(ver_remaining)
                    if not m:
                        raise SyntaxError(&#39;invalid constraint: %s&#39; % ver_remaining)
                if not versions:
                    versions = None
            return versions, ver_remaining

        if remaining[0] != &#39;(&#39;:
            versions, remaining = get_versions(remaining)
        else:
            i = remaining.find(&#39;)&#39;, 1)
            if i &lt; 0:
                raise SyntaxError(&#39;unterminated parenthesis: %s&#39; % remaining)
            s = remaining[1:i]
            remaining = remaining[i + 1:].lstrip()
            # As a special diversion from PEP 508, allow a version number
            # a.b.c in parentheses as a synonym for ~= a.b.c (because this
            # is allowed in earlier PEPs)
            if COMPARE_OP.match(s):
                versions, _ = get_versions(s)
            else:
                m = VERSION_IDENTIFIER.match(s)
                if not m:
                    raise SyntaxError(&#39;invalid constraint: %s&#39; % s)
                v = m.groups()[0]
                s = s[m.end():].lstrip()
                if s:
                    raise SyntaxError(&#39;invalid constraint: %s&#39; % s)
                versions = [(&#39;~=&#39;, v)]

if remaining:
    if remaining[0] != &#39;;&#39;:
        raise SyntaxError(&#39;invalid requirement: %s&#39; % remaining)
    remaining = remaining[1:].lstrip()

    mark_expr, remaining = parse_marker(remaining)

if remaining and remaining[0] != &#39;#&#39;:
    raise SyntaxError(&#39;unexpected trailing data: %s&#39; % remaining)

if not versions:
    rs = distname
else:
    rs = &#39;%s %s&#39; % (distname, &#39;, &#39;.join([&#39;%s %s&#39; % con for con in versions]))
return Container(name=distname, extras=extras, constraints=versions, marker=mark_expr, url=uri, requirement=rs)
</pre></div>
</div>
<p>def get_resources_dests(resources_root, rules):
“””Find destinations for resources files”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def get_rel_path(root, path):
    # normalizes and returns a lstripped-/-separated path
    root = root.replace(os.path.sep, &#39;/&#39;)
    path = path.replace(os.path.sep, &#39;/&#39;)
    assert path.startswith(root)
    return path[len(root):].lstrip(&#39;/&#39;)

destinations = {}
for base, suffix, dest in rules:
    prefix = os.path.join(resources_root, base)
    for abs_base in iglob(prefix):
        abs_glob = os.path.join(abs_base, suffix)
        for abs_path in iglob(abs_glob):
            resource_file = get_rel_path(resources_root, abs_path)
            if dest is None:  # remove the entry if it was here
                destinations.pop(resource_file, None)
            else:
                rel_path = get_rel_path(abs_base, abs_path)
                rel_dest = dest.replace(os.path.sep, &#39;/&#39;).rstrip(&#39;/&#39;)
                destinations[resource_file] = rel_dest + &#39;/&#39; + rel_path
return destinations
</pre></div>
</div>
<p>def in_venv():
if hasattr(sys, ‘real_prefix’):
# virtualenv venvs
result = True
else:
# PEP 405 venvs
result = sys.prefix != getattr(sys, ‘base_prefix’, sys.prefix)
return result</p>
<p>def get_executable():
# The <strong>PYVENV_LAUNCHER</strong> dance is apparently no longer needed, as
# changes to the stub launcher mean that sys.executable always points
# to the stub on OS X
#    if sys.platform == ‘darwin’ and (’<strong>PYVENV_LAUNCHER</strong>’
#                                     in os.environ):
#        result =  os.environ[’<strong>PYVENV_LAUNCHER</strong>’]
#    else:
#        result = sys.executable
#    return result
# Avoid normcasing: see issue #143
# result = os.path.normcase(sys.executable)
result = sys.executable
if not isinstance(result, text_type):
result = fsdecode(result)
return result</p>
<p>def proceed(prompt, allowed_chars, error_prompt=None, default=None):
p = prompt
while True:
s = raw_input(p)
p = prompt
if not s and default:
s = default
if s:
c = s[0].lower()
if c in allowed_chars:
break
if error_prompt:
p = ‘%c: %s\n%s’ % (c, error_prompt, prompt)
return c</p>
<p>def extract_by_key(d, keys):
if isinstance(keys, string_types):
keys = keys.split()
result = {}
for key in keys:
if key in d:
result[key] = d[key]
return result</p>
<p>def read_exports(stream):
if sys.version_info[0] &gt;= 3:
# needs to be a text stream
stream = codecs.getreader(‘utf-8’)(stream)
# Try to load as JSON, falling back on legacy format
data = stream.read()
stream = StringIO(data)
try:
jdata = json.load(stream)
result = jdata[‘extensions’][‘python.exports’][‘exports’]
for group, entries in result.items():
for k, v in entries.items():
s = ‘%s = %s’ % (k, v)
entry = get_export_entry(s)
assert entry is not None
entries[k] = entry
return result
except Exception:
stream.seek(0, 0)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def read_stream(cp, stream):
    if hasattr(cp, &#39;read_file&#39;):
        cp.read_file(stream)
    else:
        cp.readfp(stream)

cp = configparser.ConfigParser()
try:
    read_stream(cp, stream)
except configparser.MissingSectionHeaderError:
    stream.close()
    data = textwrap.dedent(data)
    stream = StringIO(data)
    read_stream(cp, stream)

result = {}
for key in cp.sections():
    result[key] = entries = {}
    for name, value in cp.items(key):
        s = &#39;%s = %s&#39; % (name, value)
        entry = get_export_entry(s)
        assert entry is not None
        # entry.dist = self
        entries[name] = entry
return result
</pre></div>
</div>
<p>def write_exports(exports, stream):
if sys.version_info[0] &gt;= 3:
# needs to be a text stream
stream = codecs.getwriter(‘utf-8’)(stream)
cp = configparser.ConfigParser()
for k, v in exports.items():
# TODO check k, v for valid values
cp.add_section(k)
for entry in v.values():
if entry.suffix is None:
s = entry.prefix
else:
s = ‘%s:%s’ % (entry.prefix, entry.suffix)
if entry.flags:
s = ‘%s [%s]’ % (s, ‘, ‘.join(entry.flags))
cp.set(k, entry.name, s)
cp.write(stream)</p>
<p>&#64;contextlib.contextmanager
def tempdir():
td = tempfile.mkdtemp()
try:
yield td
finally:
shutil.rmtree(td)</p>
<p>&#64;contextlib.contextmanager
def chdir(d):
cwd = os.getcwd()
try:
os.chdir(d)
yield
finally:
os.chdir(cwd)</p>
<p>&#64;contextlib.contextmanager
def socket_timeout(seconds=15):
cto = socket.getdefaulttimeout()
try:
socket.setdefaulttimeout(seconds)
yield
finally:
socket.setdefaulttimeout(cto)</p>
<p>class cached_property(object):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, func):
    self.func = func
    # for attr in (&#39;__name__&#39;, &#39;__module__&#39;, &#39;__doc__&#39;):
    #     setattr(self, attr, getattr(func, attr, None))

def __get__(self, obj, cls=None):
    if obj is None:
        return self
    value = self.func(obj)
    object.__setattr__(obj, self.func.__name__, value)
    # obj.__dict__[self.func.__name__] = value = self.func(obj)
    return value
</pre></div>
</div>
<p>def convert_path(pathname):
“””Return ‘pathname’ as a name that will work on the native filesystem.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The path is split on &#39;/&#39; and put back together again using the current
directory separator.  Needed because filenames in the setup script are
always supplied in Unix style, and have to be converted to the local
convention before we can actually use them in the filesystem.  Raises
ValueError on non-Unix-ish systems if &#39;pathname&#39; either starts or
ends with a slash.
&quot;&quot;&quot;
if os.sep == &#39;/&#39;:
    return pathname
if not pathname:
    return pathname
if pathname[0] == &#39;/&#39;:
    raise ValueError(&quot;path &#39;%s&#39; cannot be absolute&quot; % pathname)
if pathname[-1] == &#39;/&#39;:
    raise ValueError(&quot;path &#39;%s&#39; cannot end with &#39;/&#39;&quot; % pathname)

paths = pathname.split(&#39;/&#39;)
while os.curdir in paths:
    paths.remove(os.curdir)
if not paths:
    return os.curdir
return os.path.join(*paths)
</pre></div>
</div>
<p>class FileOperator(object):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, dry_run=False):
    self.dry_run = dry_run
    self.ensured = set()
    self._init_record()

def _init_record(self):
    self.record = False
    self.files_written = set()
    self.dirs_created = set()

def record_as_written(self, path):
    if self.record:
        self.files_written.add(path)

def newer(self, source, target):
    &quot;&quot;&quot;Tell if the target is newer than the source.

    Returns true if &#39;source&#39; exists and is more recently modified than
    &#39;target&#39;, or if &#39;source&#39; exists and &#39;target&#39; doesn&#39;t.

    Returns false if both exist and &#39;target&#39; is the same age or younger
    than &#39;source&#39;. Raise PackagingFileError if &#39;source&#39; does not exist.

    Note that this test is not very accurate: files created in the same
    second will have the same &quot;age&quot;.
    &quot;&quot;&quot;
    if not os.path.exists(source):
        raise DistlibException(&quot;file &#39;%r&#39; does not exist&quot; % os.path.abspath(source))
    if not os.path.exists(target):
        return True

    return os.stat(source).st_mtime &gt; os.stat(target).st_mtime

def copy_file(self, infile, outfile, check=True):
    &quot;&quot;&quot;Copy a file respecting dry-run and force flags.
    &quot;&quot;&quot;
    self.ensure_dir(os.path.dirname(outfile))
    logger.info(&#39;Copying %s to %s&#39;, infile, outfile)
    if not self.dry_run:
        msg = None
        if check:
            if os.path.islink(outfile):
                msg = &#39;%s is a symlink&#39; % outfile
            elif os.path.exists(outfile) and not os.path.isfile(outfile):
                msg = &#39;%s is a non-regular file&#39; % outfile
        if msg:
            raise ValueError(msg + &#39; which would be overwritten&#39;)
        shutil.copyfile(infile, outfile)
    self.record_as_written(outfile)

def copy_stream(self, instream, outfile, encoding=None):
    assert not os.path.isdir(outfile)
    self.ensure_dir(os.path.dirname(outfile))
    logger.info(&#39;Copying stream %s to %s&#39;, instream, outfile)
    if not self.dry_run:
        if encoding is None:
            outstream = open(outfile, &#39;wb&#39;)
        else:
            outstream = codecs.open(outfile, &#39;w&#39;, encoding=encoding)
        try:
            shutil.copyfileobj(instream, outstream)
        finally:
            outstream.close()
    self.record_as_written(outfile)

def write_binary_file(self, path, data):
    self.ensure_dir(os.path.dirname(path))
    if not self.dry_run:
        if os.path.exists(path):
            os.remove(path)
        with open(path, &#39;wb&#39;) as f:
            f.write(data)
    self.record_as_written(path)

def write_text_file(self, path, data, encoding):
    self.write_binary_file(path, data.encode(encoding))

def set_mode(self, bits, mask, files):
    if os.name == &#39;posix&#39; or (os.name == &#39;java&#39; and os._name == &#39;posix&#39;):
        # Set the executable bits (owner, group, and world) on
        # all the files specified.
        for f in files:
            if self.dry_run:
                logger.info(&quot;changing mode of %s&quot;, f)
            else:
                mode = (os.stat(f).st_mode | bits) &amp; mask
                logger.info(&quot;changing mode of %s to %o&quot;, f, mode)
                os.chmod(f, mode)

set_executable_mode = lambda s, f: s.set_mode(0o555, 0o7777, f)

def ensure_dir(self, path):
    path = os.path.abspath(path)
    if path not in self.ensured and not os.path.exists(path):
        self.ensured.add(path)
        d, f = os.path.split(path)
        self.ensure_dir(d)
        logger.info(&#39;Creating %s&#39; % path)
        if not self.dry_run:
            os.mkdir(path)
        if self.record:
            self.dirs_created.add(path)

def byte_compile(self, path, optimize=False, force=False, prefix=None, hashed_invalidation=False):
    dpath = cache_from_source(path, not optimize)
    logger.info(&#39;Byte-compiling %s to %s&#39;, path, dpath)
    if not self.dry_run:
        if force or self.newer(path, dpath):
            if not prefix:
                diagpath = None
            else:
                assert path.startswith(prefix)
                diagpath = path[len(prefix):]
        compile_kwargs = {}
        if hashed_invalidation and hasattr(py_compile, &#39;PycInvalidationMode&#39;):
            if not isinstance(hashed_invalidation, py_compile.PycInvalidationMode):
                hashed_invalidation = py_compile.PycInvalidationMode.CHECKED_HASH
            compile_kwargs[&#39;invalidation_mode&#39;] = hashed_invalidation
        py_compile.compile(path, dpath, diagpath, True, **compile_kwargs)  # raise error
    self.record_as_written(dpath)
    return dpath

def ensure_removed(self, path):
    if os.path.exists(path):
        if os.path.isdir(path) and not os.path.islink(path):
            logger.debug(&#39;Removing directory tree at %s&#39;, path)
            if not self.dry_run:
                shutil.rmtree(path)
            if self.record:
                if path in self.dirs_created:
                    self.dirs_created.remove(path)
        else:
            if os.path.islink(path):
                s = &#39;link&#39;
            else:
                s = &#39;file&#39;
            logger.debug(&#39;Removing %s %s&#39;, s, path)
            if not self.dry_run:
                os.remove(path)
            if self.record:
                if path in self.files_written:
                    self.files_written.remove(path)

def is_writable(self, path):
    result = False
    while not result:
        if os.path.exists(path):
            result = os.access(path, os.W_OK)
            break
        parent = os.path.dirname(path)
        if parent == path:
            break
        path = parent
    return result

def commit(self):
    &quot;&quot;&quot;
    Commit recorded changes, turn off recording, return
    changes.
    &quot;&quot;&quot;
    assert self.record
    result = self.files_written, self.dirs_created
    self._init_record()
    return result

def rollback(self):
    if not self.dry_run:
        for f in list(self.files_written):
            if os.path.exists(f):
                os.remove(f)
        # dirs should all be empty now, except perhaps for
        # __pycache__ subdirs
        # reverse so that subdirs appear before their parents
        dirs = sorted(self.dirs_created, reverse=True)
        for d in dirs:
            flist = os.listdir(d)
            if flist:
                assert flist == [&#39;__pycache__&#39;]
                sd = os.path.join(d, flist[0])
                os.rmdir(sd)
            os.rmdir(d)  # should fail if non-empty
    self._init_record()
</pre></div>
</div>
<p>def resolve(module_name, dotted_path):
if module_name in sys.modules:
mod = sys.modules[module_name]
else:
mod = <strong>import</strong>(module_name)
if dotted_path is None:
result = mod
else:
parts = dotted_path.split(‘.’)
result = getattr(mod, parts.pop(0))
for p in parts:
result = getattr(result, p)
return result</p>
<p>class ExportEntry(object):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, name, prefix, suffix, flags):
    self.name = name
    self.prefix = prefix
    self.suffix = suffix
    self.flags = flags

@cached_property
def value(self):
    return resolve(self.prefix, self.suffix)

def __repr__(self):  # pragma: no cover
    return &#39;&lt;ExportEntry %s = %s:%s %s&gt;&#39; % (self.name, self.prefix, self.suffix, self.flags)

def __eq__(self, other):
    if not isinstance(other, ExportEntry):
        result = False
    else:
        result = (self.name == other.name and self.prefix == other.prefix and self.suffix == other.suffix and
                  self.flags == other.flags)
    return result

__hash__ = object.__hash__
</pre></div>
</div>
<p>ENTRY_RE = re.compile(
r’’’(?P<name>(<a href="#id33"><span class="problematic" id="id5">[^\[]</span></a>\S*))
\s*=\s*(?P<callable>(\w+)([:.]\w+)<em>)
\s</em>([\s*(?P<flags>[\w-]+(=\w+)?(,\s*\w+(=\w+)?)<em>)\s</em>])?
‘’’, re.VERBOSE)</p>
<p>def get_export_entry(specification):
m = ENTRY_RE.search(specification)
if not m:
result = None
if ‘[’ in specification or ‘]’ in specification:
raise DistlibException(“Invalid specification “
“’%s’” % specification)
else:
d = m.groupdict()
name = d[‘name’]
path = d[‘callable’]
colons = path.count(‘:’)
if colons == 0:
prefix, suffix = path, None
else:
if colons != 1:
raise DistlibException(“Invalid specification “
“’%s’” % specification)
prefix, suffix = path.split(‘:’)
flags = d[‘flags’]
if flags is None:
if ‘[’ in specification or ‘]’ in specification:
raise DistlibException(“Invalid specification “
“’%s’” % specification)
flags = []
else:
flags = [f.strip() for f in flags.split(‘,’)]
result = ExportEntry(name, prefix, suffix, flags)
return result</p>
<p>def get_cache_base(suffix=None):
“””
Return the default base location for distlib caches. If the directory does
not exist, it is created. Use the suffix provided for the base directory,
and default to ‘.distlib’ if it isn’t provided.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>On Windows, if LOCALAPPDATA is defined in the environment, then it is
assumed to be a directory, and will be the parent directory of the result.
On POSIX, and on Windows if LOCALAPPDATA is not defined, the user&#39;s home
directory - using os.expanduser(&#39;~&#39;) - will be the parent directory of
the result.

The result is just the directory &#39;.distlib&#39; in the parent directory as
determined above, or with the name specified with ``suffix``.
&quot;&quot;&quot;
if suffix is None:
    suffix = &#39;.distlib&#39;
if os.name == &#39;nt&#39; and &#39;LOCALAPPDATA&#39; in os.environ:
    result = os.path.expandvars(&#39;$localappdata&#39;)
else:
    # Assume posix, or old Windows
    result = os.path.expanduser(&#39;~&#39;)
# we use &#39;isdir&#39; instead of &#39;exists&#39;, because we want to
# fail if there&#39;s a file with that name
if os.path.isdir(result):
    usable = os.access(result, os.W_OK)
    if not usable:
        logger.warning(&#39;Directory exists but is not writable: %s&#39;, result)
else:
    try:
        os.makedirs(result)
        usable = True
    except OSError:
        logger.warning(&#39;Unable to create %s&#39;, result, exc_info=True)
        usable = False
if not usable:
    result = tempfile.mkdtemp()
    logger.warning(&#39;Default location unusable, using %s&#39;, result)
return os.path.join(result, suffix)
</pre></div>
</div>
<p>def path_to_cache_dir(path, use_abspath=True):
“””
Convert an absolute path to a directory name for use in a cache.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The algorithm used is:

#. On Windows, any ``&#39;:&#39;`` in the drive is replaced with ``&#39;---&#39;``.
#. Any occurrence of ``os.sep`` is replaced with ``&#39;--&#39;``.
#. ``&#39;.cache&#39;`` is appended.
&quot;&quot;&quot;
d, p = os.path.splitdrive(os.path.abspath(path) if use_abspath else path)
if d:
    d = d.replace(&#39;:&#39;, &#39;---&#39;)
p = p.replace(os.sep, &#39;--&#39;)
return d + p + &#39;.cache&#39;
</pre></div>
</div>
<p>def ensure_slash(s):
if not s.endswith(‘/’):
return s + ‘/’
return s</p>
<p>def parse_credentials(netloc):
username = password = None
if ‘&#64;’ in netloc:
prefix, netloc = netloc.rsplit(‘&#64;’, 1)
if ‘:’ not in prefix:
username = prefix
else:
username, password = prefix.split(‘:’, 1)
if username:
username = unquote(username)
if password:
password = unquote(password)
return username, password, netloc</p>
<p>def get_process_umask():
result = os.umask(0o22)
os.umask(result)
return result</p>
<p>def is_string_sequence(seq):
result = True
i = None
for i, s in enumerate(seq):
if not isinstance(s, string_types):
result = False
break
assert i is not None
return result</p>
<p>PROJECT_NAME_AND_VERSION = re.compile(‘([a-z0-9_]+([.-][a-z_][a-z0-9_]<em>)</em>)-’
‘([a-z0-9_.+-]+)’, re.I)
PYTHON_VERSION = re.compile(r’-py(\d.?\d?)’)</p>
<p>def split_filename(filename, project_name=None):
“””
Extract name, version, python version from a filename (no extension)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Return name, version, pyver or None
&quot;&quot;&quot;
result = None
pyver = None
filename = unquote(filename).replace(&#39; &#39;, &#39;-&#39;)
m = PYTHON_VERSION.search(filename)
if m:
    pyver = m.group(1)
    filename = filename[:m.start()]
if project_name and len(filename) &gt; len(project_name) + 1:
    m = re.match(re.escape(project_name) + r&#39;\b&#39;, filename)
    if m:
        n = m.end()
        result = filename[:n], filename[n + 1:], pyver
if result is None:
    m = PROJECT_NAME_AND_VERSION.match(filename)
    if m:
        result = m.group(1), m.group(3), pyver
return result
</pre></div>
</div>
</section>
<section id="allow-spaces-in-name-because-of-legacy-dists-like-twisted-core">
<h1>Allow spaces in name because of legacy dists like “Twisted Core”<a class="headerlink" href="#allow-spaces-in-name-because-of-legacy-dists-like-twisted-core" title="Link to this heading"></a></h1>
<p>NAME_VERSION_RE = re.compile(r’(?P<name>[\w .-]+)\s*’
r’(\s*(?P<ver><a href="#id34"><span class="problematic" id="id6">[^\s)]</span></a>+))$’)</p>
<p>def parse_name_and_version(p):
“””
A utility method used to get name and version from a string.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>From e.g. a Provides-Dist value.

:param p: A value in a form &#39;foo (1.0)&#39;
:return: The name and version as a tuple.
&quot;&quot;&quot;
m = NAME_VERSION_RE.match(p)
if not m:
    raise DistlibException(&#39;Ill-formed name/version string: \&#39;%s\&#39;&#39; % p)
d = m.groupdict()
return d[&#39;name&#39;].strip().lower(), d[&#39;ver&#39;]
</pre></div>
</div>
<p>def get_extras(requested, available):
result = set()
requested = set(requested or [])
available = set(available or [])
if ‘<em>’ in requested:
requested.remove(’</em>’)
result |= available
for r in requested:
if r == ‘-‘:
result.add(r)
elif r.startswith(‘-‘):
unwanted = r[1:]
if unwanted not in available:
logger.warning(‘undeclared extra: %s’ % unwanted)
if unwanted in result:
result.remove(unwanted)
else:
if r not in available:
logger.warning(‘undeclared extra: %s’ % r)
result.add(r)
return result</p>
</section>
<section id="id7">
<h1><a class="headerlink" href="#id7" title="Link to this heading"></a></h1>
</section>
<section id="extended-metadata-functionality">
<h1>Extended metadata functionality<a class="headerlink" href="#extended-metadata-functionality" title="Link to this heading"></a></h1>
</section>
<section id="id8">
<h1><a class="headerlink" href="#id8" title="Link to this heading"></a></h1>
<p>def _get_external_data(url):
result = {}
try:
# urlopen might fail if it runs into redirections,
# because of Python issue #13696. Fixed in locators
# using a custom redirect handler.
resp = urlopen(url)
headers = resp.info()
ct = headers.get(‘Content-Type’)
if not ct.startswith(‘application/json’):
logger.debug(‘Unexpected response for JSON request: %s’, ct)
else:
reader = codecs.getreader(‘utf-8’)(resp)
# data = reader.read().decode(‘utf-8’)
# result = json.loads(data)
result = json.load(reader)
except Exception as e:
logger.exception(‘Failed to get external data for %s: %s’, url, e)
return result</p>
<p>_external_data_base_url = ‘https://www.red-dove.com/pypi/projects/’</p>
<p>def get_project_data(name):
url = ‘%s/%s/project.json’ % (name[0].upper(), name)
url = urljoin(_external_data_base_url, url)
result = _get_external_data(url)
return result</p>
<p>def get_package_data(name, version):
url = ‘%s/%s/package-%s.json’ % (name[0].upper(), name, version)
url = urljoin(_external_data_base_url, url)
return _get_external_data(url)</p>
<p>class Cache(object):
“””
A class implementing a cache for resources that need to live in the file system
e.g. shared libraries. This class was moved from resources to here because it
could be used by other modules, e.g. the wheel module.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, base):
    &quot;&quot;&quot;
    Initialise an instance.

    :param base: The base directory where the cache should be located.
    &quot;&quot;&quot;
    # we use &#39;isdir&#39; instead of &#39;exists&#39;, because we want to
    # fail if there&#39;s a file with that name
    if not os.path.isdir(base):  # pragma: no cover
        os.makedirs(base)
    if (os.stat(base).st_mode &amp; 0o77) != 0:
        logger.warning(&#39;Directory \&#39;%s\&#39; is not private&#39;, base)
    self.base = os.path.abspath(os.path.normpath(base))

def prefix_to_dir(self, prefix, use_abspath=True):
    &quot;&quot;&quot;
    Converts a resource prefix to a directory name in the cache.
    &quot;&quot;&quot;
    return path_to_cache_dir(prefix, use_abspath=use_abspath)

def clear(self):
    &quot;&quot;&quot;
    Clear the cache.
    &quot;&quot;&quot;
    not_removed = []
    for fn in os.listdir(self.base):
        fn = os.path.join(self.base, fn)
        try:
            if os.path.islink(fn) or os.path.isfile(fn):
                os.remove(fn)
            elif os.path.isdir(fn):
                shutil.rmtree(fn)
        except Exception:
            not_removed.append(fn)
    return not_removed
</pre></div>
</div>
<p>class EventMixin(object):
“””
A very simple publish/subscribe system.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self):
    self._subscribers = {}

def add(self, event, subscriber, append=True):
    &quot;&quot;&quot;
    Add a subscriber for an event.

    :param event: The name of an event.
    :param subscriber: The subscriber to be added (and called when the
                       event is published).
    :param append: Whether to append or prepend the subscriber to an
                   existing subscriber list for the event.
    &quot;&quot;&quot;
    subs = self._subscribers
    if event not in subs:
        subs[event] = deque([subscriber])
    else:
        sq = subs[event]
        if append:
            sq.append(subscriber)
        else:
            sq.appendleft(subscriber)

def remove(self, event, subscriber):
    &quot;&quot;&quot;
    Remove a subscriber for an event.

    :param event: The name of an event.
    :param subscriber: The subscriber to be removed.
    &quot;&quot;&quot;
    subs = self._subscribers
    if event not in subs:
        raise ValueError(&#39;No subscribers: %r&#39; % event)
    subs[event].remove(subscriber)

def get_subscribers(self, event):
    &quot;&quot;&quot;
    Return an iterator for the subscribers for an event.
    :param event: The event to return subscribers for.
    &quot;&quot;&quot;
    return iter(self._subscribers.get(event, ()))

def publish(self, event, *args, **kwargs):
    &quot;&quot;&quot;
    Publish a event and return a list of values returned by its
    subscribers.

    :param event: The event to publish.
    :param args: The positional arguments to pass to the event&#39;s
                 subscribers.
    :param kwargs: The keyword arguments to pass to the event&#39;s
                   subscribers.
    &quot;&quot;&quot;
    result = []
    for subscriber in self.get_subscribers(event):
        try:
            value = subscriber(event, *args, **kwargs)
        except Exception:
            logger.exception(&#39;Exception during event publication&#39;)
            value = None
        result.append(value)
    logger.debug(&#39;publish %s: args = %s, kwargs = %s, result = %s&#39;, event, args, kwargs, result)
    return result
</pre></div>
</div>
</section>
<section id="id9">
<h1><a class="headerlink" href="#id9" title="Link to this heading"></a></h1>
</section>
<section id="simple-sequencing">
<h1>Simple sequencing<a class="headerlink" href="#simple-sequencing" title="Link to this heading"></a></h1>
</section>
<section id="id10">
<h1><a class="headerlink" href="#id10" title="Link to this heading"></a></h1>
<p>class Sequencer(object):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self):
    self._preds = {}
    self._succs = {}
    self._nodes = set()  # nodes with no preds/succs

def add_node(self, node):
    self._nodes.add(node)

def remove_node(self, node, edges=False):
    if node in self._nodes:
        self._nodes.remove(node)
    if edges:
        for p in set(self._preds.get(node, ())):
            self.remove(p, node)
        for s in set(self._succs.get(node, ())):
            self.remove(node, s)
        # Remove empties
        for k, v in list(self._preds.items()):
            if not v:
                del self._preds[k]
        for k, v in list(self._succs.items()):
            if not v:
                del self._succs[k]

def add(self, pred, succ):
    assert pred != succ
    self._preds.setdefault(succ, set()).add(pred)
    self._succs.setdefault(pred, set()).add(succ)

def remove(self, pred, succ):
    assert pred != succ
    try:
        preds = self._preds[succ]
        succs = self._succs[pred]
    except KeyError:  # pragma: no cover
        raise ValueError(&#39;%r not a successor of anything&#39; % succ)
    try:
        preds.remove(pred)
        succs.remove(succ)
    except KeyError:  # pragma: no cover
        raise ValueError(&#39;%r not a successor of %r&#39; % (succ, pred))

def is_step(self, step):
    return (step in self._preds or step in self._succs or step in self._nodes)

def get_steps(self, final):
    if not self.is_step(final):
        raise ValueError(&#39;Unknown: %r&#39; % final)
    result = []
    todo = []
    seen = set()
    todo.append(final)
    while todo:
        step = todo.pop(0)
        if step in seen:
            # if a step was already seen,
            # move it to the end (so it will appear earlier
            # when reversed on return) ... but not for the
            # final step, as that would be confusing for
            # users
            if step != final:
                result.remove(step)
                result.append(step)
        else:
            seen.add(step)
            result.append(step)
            preds = self._preds.get(step, ())
            todo.extend(preds)
    return reversed(result)

@property
def strong_connections(self):
    # http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
    index_counter = [0]
    stack = []
    lowlinks = {}
    index = {}
    result = []

    graph = self._succs

    def strongconnect(node):
        # set the depth index for this node to the smallest unused index
        index[node] = index_counter[0]
        lowlinks[node] = index_counter[0]
        index_counter[0] += 1
        stack.append(node)

        # Consider successors
        try:
            successors = graph[node]
        except Exception:
            successors = []
        for successor in successors:
            if successor not in lowlinks:
                # Successor has not yet been visited
                strongconnect(successor)
                lowlinks[node] = min(lowlinks[node], lowlinks[successor])
            elif successor in stack:
                # the successor is in the stack and hence in the current
                # strongly connected component (SCC)
                lowlinks[node] = min(lowlinks[node], index[successor])

        # If `node` is a root node, pop the stack and generate an SCC
        if lowlinks[node] == index[node]:
            connected_component = []

            while True:
                successor = stack.pop()
                connected_component.append(successor)
                if successor == node:
                    break
            component = tuple(connected_component)
            # storing the result
            result.append(component)

    for node in graph:
        if node not in lowlinks:
            strongconnect(node)

    return result

@property
def dot(self):
    result = [&#39;digraph G {&#39;]
    for succ in self._preds:
        preds = self._preds[succ]
        for pred in preds:
            result.append(&#39;  %s -&gt; %s;&#39; % (pred, succ))
    for node in self._nodes:
        result.append(&#39;  %s;&#39; % node)
    result.append(&#39;}&#39;)
    return &#39;\n&#39;.join(result)
</pre></div>
</div>
</section>
<section id="id11">
<h1><a class="headerlink" href="#id11" title="Link to this heading"></a></h1>
</section>
<section id="unarchiving-functionality-for-zip-tar-tgz-tbz-whl">
<h1>Unarchiving functionality for zip, tar, tgz, tbz, whl<a class="headerlink" href="#unarchiving-functionality-for-zip-tar-tgz-tbz-whl" title="Link to this heading"></a></h1>
</section>
<section id="id12">
<h1><a class="headerlink" href="#id12" title="Link to this heading"></a></h1>
<p>ARCHIVE_EXTENSIONS = (‘.tar.gz’, ‘.tar.bz2’, ‘.tar’, ‘.zip’, ‘.tgz’, ‘.tbz’, ‘.whl’)</p>
<p>def unarchive(archive_filename, dest_dir, format=None, check=True):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def check_path(path):
    if not isinstance(path, text_type):
        path = path.decode(&#39;utf-8&#39;)
    p = os.path.abspath(os.path.join(dest_dir, path))
    if not p.startswith(dest_dir) or p[plen] != os.sep:
        raise ValueError(&#39;path outside destination: %r&#39; % p)

dest_dir = os.path.abspath(dest_dir)
plen = len(dest_dir)
archive = None
if format is None:
    if archive_filename.endswith((&#39;.zip&#39;, &#39;.whl&#39;)):
        format = &#39;zip&#39;
    elif archive_filename.endswith((&#39;.tar.gz&#39;, &#39;.tgz&#39;)):
        format = &#39;tgz&#39;
        mode = &#39;r:gz&#39;
    elif archive_filename.endswith((&#39;.tar.bz2&#39;, &#39;.tbz&#39;)):
        format = &#39;tbz&#39;
        mode = &#39;r:bz2&#39;
    elif archive_filename.endswith(&#39;.tar&#39;):
        format = &#39;tar&#39;
        mode = &#39;r&#39;
    else:  # pragma: no cover
        raise ValueError(&#39;Unknown format for %r&#39; % archive_filename)
try:
    if format == &#39;zip&#39;:
        archive = ZipFile(archive_filename, &#39;r&#39;)
        if check:
            names = archive.namelist()
            for name in names:
                check_path(name)
    else:
        archive = tarfile.open(archive_filename, mode)
        if check:
            names = archive.getnames()
            for name in names:
                check_path(name)
    if format != &#39;zip&#39; and sys.version_info[0] &lt; 3:
        # See Python issue 17153. If the dest path contains Unicode,
        # tarfile extraction fails on Python 2.x if a member path name
        # contains non-ASCII characters - it leads to an implicit
        # bytes -&gt; unicode conversion using ASCII to decode.
        for tarinfo in archive.getmembers():
            if not isinstance(tarinfo.name, text_type):
                tarinfo.name = tarinfo.name.decode(&#39;utf-8&#39;)

    # Limit extraction of dangerous items, if this Python
    # allows it easily. If not, just trust the input.
    # See: https://docs.python.org/3/library/tarfile.html#extraction-filters
    def extraction_filter(member, path):
        &quot;&quot;&quot;Run tarfile.tar_filter, but raise the expected ValueError&quot;&quot;&quot;
        # This is only called if the current Python has tarfile filters
        try:
            return tarfile.tar_filter(member, path)
        except tarfile.FilterError as exc:
            raise ValueError(str(exc))

    archive.extraction_filter = extraction_filter

    archive.extractall(dest_dir)

finally:
    if archive:
        archive.close()
</pre></div>
</div>
<p>def zip_dir(directory):
“””zip a directory tree into a BytesIO object”””
result = io.BytesIO()
dlen = len(directory)
with ZipFile(result, “w”) as zf:
for root, dirs, files in os.walk(directory):
for name in files:
full = os.path.join(root, name)
rel = root[dlen:]
dest = os.path.join(rel, name)
zf.write(full, dest)
return result</p>
</section>
<section id="id13">
<h1><a class="headerlink" href="#id13" title="Link to this heading"></a></h1>
</section>
<section id="simple-progress-bar">
<h1>Simple progress bar<a class="headerlink" href="#simple-progress-bar" title="Link to this heading"></a></h1>
</section>
<section id="id14">
<h1><a class="headerlink" href="#id14" title="Link to this heading"></a></h1>
<p>UNITS = (‘’, ‘K’, ‘M’, ‘G’, ‘T’, ‘P’)</p>
<p>class Progress(object):
unknown = ‘UNKNOWN’</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, minval=0, maxval=100):
    assert maxval is None or maxval &gt;= minval
    self.min = self.cur = minval
    self.max = maxval
    self.started = None
    self.elapsed = 0
    self.done = False

def update(self, curval):
    assert self.min &lt;= curval
    assert self.max is None or curval &lt;= self.max
    self.cur = curval
    now = time.time()
    if self.started is None:
        self.started = now
    else:
        self.elapsed = now - self.started

def increment(self, incr):
    assert incr &gt;= 0
    self.update(self.cur + incr)

def start(self):
    self.update(self.min)
    return self

def stop(self):
    if self.max is not None:
        self.update(self.max)
    self.done = True

@property
def maximum(self):
    return self.unknown if self.max is None else self.max

@property
def percentage(self):
    if self.done:
        result = &#39;100 %&#39;
    elif self.max is None:
        result = &#39; ?? %&#39;
    else:
        v = 100.0 * (self.cur - self.min) / (self.max - self.min)
        result = &#39;%3d %%&#39; % v
    return result

def format_duration(self, duration):
    if (duration &lt;= 0) and self.max is None or self.cur == self.min:
        result = &#39;??:??:??&#39;
    # elif duration &lt; 1:
    #     result = &#39;--:--:--&#39;
    else:
        result = time.strftime(&#39;%H:%M:%S&#39;, time.gmtime(duration))
    return result

@property
def ETA(self):
    if self.done:
        prefix = &#39;Done&#39;
        t = self.elapsed
        # import pdb; pdb.set_trace()
    else:
        prefix = &#39;ETA &#39;
        if self.max is None:
            t = -1
        elif self.elapsed == 0 or (self.cur == self.min):
            t = 0
        else:
            # import pdb; pdb.set_trace()
            t = float(self.max - self.min)
            t /= self.cur - self.min
            t = (t - 1) * self.elapsed
    return &#39;%s: %s&#39; % (prefix, self.format_duration(t))

@property
def speed(self):
    if self.elapsed == 0:
        result = 0.0
    else:
        result = (self.cur - self.min) / self.elapsed
    for unit in UNITS:
        if result &lt; 1000:
            break
        result /= 1000.0
    return &#39;%d %sB/s&#39; % (result, unit)
</pre></div>
</div>
</section>
<section id="id15">
<h1><a class="headerlink" href="#id15" title="Link to this heading"></a></h1>
</section>
<section id="glob-functionality">
<h1>Glob functionality<a class="headerlink" href="#glob-functionality" title="Link to this heading"></a></h1>
</section>
<section id="id16">
<h1><a class="headerlink" href="#id16" title="Link to this heading"></a></h1>
<p>RICH_GLOB = re.compile(r’{(<a href="#id35"><span class="problematic" id="id17">[^}]</span></a><em>)}’)
_CHECK_RECURSIVE_GLOB = re.compile(r’<a href="#id36"><span class="problematic" id="id18">[^/\\,{]</span></a>**|**<a href="#id37"><span class="problematic" id="id19">[^/\\,}]</span></a>’)
_CHECK_MISMATCH_SET = re.compile(r’^<a href="#id38"><span class="problematic" id="id20">[^{]</span></a></em>}|{<a href="#id39"><span class="problematic" id="id21">[^}]</span></a>*$’)</p>
<p>def iglob(path_glob):
“””Extended globbing function that supports ** and {opt1,opt2,opt3}.”””
if _CHECK_RECURSIVE_GLOB.search(path_glob):
msg = “””invalid glob %r: recursive glob “**” must be used alone”””
raise ValueError(msg % path_glob)
if _CHECK_MISMATCH_SET.search(path_glob):
msg = “””invalid glob %r: mismatching set marker ‘{’ or ‘}’”””
raise ValueError(msg % path_glob)
return _iglob(path_glob)</p>
<p>def _iglob(path_glob):
rich_path_glob = RICH_GLOB.split(path_glob, 1)
if len(rich_path_glob) &gt; 1:
assert len(rich_path_glob) == 3, rich_path_glob
prefix, set, suffix = rich_path_glob
for item in set.split(‘,’):
for path in _iglob(‘’.join((prefix, item, suffix))):
yield path
else:
if ‘<strong>’ not in path_glob:
for item in std_iglob(path_glob):
yield item
else:
prefix, radical = path_glob.split(’</strong>’, 1)
if prefix == ‘’:
prefix = ‘.’
if radical == ‘’:
radical = ‘*’
else:
# we support both
radical = radical.lstrip(‘/’)
radical = radical.lstrip(’')
for path, dir, files in os.walk(prefix):
path = os.path.normpath(path)
for fn in _iglob(os.path.join(path, radical)):
yield fn</p>
<p>if ssl:
from .compat import (HTTPSHandler as BaseHTTPSHandler, match_hostname, CertificateError)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#
# HTTPSConnection which verifies certificates/matches domains
#

class HTTPSConnection(httplib.HTTPSConnection):
    ca_certs = None  # set this to the path to the certs file (.pem)
    check_domain = True  # only used if ca_certs is not None

    # noinspection PyPropertyAccess
    def connect(self):
        sock = socket.create_connection((self.host, self.port), self.timeout)
        if getattr(self, &#39;_tunnel_host&#39;, False):
            self.sock = sock
            self._tunnel()

        context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        if hasattr(ssl, &#39;OP_NO_SSLv2&#39;):
            context.options |= ssl.OP_NO_SSLv2
        if getattr(self, &#39;cert_file&#39;, None):
            context.load_cert_chain(self.cert_file, self.key_file)
        kwargs = {}
        if self.ca_certs:
            context.verify_mode = ssl.CERT_REQUIRED
            context.load_verify_locations(cafile=self.ca_certs)
            if getattr(ssl, &#39;HAS_SNI&#39;, False):
                kwargs[&#39;server_hostname&#39;] = self.host

        self.sock = context.wrap_socket(sock, **kwargs)
        if self.ca_certs and self.check_domain:
            try:
                match_hostname(self.sock.getpeercert(), self.host)
                logger.debug(&#39;Host verified: %s&#39;, self.host)
            except CertificateError:  # pragma: no cover
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
                raise

class HTTPSHandler(BaseHTTPSHandler):

    def __init__(self, ca_certs, check_domain=True):
        BaseHTTPSHandler.__init__(self)
        self.ca_certs = ca_certs
        self.check_domain = check_domain

    def _conn_maker(self, *args, **kwargs):
        &quot;&quot;&quot;
        This is called to create a connection instance. Normally you&#39;d
        pass a connection class to do_open, but it doesn&#39;t actually check for
        a class, and just expects a callable. As long as we behave just as a
        constructor would have, we should be OK. If it ever changes so that
        we *must* pass a class, we&#39;ll create an UnsafeHTTPSConnection class
        which just sets check_domain to False in the class definition, and
        choose which one to pass to do_open.
        &quot;&quot;&quot;
        result = HTTPSConnection(*args, **kwargs)
        if self.ca_certs:
            result.ca_certs = self.ca_certs
            result.check_domain = self.check_domain
        return result

    def https_open(self, req):
        try:
            return self.do_open(self._conn_maker, req)
        except URLError as e:
            if &#39;certificate verify failed&#39; in str(e.reason):
                raise CertificateError(&#39;Unable to verify server certificate &#39;
                                       &#39;for %s&#39; % req.host)
            else:
                raise

#
# To prevent against mixing HTTP traffic with HTTPS (examples: A Man-In-The-
# Middle proxy using HTTP listens on port 443, or an index mistakenly serves
# HTML containing a http://xyz link when it should be https://xyz),
# you can use the following handler class, which does not allow HTTP traffic.
#
# It works by inheriting from HTTPHandler - so build_opener won&#39;t add a
# handler for HTTP itself.
#
class HTTPSOnlyHandler(HTTPSHandler, HTTPHandler):

    def http_open(self, req):
        raise URLError(&#39;Unexpected HTTP request on what should be a secure &#39;
                       &#39;connection: %s&#39; % req)
</pre></div>
</div>
</section>
<section id="id22">
<h1><a class="headerlink" href="#id22" title="Link to this heading"></a></h1>
</section>
<section id="xml-rpc-with-timeouts">
<h1>XML-RPC with timeouts<a class="headerlink" href="#xml-rpc-with-timeouts" title="Link to this heading"></a></h1>
</section>
<section id="id23">
<h1><a class="headerlink" href="#id23" title="Link to this heading"></a></h1>
<p>class Transport(xmlrpclib.Transport):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, timeout, use_datetime=0):
    self.timeout = timeout
    xmlrpclib.Transport.__init__(self, use_datetime)

def make_connection(self, host):
    h, eh, x509 = self.get_host_info(host)
    if not self._connection or host != self._connection[0]:
        self._extra_headers = eh
        self._connection = host, httplib.HTTPConnection(h)
    return self._connection[1]
</pre></div>
</div>
<p>if ssl:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class SafeTransport(xmlrpclib.SafeTransport):

    def __init__(self, timeout, use_datetime=0):
        self.timeout = timeout
        xmlrpclib.SafeTransport.__init__(self, use_datetime)

    def make_connection(self, host):
        h, eh, kwargs = self.get_host_info(host)
        if not kwargs:
            kwargs = {}
        kwargs[&#39;timeout&#39;] = self.timeout
        if not self._connection or host != self._connection[0]:
            self._extra_headers = eh
            self._connection = host, httplib.HTTPSConnection(h, None, **kwargs)
        return self._connection[1]
</pre></div>
</div>
<p>class ServerProxy(xmlrpclib.ServerProxy):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, uri, **kwargs):
    self.timeout = timeout = kwargs.pop(&#39;timeout&#39;, None)
    # The above classes only come into play if a timeout
    # is specified
    if timeout is not None:
        # scheme = splittype(uri)  # deprecated as of Python 3.8
        scheme = urlparse(uri)[0]
        use_datetime = kwargs.get(&#39;use_datetime&#39;, 0)
        if scheme == &#39;https&#39;:
            tcls = SafeTransport
        else:
            tcls = Transport
        kwargs[&#39;transport&#39;] = t = tcls(timeout, use_datetime=use_datetime)
        self.transport = t
    xmlrpclib.ServerProxy.__init__(self, uri, **kwargs)
</pre></div>
</div>
</section>
<section id="id24">
<h1><a class="headerlink" href="#id24" title="Link to this heading"></a></h1>
</section>
<section id="csv-functionality-this-is-provided-because-on-2-x-the-csv-module-can-t">
<h1>CSV functionality. This is provided because on 2.x, the csv module can’t<a class="headerlink" href="#csv-functionality-this-is-provided-because-on-2-x-the-csv-module-can-t" title="Link to this heading"></a></h1>
</section>
<section id="handle-unicode-however-we-need-to-deal-with-unicode-in-e-g-record-files">
<h1>handle Unicode. However, we need to deal with Unicode in e.g. RECORD files.<a class="headerlink" href="#handle-unicode-however-we-need-to-deal-with-unicode-in-e-g-record-files" title="Link to this heading"></a></h1>
</section>
<section id="id25">
<h1><a class="headerlink" href="#id25" title="Link to this heading"></a></h1>
<p>def _csv_open(fn, mode, **kwargs):
if sys.version_info[0] &lt; 3:
mode += ‘b’
else:
kwargs[‘newline’] = ‘’
# Python 3 determines encoding from locale. Force ‘utf-8’
# file encoding to match other forced utf-8 encoding
kwargs[‘encoding’] = ‘utf-8’
return open(fn, mode, **kwargs)</p>
<p>class CSVBase(object):
defaults = {
‘delimiter’: str(‘,’),  # The strs are used because we need native
‘quotechar’: str(‘”’),  # str in the csv API (2.x won’t take
‘lineterminator’: str(‘\n’)  # Unicode)
}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __enter__(self):
    return self

def __exit__(self, *exc_info):
    self.stream.close()
</pre></div>
</div>
<p>class CSVReader(CSVBase):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, **kwargs):
    if &#39;stream&#39; in kwargs:
        stream = kwargs[&#39;stream&#39;]
        if sys.version_info[0] &gt;= 3:
            # needs to be a text stream
            stream = codecs.getreader(&#39;utf-8&#39;)(stream)
        self.stream = stream
    else:
        self.stream = _csv_open(kwargs[&#39;path&#39;], &#39;r&#39;)
    self.reader = csv.reader(self.stream, **self.defaults)

def __iter__(self):
    return self

def next(self):
    result = next(self.reader)
    if sys.version_info[0] &lt; 3:
        for i, item in enumerate(result):
            if not isinstance(item, text_type):
                result[i] = item.decode(&#39;utf-8&#39;)
    return result

__next__ = next
</pre></div>
</div>
<p>class CSVWriter(CSVBase):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, fn, **kwargs):
    self.stream = _csv_open(fn, &#39;w&#39;)
    self.writer = csv.writer(self.stream, **self.defaults)

def writerow(self, row):
    if sys.version_info[0] &lt; 3:
        r = []
        for item in row:
            if isinstance(item, text_type):
                item = item.encode(&#39;utf-8&#39;)
            r.append(item)
        row = r
    self.writer.writerow(row)
</pre></div>
</div>
</section>
<section id="id26">
<h1><a class="headerlink" href="#id26" title="Link to this heading"></a></h1>
</section>
<section id="configurator-functionality">
<h1>Configurator functionality<a class="headerlink" href="#configurator-functionality" title="Link to this heading"></a></h1>
</section>
<section id="id27">
<h1><a class="headerlink" href="#id27" title="Link to this heading"></a></h1>
<p>class Configurator(BaseConfigurator):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>value_converters = dict(BaseConfigurator.value_converters)
value_converters[&#39;inc&#39;] = &#39;inc_convert&#39;

def __init__(self, config, base=None):
    super(Configurator, self).__init__(config)
    self.base = base or os.getcwd()

def configure_custom(self, config):

    def convert(o):
        if isinstance(o, (list, tuple)):
            result = type(o)([convert(i) for i in o])
        elif isinstance(o, dict):
            if &#39;()&#39; in o:
                result = self.configure_custom(o)
            else:
                result = {}
                for k in o:
                    result[k] = convert(o[k])
        else:
            result = self.convert(o)
        return result

    c = config.pop(&#39;()&#39;)
    if not callable(c):
        c = self.resolve(c)
    props = config.pop(&#39;.&#39;, None)
    # Check for valid identifiers
    args = config.pop(&#39;[]&#39;, ())
    if args:
        args = tuple([convert(o) for o in args])
    items = [(k, convert(config[k])) for k in config if valid_ident(k)]
    kwargs = dict(items)
    result = c(*args, **kwargs)
    if props:
        for n, v in props.items():
            setattr(result, n, convert(v))
    return result

def __getitem__(self, key):
    result = self.config[key]
    if isinstance(result, dict) and &#39;()&#39; in result:
        self.config[key] = result = self.configure_custom(result)
    return result

def inc_convert(self, value):
    &quot;&quot;&quot;Default converter for the inc:// protocol.&quot;&quot;&quot;
    if not os.path.isabs(value):
        value = os.path.join(self.base, value)
    with codecs.open(value, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
        result = json.load(f)
    return result
</pre></div>
</div>
<p>class SubprocessMixin(object):
“””
Mixin for running subprocesses and capturing their output
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, verbose=False, progress=None):
    self.verbose = verbose
    self.progress = progress

def reader(self, stream, context):
    &quot;&quot;&quot;
    Read lines from a subprocess&#39; output stream and either pass to a progress
    callable (if specified) or write progress information to sys.stderr.
    &quot;&quot;&quot;
    progress = self.progress
    verbose = self.verbose
    while True:
        s = stream.readline()
        if not s:
            break
        if progress is not None:
            progress(s, context)
        else:
            if not verbose:
                sys.stderr.write(&#39;.&#39;)
            else:
                sys.stderr.write(s.decode(&#39;utf-8&#39;))
            sys.stderr.flush()
    stream.close()

def run_command(self, cmd, **kwargs):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)
    t1 = threading.Thread(target=self.reader, args=(p.stdout, &#39;stdout&#39;))
    t1.start()
    t2 = threading.Thread(target=self.reader, args=(p.stderr, &#39;stderr&#39;))
    t2.start()
    p.wait()
    t1.join()
    t2.join()
    if self.progress is not None:
        self.progress(&#39;done.&#39;, &#39;main&#39;)
    elif self.verbose:
        sys.stderr.write(&#39;done.\n&#39;)
    return p
</pre></div>
</div>
<p>def normalize_name(name):
“””Normalize a python package name a la PEP 503”””
# https://www.python.org/dev/peps/pep-0503/#normalized-names
return re.sub(‘[-_.]+’, ‘-’, name).lower()</p>
</section>
<section id="def-get-pypirc-command">
<h1>def _get_pypirc_command():<a class="headerlink" href="#def-get-pypirc-command" title="Link to this heading"></a></h1>
</section>
<section id="id28">
<h1>“””<a class="headerlink" href="#id28" title="Link to this heading"></a></h1>
</section>
<section id="get-the-distutils-command-for-interacting-with-pypi-configurations">
<h1>Get the distutils command for interacting with PyPI configurations.<a class="headerlink" href="#get-the-distutils-command-for-interacting-with-pypi-configurations" title="Link to this heading"></a></h1>
</section>
<section id="return-the-command">
<h1>:return: the command.<a class="headerlink" href="#return-the-command" title="Link to this heading"></a></h1>
</section>
<section id="id29">
<h1>“””<a class="headerlink" href="#id29" title="Link to this heading"></a></h1>
</section>
<section id="from-distutils-core-import-distribution">
<h1>from distutils.core import Distribution<a class="headerlink" href="#from-distutils-core-import-distribution" title="Link to this heading"></a></h1>
</section>
<section id="from-distutils-config-import-pypirccommand">
<h1>from distutils.config import PyPIRCCommand<a class="headerlink" href="#from-distutils-config-import-pypirccommand" title="Link to this heading"></a></h1>
</section>
<section id="d-distribution">
<h1>d = Distribution()<a class="headerlink" href="#d-distribution" title="Link to this heading"></a></h1>
</section>
<section id="return-pypirccommand-d">
<h1>return PyPIRCCommand(d)<a class="headerlink" href="#return-pypirccommand-d" title="Link to this heading"></a></h1>
<p>class PyPIRCFile(object):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>DEFAULT_REPOSITORY = &#39;https://upload.pypi.org/legacy/&#39;
DEFAULT_REALM = &#39;pypi&#39;

def __init__(self, fn=None, url=None):
    if fn is None:
        fn = os.path.join(os.path.expanduser(&#39;~&#39;), &#39;.pypirc&#39;)
    self.filename = fn
    self.url = url

def read(self):
    result = {}

    if os.path.exists(self.filename):
        repository = self.url or self.DEFAULT_REPOSITORY

        config = configparser.RawConfigParser()
        config.read(self.filename)
        sections = config.sections()
        if &#39;distutils&#39; in sections:
            # let&#39;s get the list of servers
            index_servers = config.get(&#39;distutils&#39;, &#39;index-servers&#39;)
            _servers = [server.strip() for server in index_servers.split(&#39;\n&#39;) if server.strip() != &#39;&#39;]
            if _servers == []:
                # nothing set, let&#39;s try to get the default pypi
                if &#39;pypi&#39; in sections:
                    _servers = [&#39;pypi&#39;]
            else:
                for server in _servers:
                    result = {&#39;server&#39;: server}
                    result[&#39;username&#39;] = config.get(server, &#39;username&#39;)

                    # optional params
                    for key, default in ((&#39;repository&#39;, self.DEFAULT_REPOSITORY), (&#39;realm&#39;, self.DEFAULT_REALM),
                                         (&#39;password&#39;, None)):
                        if config.has_option(server, key):
                            result[key] = config.get(server, key)
                        else:
                            result[key] = default

                    # work around people having &quot;repository&quot; for the &quot;pypi&quot;
                    # section of their config set to the HTTP (rather than
                    # HTTPS) URL
                    if (server == &#39;pypi&#39; and repository in (self.DEFAULT_REPOSITORY, &#39;pypi&#39;)):
                        result[&#39;repository&#39;] = self.DEFAULT_REPOSITORY
                    elif (result[&#39;server&#39;] != repository and result[&#39;repository&#39;] != repository):
                        result = {}
        elif &#39;server-login&#39; in sections:
            # old format
            server = &#39;server-login&#39;
            if config.has_option(server, &#39;repository&#39;):
                repository = config.get(server, &#39;repository&#39;)
            else:
                repository = self.DEFAULT_REPOSITORY
            result = {
                &#39;username&#39;: config.get(server, &#39;username&#39;),
                &#39;password&#39;: config.get(server, &#39;password&#39;),
                &#39;repository&#39;: repository,
                &#39;server&#39;: server,
                &#39;realm&#39;: self.DEFAULT_REALM
            }
    return result

def update(self, username, password):
    # import pdb; pdb.set_trace()
    config = configparser.RawConfigParser()
    fn = self.filename
    config.read(fn)
    if not config.has_section(&#39;pypi&#39;):
        config.add_section(&#39;pypi&#39;)
    config.set(&#39;pypi&#39;, &#39;username&#39;, username)
    config.set(&#39;pypi&#39;, &#39;password&#39;, password)
    with open(fn, &#39;w&#39;) as f:
        config.write(f)
</pre></div>
</div>
<p>def _load_pypirc(index):
“””
Read the PyPI access configuration as supported by distutils.
“””
return PyPIRCFile(url=index.url).read()</p>
<p>def _store_pypirc(index):
PyPIRCFile().update(index.username, index.password)</p>
</section>
<section id="id30">
<h1><a class="headerlink" href="#id30" title="Link to this heading"></a></h1>
</section>
<section id="get-platform-get-host-platform-copied-from-python-3-10-a0-source-with-some-minor">
<h1>get_platform()/get_host_platform() copied from Python 3.10.a0 source, with some minor<a class="headerlink" href="#get-platform-get-host-platform-copied-from-python-3-10-a0-source-with-some-minor" title="Link to this heading"></a></h1>
</section>
<section id="tweaks">
<h1>tweaks<a class="headerlink" href="#tweaks" title="Link to this heading"></a></h1>
</section>
<section id="id31">
<h1><a class="headerlink" href="#id31" title="Link to this heading"></a></h1>
<p>def get_host_platform():
“””Return a string that identifies the current platform.  This is used mainly to
distinguish platform-specific build directories and platform-specific built
distributions.  Typically includes the OS name and version and the
architecture (as supplied by ‘os.uname()’), although the exact information
included depends on the OS; eg. on Linux, the kernel version isn’t
particularly important.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Examples of returned values:
   linux-i586
   linux-alpha (?)
   solaris-2.6-sun4u

Windows will return one of:
   win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
   win32 (all others - specifically, sys.platform is returned)

For other non-POSIX platforms, currently just returns &#39;sys.platform&#39;.

&quot;&quot;&quot;
if os.name == &#39;nt&#39;:
    if &#39;amd64&#39; in sys.version.lower():
        return &#39;win-amd64&#39;
    if &#39;(arm)&#39; in sys.version.lower():
        return &#39;win-arm32&#39;
    if &#39;(arm64)&#39; in sys.version.lower():
        return &#39;win-arm64&#39;
    return sys.platform

# Set for cross builds explicitly
if &quot;_PYTHON_HOST_PLATFORM&quot; in os.environ:
    return os.environ[&quot;_PYTHON_HOST_PLATFORM&quot;]

if os.name != &#39;posix&#39; or not hasattr(os, &#39;uname&#39;):
    # XXX what about the architecture? NT is Intel or Alpha,
    # Mac OS is M68k or PPC, etc.
    return sys.platform

# Try to distinguish various flavours of Unix

(osname, host, release, version, machine) = os.uname()

# Convert the OS name to lowercase, remove &#39;/&#39; characters, and translate
# spaces (for &quot;Power Macintosh&quot;)
osname = osname.lower().replace(&#39;/&#39;, &#39;&#39;)
machine = machine.replace(&#39; &#39;, &#39;_&#39;).replace(&#39;/&#39;, &#39;-&#39;)

if osname[:5] == &#39;linux&#39;:
    # At least on Linux/Intel, &#39;machine&#39; is the processor --
    # i386, etc.
    # XXX what about Alpha, SPARC, etc?
    return &quot;%s-%s&quot; % (osname, machine)

elif osname[:5] == &#39;sunos&#39;:
    if release[0] &gt;= &#39;5&#39;:  # SunOS 5 == Solaris 2
        osname = &#39;solaris&#39;
        release = &#39;%d.%s&#39; % (int(release[0]) - 3, release[2:])
        # We can&#39;t use &#39;platform.architecture()[0]&#39; because a
        # bootstrap problem. We use a dict to get an error
        # if some suspicious happens.
        bitness = {2147483647: &#39;32bit&#39;, 9223372036854775807: &#39;64bit&#39;}
        machine += &#39;.%s&#39; % bitness[sys.maxsize]
    # fall through to standard osname-release-machine representation
elif osname[:3] == &#39;aix&#39;:
    from _aix_support import aix_platform
    return aix_platform()
elif osname[:6] == &#39;cygwin&#39;:
    osname = &#39;cygwin&#39;
    rel_re = re.compile(r&#39;[\d.]+&#39;, re.ASCII)
    m = rel_re.match(release)
    if m:
        release = m.group()
elif osname[:6] == &#39;darwin&#39;:
    import _osx_support
    try:
        from distutils import sysconfig
    except ImportError:
        import sysconfig
    osname, release, machine = _osx_support.get_platform_osx(sysconfig.get_config_vars(), osname, release, machine)

return &#39;%s-%s-%s&#39; % (osname, release, machine)
</pre></div>
</div>
<p>_TARGET_TO_PLAT = {
‘x86’: ‘win32’,
‘x64’: ‘win-amd64’,
‘arm’: ‘win-arm32’,
}</p>
<p>def get_platform():
if os.name != ‘nt’:
return get_host_platform()
cross_compilation_target = os.environ.get(‘VSCMD_ARG_TGT_ARCH’)
if cross_compilation_target not in _TARGET_TO_PLAT:
return get_host_platform()
return _TARGET_TO_PLAT[cross_compilation_target]</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>