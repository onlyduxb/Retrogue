

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/index/collector.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
The main purpose of this module is to expose LinkCollector.collect_sources().
“””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import collections
import email.message
import functools
import itertools
import json
import logging
import os
import urllib.parse
import urllib.request
from collections.abc import Iterable, MutableMapping, Sequence
from dataclasses import dataclass
from html.parser import HTMLParser
from optparse import Values
from typing import (
Callable,
NamedTuple,
Protocol,
)</p>
<p>from pip._vendor import requests
from pip._vendor.requests import Response
from pip._vendor.requests.exceptions import RetryError, SSLError</p>
<p>from pip._internal.exceptions import NetworkConnectionError
from pip._internal.models.link import Link
from pip._internal.models.search_scope import SearchScope
from pip._internal.network.session import PipSession
from pip._internal.network.utils import raise_for_status
from pip._internal.utils.filetypes import is_archive_file
from pip._internal.utils.misc import redact_auth_from_url
from pip._internal.vcs import vcs</p>
<p>from .sources import CandidatesFromPage, LinkSource, build_source</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>ResponseHeaders = MutableMapping[str, str]</p>
<p>def _match_vcs_scheme(url: str) -&gt; str | None:
“””Look for VCS schemes in the URL.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Returns the matched VCS scheme, or None if there&#39;s no match.
&quot;&quot;&quot;
for scheme in vcs.schemes:
    if url.lower().startswith(scheme) and url[len(scheme)] in &quot;+:&quot;:
        return scheme
return None
</pre></div>
</div>
<p>class _NotAPIContent(Exception):
def <strong>init</strong>(self, content_type: str, request_desc: str) -&gt; None:
super().<strong>init</strong>(content_type, request_desc)
self.content_type = content_type
self.request_desc = request_desc</p>
<p>def _ensure_api_header(response: Response) -&gt; None:
“””
Check the Content-Type header to ensure the response contains a Simple
API Response.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Raises `_NotAPIContent` if the content type is not a valid content-type.
&quot;&quot;&quot;
content_type = response.headers.get(&quot;Content-Type&quot;, &quot;Unknown&quot;)

content_type_l = content_type.lower()
if content_type_l.startswith(
    (
        &quot;text/html&quot;,
        &quot;application/vnd.pypi.simple.v1+html&quot;,
        &quot;application/vnd.pypi.simple.v1+json&quot;,
    )
):
    return

raise _NotAPIContent(content_type, response.request.method)
</pre></div>
</div>
<p>class _NotHTTP(Exception):
pass</p>
<p>def _ensure_api_response(url: str, session: PipSession) -&gt; None:
“””
Send a HEAD request to the URL, and ensure the response contains a simple
API Response.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Raises `_NotHTTP` if the URL is not available for a HEAD request, or
`_NotAPIContent` if the content type is not a valid content type.
&quot;&quot;&quot;
scheme, netloc, path, query, fragment = urllib.parse.urlsplit(url)
if scheme not in {&quot;http&quot;, &quot;https&quot;}:
    raise _NotHTTP()

resp = session.head(url, allow_redirects=True)
raise_for_status(resp)

_ensure_api_header(resp)
</pre></div>
</div>
<p>def _get_simple_response(url: str, session: PipSession) -&gt; Response:
“””Access an Simple API response with GET, and return the response.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This consists of three parts:

1. If the URL looks suspiciously like an archive, send a HEAD first to
   check the Content-Type is HTML or Simple API, to avoid downloading a
   large file. Raise `_NotHTTP` if the content type cannot be determined, or
   `_NotAPIContent` if it is not HTML or a Simple API.
2. Actually perform the request. Raise HTTP exceptions on network failures.
3. Check the Content-Type header to make sure we got a Simple API response,
   and raise `_NotAPIContent` otherwise.
&quot;&quot;&quot;
if is_archive_file(Link(url).filename):
    _ensure_api_response(url, session=session)

logger.debug(&quot;Getting page %s&quot;, redact_auth_from_url(url))

resp = session.get(
    url,
    headers={
        &quot;Accept&quot;: &quot;, &quot;.join(
            [
                &quot;application/vnd.pypi.simple.v1+json&quot;,
                &quot;application/vnd.pypi.simple.v1+html; q=0.1&quot;,
                &quot;text/html; q=0.01&quot;,
            ]
        ),
        # We don&#39;t want to blindly returned cached data for
        # /simple/, because authors generally expecting that
        # twine upload &amp;&amp; pip install will function, but if
        # they&#39;ve done a pip install in the last ~10 minutes
        # it won&#39;t. Thus by setting this to zero we will not
        # blindly use any cached data, however the benefit of
        # using max-age=0 instead of no-cache, is that we will
        # still support conditional requests, so we will still
        # minimize traffic sent in cases where the page hasn&#39;t
        # changed at all, we will just always incur the round
        # trip for the conditional GET now instead of only
        # once per 10 minutes.
        # For more information, please see pypa/pip#5670.
        &quot;Cache-Control&quot;: &quot;max-age=0&quot;,
    },
)
raise_for_status(resp)

# The check for archives above only works if the url ends with
# something that looks like an archive. However that is not a
# requirement of an url. Unless we issue a HEAD request on every
# url we cannot know ahead of time for sure if something is a
# Simple API response or not. However we can check after we&#39;ve
# downloaded it.
_ensure_api_header(resp)

logger.debug(
    &quot;Fetched page %s as %s&quot;,
    redact_auth_from_url(url),
    resp.headers.get(&quot;Content-Type&quot;, &quot;Unknown&quot;),
)

return resp
</pre></div>
</div>
<p>def _get_encoding_from_headers(headers: ResponseHeaders) -&gt; str | None:
“””Determine if we have any encoding information in our headers.”””
if headers and “Content-Type” in headers:
m = email.message.Message()
m[“content-type”] = headers[“Content-Type”]
charset = m.get_param(“charset”)
if charset:
return str(charset)
return None</p>
<p>class CacheablePageContent:
def <strong>init</strong>(self, page: IndexContent) -&gt; None:
assert page.cache_link_parsing
self.page = page</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __eq__(self, other: object) -&gt; bool:
    return isinstance(other, type(self)) and self.page.url == other.page.url

def __hash__(self) -&gt; int:
    return hash(self.page.url)
</pre></div>
</div>
<p>class ParseLinks(Protocol):
def <strong>call</strong>(self, page: IndexContent) -&gt; Iterable[Link]: …</p>
<p>def with_cached_index_content(fn: ParseLinks) -&gt; ParseLinks:
“””
Given a function that parses an Iterable[Link] from an IndexContent, cache the
function’s result (keyed by CacheablePageContent), unless the IndexContent
<code class="docutils literal notranslate"><span class="pre">page</span></code> has <code class="docutils literal notranslate"><span class="pre">page.cache_link_parsing</span> <span class="pre">==</span> <span class="pre">False</span></code>.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@functools.cache
def wrapper(cacheable_page: CacheablePageContent) -&gt; list[Link]:
    return list(fn(cacheable_page.page))

@functools.wraps(fn)
def wrapper_wrapper(page: IndexContent) -&gt; list[Link]:
    if page.cache_link_parsing:
        return wrapper(CacheablePageContent(page))
    return list(fn(page))

return wrapper_wrapper
</pre></div>
</div>
<p>&#64;with_cached_index_content
def parse_links(page: IndexContent) -&gt; Iterable[Link]:
“””
Parse a Simple API’s Index Content, and yield its anchor elements as Link objects.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>content_type_l = page.content_type.lower()
if content_type_l.startswith(&quot;application/vnd.pypi.simple.v1+json&quot;):
    data = json.loads(page.content)
    for file in data.get(&quot;files&quot;, []):
        link = Link.from_json(file, page.url)
        if link is None:
            continue
        yield link
    return

parser = HTMLLinkParser(page.url)
encoding = page.encoding or &quot;utf-8&quot;
parser.feed(page.content.decode(encoding))

url = page.url
base_url = parser.base_url or url
for anchor in parser.anchors:
    link = Link.from_element(anchor, page_url=url, base_url=base_url)
    if link is None:
        continue
    yield link
</pre></div>
</div>
<p>&#64;dataclass(frozen=True)
class IndexContent:
“””Represents one response (or page), along with its URL.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param encoding: the encoding to decode the given content.
:param url: the URL from which the HTML was downloaded.
:param cache_link_parsing: whether links parsed from this page&#39;s url
                           should be cached. PyPI index urls should
                           have this set to False, for example.
&quot;&quot;&quot;

content: bytes
content_type: str
encoding: str | None
url: str
cache_link_parsing: bool = True

def __str__(self) -&gt; str:
    return redact_auth_from_url(self.url)
</pre></div>
</div>
<p>class HTMLLinkParser(HTMLParser):
“””
HTMLParser that keeps the first base HREF and a list of all anchor
elements’ attributes.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, url: str) -&gt; None:
    super().__init__(convert_charrefs=True)

    self.url: str = url
    self.base_url: str | None = None
    self.anchors: list[dict[str, str | None]] = []

def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -&gt; None:
    if tag == &quot;base&quot; and self.base_url is None:
        href = self.get_href(attrs)
        if href is not None:
            self.base_url = href
    elif tag == &quot;a&quot;:
        self.anchors.append(dict(attrs))

def get_href(self, attrs: list[tuple[str, str | None]]) -&gt; str | None:
    for name, value in attrs:
        if name == &quot;href&quot;:
            return value
    return None
</pre></div>
</div>
<p>def _handle_get_simple_fail(
link: Link,
reason: str | Exception,
meth: Callable[…, None] | None = None,
) -&gt; None:
if meth is None:
meth = logger.debug
meth(“Could not fetch URL %s: %s - skipping”, link, reason)</p>
<p>def _make_index_content(
response: Response, cache_link_parsing: bool = True
) -&gt; IndexContent:
encoding = _get_encoding_from_headers(response.headers)
return IndexContent(
response.content,
response.headers[“Content-Type”],
encoding=encoding,
url=response.url,
cache_link_parsing=cache_link_parsing,
)</p>
<p>def _get_index_content(link: Link, *, session: PipSession) -&gt; IndexContent | None:
url = link.url.split(“#”, 1)[0]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Check for VCS schemes that do not support lookup as web pages.
vcs_scheme = _match_vcs_scheme(url)
if vcs_scheme:
    logger.warning(
        &quot;Cannot look at %s URL %s because it does not support lookup as web pages.&quot;,
        vcs_scheme,
        link,
    )
    return None

# Tack index.html onto file:// URLs that point to directories
scheme, _, path, _, _, _ = urllib.parse.urlparse(url)
if scheme == &quot;file&quot; and os.path.isdir(urllib.request.url2pathname(path)):
    # add trailing slash if not present so urljoin doesn&#39;t trim
    # final segment
    if not url.endswith(&quot;/&quot;):
        url += &quot;/&quot;
    # TODO: In the future, it would be nice if pip supported PEP 691
    #       style responses in the file:// URLs, however there&#39;s no
    #       standard file extension for application/vnd.pypi.simple.v1+json
    #       so we&#39;ll need to come up with something on our own.
    url = urllib.parse.urljoin(url, &quot;index.html&quot;)
    logger.debug(&quot; file: URL is directory, getting %s&quot;, url)

try:
    resp = _get_simple_response(url, session=session)
except _NotHTTP:
    logger.warning(
        &quot;Skipping page %s because it looks like an archive, and cannot &quot;
        &quot;be checked by a HTTP HEAD request.&quot;,
        link,
    )
except _NotAPIContent as exc:
    logger.warning(
        &quot;Skipping page %s because the %s request got Content-Type: %s. &quot;
        &quot;The only supported Content-Types are application/vnd.pypi.simple.v1+json, &quot;
        &quot;application/vnd.pypi.simple.v1+html, and text/html&quot;,
        link,
        exc.request_desc,
        exc.content_type,
    )
except NetworkConnectionError as exc:
    _handle_get_simple_fail(link, exc)
except RetryError as exc:
    _handle_get_simple_fail(link, exc)
except SSLError as exc:
    reason = &quot;There was a problem confirming the ssl certificate: &quot;
    reason += str(exc)
    _handle_get_simple_fail(link, reason, meth=logger.info)
except requests.ConnectionError as exc:
    _handle_get_simple_fail(link, f&quot;connection error: {exc}&quot;)
except requests.Timeout:
    _handle_get_simple_fail(link, &quot;timed out&quot;)
else:
    return _make_index_content(resp, cache_link_parsing=link.cache_link_parsing)
return None
</pre></div>
</div>
<p>class CollectedSources(NamedTuple):
find_links: Sequence[LinkSource | None]
index_urls: Sequence[LinkSource | None]</p>
<p>class LinkCollector:
“””
Responsible for collecting Link objects from all configured locations,
making network requests as needed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The class&#39;s main method is its collect_sources() method.
&quot;&quot;&quot;

def __init__(
    self,
    session: PipSession,
    search_scope: SearchScope,
) -&gt; None:
    self.search_scope = search_scope
    self.session = session

@classmethod
def create(
    cls,
    session: PipSession,
    options: Values,
    suppress_no_index: bool = False,
) -&gt; LinkCollector:
    &quot;&quot;&quot;
    :param session: The Session to use to make requests.
    :param suppress_no_index: Whether to ignore the --no-index option
        when constructing the SearchScope object.
    &quot;&quot;&quot;
    index_urls = [options.index_url] + options.extra_index_urls
    if options.no_index and not suppress_no_index:
        logger.debug(
            &quot;Ignoring indexes: %s&quot;,
            &quot;,&quot;.join(redact_auth_from_url(url) for url in index_urls),
        )
        index_urls = []

    # Make sure find_links is a list before passing to create().
    find_links = options.find_links or []

    search_scope = SearchScope.create(
        find_links=find_links,
        index_urls=index_urls,
        no_index=options.no_index,
    )
    link_collector = LinkCollector(
        session=session,
        search_scope=search_scope,
    )
    return link_collector

@property
def find_links(self) -&gt; list[str]:
    return self.search_scope.find_links

def fetch_response(self, location: Link) -&gt; IndexContent | None:
    &quot;&quot;&quot;
    Fetch an HTML page containing package links.
    &quot;&quot;&quot;
    return _get_index_content(location, session=self.session)

def collect_sources(
    self,
    project_name: str,
    candidates_from_page: CandidatesFromPage,
) -&gt; CollectedSources:
    # The OrderedDict calls deduplicate sources by URL.
    index_url_sources = collections.OrderedDict(
        build_source(
            loc,
            candidates_from_page=candidates_from_page,
            page_validator=self.session.is_secure_origin,
            expand_dir=False,
            cache_link_parsing=False,
            project_name=project_name,
        )
        for loc in self.search_scope.get_index_urls_locations(project_name)
    ).values()
    find_links_sources = collections.OrderedDict(
        build_source(
            loc,
            candidates_from_page=candidates_from_page,
            page_validator=self.session.is_secure_origin,
            expand_dir=True,
            cache_link_parsing=True,
            project_name=project_name,
        )
        for loc in self.find_links
    ).values()

    if logger.isEnabledFor(logging.DEBUG):
        lines = [
            f&quot;* {s.link}&quot;
            for s in itertools.chain(find_links_sources, index_url_sources)
            if s is not None and s.link is not None
        ]
        lines = [
            f&quot;{len(lines)} location(s) to search &quot;
            f&quot;for versions of {project_name}:&quot;
        ] + lines
        logger.debug(&quot;\n&quot;.join(lines))

    return CollectedSources(
        find_links=list(find_links_sources),
        index_urls=list(index_url_sources),
    )
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>