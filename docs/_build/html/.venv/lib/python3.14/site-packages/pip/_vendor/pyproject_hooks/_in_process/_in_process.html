

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>This file is run as a script, and import wrappers is not zip-safe, so we &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">This file is run as a script, and <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">wrappers</span></code> is not zip-safe, so we</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/pyproject_hooks/_in_process/_in_process.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””This is invoked in a subprocess to call the build backend hooks.</p>
<p>It expects:</p>
<ul class="simple">
<li><p>Command line args: hook_name, control_dir</p></li>
<li><p>Environment variables:
_PYPROJECT_HOOKS_BUILD_BACKEND=entry.point:spec
_PYPROJECT_HOOKS_BACKEND_PATH=paths (separated with os.pathsep)</p></li>
<li><p>control_dir/input.json:</p>
<ul>
<li><p>{“kwargs”: {…}}</p></li>
</ul>
</li>
</ul>
<p>Results:</p>
<ul class="simple">
<li><p>control_dir/output.json</p>
<ul>
<li><p>{“return_val”: …}
“””
import json
import os
import os.path
import re
import shutil
import sys
import traceback
from glob import glob
from importlib import import_module
from importlib.machinery import PathFinder
from os.path import join as pjoin</p></li>
</ul>
</li>
</ul>
<section id="this-file-is-run-as-a-script-and-import-wrappers-is-not-zip-safe-so-we">
<h1>This file is run as a script, and <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">wrappers</span></code> is not zip-safe, so we<a class="headerlink" href="#this-file-is-run-as-a-script-and-import-wrappers-is-not-zip-safe-so-we" title="Link to this heading"></a></h1>
</section>
<section id="include-write-json-and-read-json-from-wrappers-py">
<h1>include write_json() and read_json() from wrappers.py.<a class="headerlink" href="#include-write-json-and-read-json-from-wrappers-py" title="Link to this heading"></a></h1>
<p>def write_json(obj, path, **kwargs):
with open(path, “w”, encoding=”utf-8”) as f:
json.dump(obj, f, **kwargs)</p>
<p>def read_json(path):
with open(path, encoding=”utf-8”) as f:
return json.load(f)</p>
<p>class BackendUnavailable(Exception):
“””Raised if we cannot import the backend”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, message, traceback=None):
    super().__init__(message)
    self.message = message
    self.traceback = traceback
</pre></div>
</div>
<p>class HookMissing(Exception):
“””Raised if a hook is missing and we are not executing the fallback”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, hook_name=None):
    super().__init__(hook_name)
    self.hook_name = hook_name
</pre></div>
</div>
<p>def _build_backend():
“””Find and load the build backend”””
backend_path = os.environ.get(“_PYPROJECT_HOOKS_BACKEND_PATH”)
ep = os.environ[“_PYPROJECT_HOOKS_BUILD_BACKEND”]
mod_path, _, obj_path = ep.partition(“:”)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if backend_path:
    # Ensure in-tree backend directories have the highest priority when importing.
    extra_pathitems = backend_path.split(os.pathsep)
    sys.meta_path.insert(0, _BackendPathFinder(extra_pathitems, mod_path))

try:
    obj = import_module(mod_path)
except ImportError:
    msg = f&quot;Cannot import {mod_path!r}&quot;
    raise BackendUnavailable(msg, traceback.format_exc())

if obj_path:
    for path_part in obj_path.split(&quot;.&quot;):
        obj = getattr(obj, path_part)
return obj
</pre></div>
</div>
<p>class _BackendPathFinder:
“””Implements the MetaPathFinder interface to locate modules in <code class="docutils literal notranslate"><span class="pre">backend-path</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Since the environment provided by the frontend can contain all sorts of
MetaPathFinders, the only way to ensure the backend is loaded from the
right place is to prepend our own.
&quot;&quot;&quot;

def __init__(self, backend_path, backend_module):
    self.backend_path = backend_path
    self.backend_module = backend_module
    self.backend_parent, _, _ = backend_module.partition(&quot;.&quot;)

def find_spec(self, fullname, _path, _target=None):
    if &quot;.&quot; in fullname:
        # Rely on importlib to find nested modules based on parent&#39;s path
        return None

    # Ignore other items in _path or sys.path and use backend_path instead:
    spec = PathFinder.find_spec(fullname, path=self.backend_path)
    if spec is None and fullname == self.backend_parent:
        # According to the spec, the backend MUST be loaded from backend-path.
        # Therefore, we can halt the import machinery and raise a clean error.
        msg = f&quot;Cannot find module {self.backend_module!r} in {self.backend_path!r}&quot;
        raise BackendUnavailable(msg)

    return spec

if sys.version_info &gt;= (3, 8):

    def find_distributions(self, context=None):
        # Delayed import: Python 3.7 does not contain importlib.metadata
        from importlib.metadata import DistributionFinder, MetadataPathFinder

        context = DistributionFinder.Context(path=self.backend_path)
        return MetadataPathFinder.find_distributions(context=context)
</pre></div>
</div>
<p>def _supported_features():
“””Return the list of options features supported by the backend.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Returns a list of strings.
The only possible value is &#39;build_editable&#39;.
&quot;&quot;&quot;
backend = _build_backend()
features = []
if hasattr(backend, &quot;build_editable&quot;):
    features.append(&quot;build_editable&quot;)
return features
</pre></div>
</div>
<p>def get_requires_for_build_wheel(config_settings):
“””Invoke the optional get_requires_for_build_wheel hook</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Returns [] if the hook is not defined.
&quot;&quot;&quot;
backend = _build_backend()
try:
    hook = backend.get_requires_for_build_wheel
except AttributeError:
    return []
else:
    return hook(config_settings)
</pre></div>
</div>
<p>def get_requires_for_build_editable(config_settings):
“””Invoke the optional get_requires_for_build_editable hook</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Returns [] if the hook is not defined.
&quot;&quot;&quot;
backend = _build_backend()
try:
    hook = backend.get_requires_for_build_editable
except AttributeError:
    return []
else:
    return hook(config_settings)
</pre></div>
</div>
<p>def prepare_metadata_for_build_wheel(
metadata_directory, config_settings, _allow_fallback
):
“””Invoke optional prepare_metadata_for_build_wheel</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Implements a fallback by building a wheel if the hook isn&#39;t defined,
unless _allow_fallback is False in which case HookMissing is raised.
&quot;&quot;&quot;
backend = _build_backend()
try:
    hook = backend.prepare_metadata_for_build_wheel
except AttributeError:
    if not _allow_fallback:
        raise HookMissing()
else:
    return hook(metadata_directory, config_settings)
# fallback to build_wheel outside the try block to avoid exception chaining
# which can be confusing to users and is not relevant
whl_basename = backend.build_wheel(metadata_directory, config_settings)
return _get_wheel_metadata_from_wheel(
    whl_basename, metadata_directory, config_settings
)
</pre></div>
</div>
<p>def prepare_metadata_for_build_editable(
metadata_directory, config_settings, _allow_fallback
):
“””Invoke optional prepare_metadata_for_build_editable</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Implements a fallback by building an editable wheel if the hook isn&#39;t
defined, unless _allow_fallback is False in which case HookMissing is
raised.
&quot;&quot;&quot;
backend = _build_backend()
try:
    hook = backend.prepare_metadata_for_build_editable
except AttributeError:
    if not _allow_fallback:
        raise HookMissing()
    try:
        build_hook = backend.build_editable
    except AttributeError:
        raise HookMissing(hook_name=&quot;build_editable&quot;)
    else:
        whl_basename = build_hook(metadata_directory, config_settings)
        return _get_wheel_metadata_from_wheel(
            whl_basename, metadata_directory, config_settings
        )
else:
    return hook(metadata_directory, config_settings)
</pre></div>
</div>
<p>WHEEL_BUILT_MARKER = “PYPROJECT_HOOKS_ALREADY_BUILT_WHEEL”</p>
<p>def _dist_info_files(whl_zip):
“””Identify the .dist-info folder inside a wheel ZipFile.”””
res = []
for path in whl_zip.namelist():
m = re.match(r”<a href="#id4"><span class="problematic" id="id1">[^/\\]</span></a>+-<a href="#id5"><span class="problematic" id="id2">[^/\\]</span></a>+.dist-info/”, path)
if m:
res.append(path)
if res:
return res
raise Exception(“No .dist-info folder found in wheel”)</p>
<p>def _get_wheel_metadata_from_wheel(whl_basename, metadata_directory, config_settings):
“””Extract the metadata from a wheel.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Fallback for when the build backend does not
define the &#39;get_wheel_metadata&#39; hook.
&quot;&quot;&quot;
from zipfile import ZipFile

with open(os.path.join(metadata_directory, WHEEL_BUILT_MARKER), &quot;wb&quot;):
    pass  # Touch marker file

whl_file = os.path.join(metadata_directory, whl_basename)
with ZipFile(whl_file) as zipf:
    dist_info = _dist_info_files(zipf)
    zipf.extractall(path=metadata_directory, members=dist_info)
return dist_info[0].split(&quot;/&quot;)[0]
</pre></div>
</div>
<p>def _find_already_built_wheel(metadata_directory):
“””Check for a wheel already built during the get_wheel_metadata hook.”””
if not metadata_directory:
return None
metadata_parent = os.path.dirname(metadata_directory)
if not os.path.isfile(pjoin(metadata_parent, WHEEL_BUILT_MARKER)):
return None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>whl_files = glob(os.path.join(metadata_parent, &quot;*.whl&quot;))
if not whl_files:
    print(&quot;Found wheel built marker, but no .whl files&quot;)
    return None
if len(whl_files) &gt; 1:
    print(
        &quot;Found multiple .whl files; unspecified behaviour. &quot;
        &quot;Will call build_wheel.&quot;
    )
    return None

# Exactly one .whl file
return whl_files[0]
</pre></div>
</div>
<p>def build_wheel(wheel_directory, config_settings, metadata_directory=None):
“””Invoke the mandatory build_wheel hook.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>If a wheel was already built in the
prepare_metadata_for_build_wheel fallback, this
will copy it rather than rebuilding the wheel.
&quot;&quot;&quot;
prebuilt_whl = _find_already_built_wheel(metadata_directory)
if prebuilt_whl:
    shutil.copy2(prebuilt_whl, wheel_directory)
    return os.path.basename(prebuilt_whl)

return _build_backend().build_wheel(
    wheel_directory, config_settings, metadata_directory
)
</pre></div>
</div>
<p>def build_editable(wheel_directory, config_settings, metadata_directory=None):
“””Invoke the optional build_editable hook.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>If a wheel was already built in the
prepare_metadata_for_build_editable fallback, this
will copy it rather than rebuilding the wheel.
&quot;&quot;&quot;
backend = _build_backend()
try:
    hook = backend.build_editable
except AttributeError:
    raise HookMissing()
else:
    prebuilt_whl = _find_already_built_wheel(metadata_directory)
    if prebuilt_whl:
        shutil.copy2(prebuilt_whl, wheel_directory)
        return os.path.basename(prebuilt_whl)

    return hook(wheel_directory, config_settings, metadata_directory)
</pre></div>
</div>
<p>def get_requires_for_build_sdist(config_settings):
“””Invoke the optional get_requires_for_build_wheel hook</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Returns [] if the hook is not defined.
&quot;&quot;&quot;
backend = _build_backend()
try:
    hook = backend.get_requires_for_build_sdist
except AttributeError:
    return []
else:
    return hook(config_settings)
</pre></div>
</div>
<p>class _DummyException(Exception):
“””Nothing should ever raise this exception”””</p>
<p>class GotUnsupportedOperation(Exception):
“””For internal use when backend raises UnsupportedOperation”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, traceback):
    self.traceback = traceback
</pre></div>
</div>
<p>def build_sdist(sdist_directory, config_settings):
“””Invoke the mandatory build_sdist hook.”””
backend = _build_backend()
try:
return backend.build_sdist(sdist_directory, config_settings)
except getattr(backend, “UnsupportedOperation”, _DummyException):
raise GotUnsupportedOperation(traceback.format_exc())</p>
<p>HOOK_NAMES = {
“get_requires_for_build_wheel”,
“prepare_metadata_for_build_wheel”,
“build_wheel”,
“get_requires_for_build_editable”,
“prepare_metadata_for_build_editable”,
“build_editable”,
“get_requires_for_build_sdist”,
“build_sdist”,
“_supported_features”,
}</p>
<p>def main():
if len(sys.argv) &lt; 3:
sys.exit(“Needs args: hook_name, control_dir”)
hook_name = sys.argv[1]
control_dir = sys.argv[2]
if hook_name not in HOOK_NAMES:
sys.exit(“Unknown hook: %s” % hook_name)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Remove the parent directory from sys.path to avoid polluting the backend
# import namespace with this directory.
here = os.path.dirname(__file__)
if here in sys.path:
    sys.path.remove(here)

hook = globals()[hook_name]

hook_input = read_json(pjoin(control_dir, &quot;input.json&quot;))

json_out = {&quot;unsupported&quot;: False, &quot;return_val&quot;: None}
try:
    json_out[&quot;return_val&quot;] = hook(**hook_input[&quot;kwargs&quot;])
except BackendUnavailable as e:
    json_out[&quot;no_backend&quot;] = True
    json_out[&quot;traceback&quot;] = e.traceback
    json_out[&quot;backend_error&quot;] = e.message
except GotUnsupportedOperation as e:
    json_out[&quot;unsupported&quot;] = True
    json_out[&quot;traceback&quot;] = e.traceback
except HookMissing as e:
    json_out[&quot;hook_missing&quot;] = True
    json_out[&quot;missing_hook_name&quot;] = e.hook_name or hook_name

write_json(json_out, pjoin(control_dir, &quot;output.json&quot;), indent=2)
</pre></div>
</div>
<p>if <strong>name</strong> == “<strong>main</strong>”:
main()</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>