

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Note: This file is under the PSF license as the code comes from the python &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Note: This file is under the PSF license as the code comes from the python</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/util/ssl_match_hostname.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””The match_hostname() function from Python 3.3.3, essential when using SSL.”””</p>
<section id="note-this-file-is-under-the-psf-license-as-the-code-comes-from-the-python">
<h1>Note: This file is under the PSF license as the code comes from the python<a class="headerlink" href="#note-this-file-is-under-the-psf-license-as-the-code-comes-from-the-python" title="Link to this heading"></a></h1>
</section>
<section id="stdlib-http-docs-python-org-3-license-html">
<h1>stdlib.   http://docs.python.org/3/license.html<a class="headerlink" href="#stdlib-http-docs-python-org-3-license-html" title="Link to this heading"></a></h1>
<p>import re
import sys</p>
</section>
<section id="ipaddress-has-been-backported-to-2-6-in-pypi-if-it-is-installed-on-the">
<h1>ipaddress has been backported to 2.6+ in pypi.  If it is installed on the<a class="headerlink" href="#ipaddress-has-been-backported-to-2-6-in-pypi-if-it-is-installed-on-the" title="Link to this heading"></a></h1>
</section>
<section id="system-use-it-to-handle-ipaddress-serveraltnames-this-was-added-in">
<h1>system, use it to handle IPAddress ServerAltnames (this was added in<a class="headerlink" href="#system-use-it-to-handle-ipaddress-serveraltnames-this-was-added-in" title="Link to this heading"></a></h1>
</section>
<section id="python-3-5-otherwise-only-do-dns-matching-this-allows">
<h1>python-3.5) otherwise only do DNS matching.  This allows<a class="headerlink" href="#python-3-5-otherwise-only-do-dns-matching-this-allows" title="Link to this heading"></a></h1>
</section>
<section id="util-ssl-match-hostname-to-continue-to-be-used-in-python-2-7">
<h1>util.ssl_match_hostname to continue to be used in Python 2.7.<a class="headerlink" href="#util-ssl-match-hostname-to-continue-to-be-used-in-python-2-7" title="Link to this heading"></a></h1>
<p>try:
import ipaddress
except ImportError:
ipaddress = None</p>
<p><strong>version</strong> = “3.5.0.1”</p>
<p>class CertificateError(ValueError):
pass</p>
<p>def _dnsname_match(dn, hostname, max_wildcards=1):
“””Matching according to RFC 6125, section 6.4.3</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://tools.ietf.org/html/rfc6125#section-6.4.3
&quot;&quot;&quot;
pats = []
if not dn:
    return False

# Ported from python3-syntax:
# leftmost, *remainder = dn.split(r&#39;.&#39;)
parts = dn.split(r&quot;.&quot;)
leftmost = parts[0]
remainder = parts[1:]

wildcards = leftmost.count(&quot;*&quot;)
if wildcards &gt; max_wildcards:
    # Issue #17980: avoid denials of service by refusing more
    # than one wildcard per fragment.  A survey of established
    # policy among SSL implementations showed it to be a
    # reasonable choice.
    raise CertificateError(
        &quot;too many wildcards in certificate DNS name: &quot; + repr(dn)
    )

# speed up common case w/o wildcards
if not wildcards:
    return dn.lower() == hostname.lower()

# RFC 6125, section 6.4.3, subitem 1.
# The client SHOULD NOT attempt to match a presented identifier in which
# the wildcard character comprises a label other than the left-most label.
if leftmost == &quot;*&quot;:
    # When &#39;*&#39; is a fragment by itself, it matches a non-empty dotless
    # fragment.
    pats.append(&quot;[^.]+&quot;)
elif leftmost.startswith(&quot;xn--&quot;) or hostname.startswith(&quot;xn--&quot;):
    # RFC 6125, section 6.4.3, subitem 3.
    # The client SHOULD NOT attempt to match a presented identifier
    # where the wildcard character is embedded within an A-label or
    # U-label of an internationalized domain name.
    pats.append(re.escape(leftmost))
else:
    # Otherwise, &#39;*&#39; matches any dotless string, e.g. www*
    pats.append(re.escape(leftmost).replace(r&quot;\*&quot;, &quot;[^.]*&quot;))

# add the remaining fragments, ignore any wildcards
for frag in remainder:
    pats.append(re.escape(frag))

pat = re.compile(r&quot;\A&quot; + r&quot;\.&quot;.join(pats) + r&quot;\Z&quot;, re.IGNORECASE)
return pat.match(hostname)
</pre></div>
</div>
<p>def _to_unicode(obj):
if isinstance(obj, str) and sys.version_info &lt; (3,):
# ignored flake8 # F821 to support python 2.7 function
obj = unicode(obj, encoding=”ascii”, errors=”strict”)  # noqa: F821
return obj</p>
<p>def _ipaddress_match(ipname, host_ip):
“””Exact matching of IP addresses.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>RFC 6125 explicitly doesn&#39;t define an algorithm for this
(section 1.7.2 - &quot;Out of Scope&quot;).
&quot;&quot;&quot;
# OpenSSL may add a trailing newline to a subjectAltName&#39;s IP address
# Divergence from upstream: ipaddress can&#39;t handle byte str
ip = ipaddress.ip_address(_to_unicode(ipname).rstrip())
return ip == host_ip
</pre></div>
</div>
<p>def match_hostname(cert, hostname):
“””Verify that <em>cert</em> (in decoded format as returned by
SSLSocket.getpeercert()) matches the <em>hostname</em>.  RFC 2818 and RFC 6125
rules are followed, but IP addresses are not accepted for <em>hostname</em>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>CertificateError is raised on failure. On success, the function
returns nothing.
&quot;&quot;&quot;
if not cert:
    raise ValueError(
        &quot;empty or no certificate, match_hostname needs a &quot;
        &quot;SSL socket or SSL context with either &quot;
        &quot;CERT_OPTIONAL or CERT_REQUIRED&quot;
    )
try:
    # Divergence from upstream: ipaddress can&#39;t handle byte str
    host_ip = ipaddress.ip_address(_to_unicode(hostname))
except (UnicodeError, ValueError):
    # ValueError: Not an IP address (common case)
    # UnicodeError: Divergence from upstream: Have to deal with ipaddress not taking
    # byte strings.  addresses should be all ascii, so we consider it not
    # an ipaddress in this case
    host_ip = None
except AttributeError:
    # Divergence from upstream: Make ipaddress library optional
    if ipaddress is None:
        host_ip = None
    else:  # Defensive
        raise
dnsnames = []
san = cert.get(&quot;subjectAltName&quot;, ())
for key, value in san:
    if key == &quot;DNS&quot;:
        if host_ip is None and _dnsname_match(value, hostname):
            return
        dnsnames.append(value)
    elif key == &quot;IP Address&quot;:
        if host_ip is not None and _ipaddress_match(value, host_ip):
            return
        dnsnames.append(value)
if not dnsnames:
    # The subject is only checked when there is no dNSName entry
    # in subjectAltName
    for sub in cert.get(&quot;subject&quot;, ()):
        for key, value in sub:
            # XXX according to RFC 2818, the most specific Common Name
            # must be used.
            if key == &quot;commonName&quot;:
                if _dnsname_match(value, hostname):
                    return
                dnsnames.append(value)
if len(dnsnames) &gt; 1:
    raise CertificateError(
        &quot;hostname %r &quot;
        &quot;doesn&#39;t match either of %s&quot; % (hostname, &quot;, &quot;.join(map(repr, dnsnames)))
    )
elif len(dnsnames) == 1:
    raise CertificateError(&quot;hostname %r doesn&#39;t match %r&quot; % (hostname, dnsnames[0]))
else:
    raise CertificateError(
        &quot;no appropriate commonName or subjectAltName fields were found&quot;
    )
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>