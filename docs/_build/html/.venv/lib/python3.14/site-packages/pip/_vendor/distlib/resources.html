

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>-- coding: utf-8 -- &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">-<em>- coding: utf-8 -</em>-</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/distlib/resources.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="coding-utf-8">
<h1>-<em>- coding: utf-8 -</em>-<a class="headerlink" href="#coding-utf-8" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="copyright-c-2013-2017-vinay-sajip">
<h1>Copyright (C) 2013-2017 Vinay Sajip.<a class="headerlink" href="#copyright-c-2013-2017-vinay-sajip" title="Link to this heading"></a></h1>
</section>
<section id="licensed-to-the-python-software-foundation-under-a-contributor-agreement">
<h1>Licensed to the Python Software Foundation under a contributor agreement.<a class="headerlink" href="#licensed-to-the-python-software-foundation-under-a-contributor-agreement" title="Link to this heading"></a></h1>
</section>
<section id="see-license-txt-and-contributors-txt">
<h1>See LICENSE.txt and CONTRIBUTORS.txt.<a class="headerlink" href="#see-license-txt-and-contributors-txt" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import unicode_literals</p>
<p>import bisect
import io
import logging
import os
import pkgutil
import sys
import types
import zipimport</p>
<p>from . import DistlibException
from .util import cached_property, get_cache_base, Cache</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>cache = None    # created when needed</p>
<p>class ResourceCache(Cache):
def <strong>init</strong>(self, base=None):
if base is None:
# Use native string to avoid issues on 2.x: see Python #20140.
base = os.path.join(get_cache_base(), str(‘resource-cache’))
super(ResourceCache, self).<strong>init</strong>(base)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def is_stale(self, resource, path):
    &quot;&quot;&quot;
    Is the cache stale for the given resource?

    :param resource: The :class:`Resource` being cached.
    :param path: The path of the resource in the cache.
    :return: True if the cache is stale.
    &quot;&quot;&quot;
    # Cache invalidation is a hard problem :-)
    return True

def get(self, resource):
    &quot;&quot;&quot;
    Get a resource into the cache,

    :param resource: A :class:`Resource` instance.
    :return: The pathname of the resource in the cache.
    &quot;&quot;&quot;
    prefix, path = resource.finder.get_cache_info(resource)
    if prefix is None:
        result = path
    else:
        result = os.path.join(self.base, self.prefix_to_dir(prefix), path)
        dirname = os.path.dirname(result)
        if not os.path.isdir(dirname):
            os.makedirs(dirname)
        if not os.path.exists(result):
            stale = True
        else:
            stale = self.is_stale(resource, path)
        if stale:
            # write the bytes of the resource to the cache location
            with open(result, &#39;wb&#39;) as f:
                f.write(resource.bytes)
    return result
</pre></div>
</div>
<p>class ResourceBase(object):
def <strong>init</strong>(self, finder, name):
self.finder = finder
self.name = name</p>
<p>class Resource(ResourceBase):
“””
A class representing an in-package resource, such as a data file. This is
not normally instantiated by user code, but rather by a
:class:<code class="docutils literal notranslate"><span class="pre">ResourceFinder</span></code> which manages the resource.
“””
is_container = False        # Backwards compatibility</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def as_stream(self):
    &quot;&quot;&quot;
    Get the resource as a stream.

    This is not a property to make it obvious that it returns a new stream
    each time.
    &quot;&quot;&quot;
    return self.finder.get_stream(self)

@cached_property
def file_path(self):
    global cache
    if cache is None:
        cache = ResourceCache()
    return cache.get(self)

@cached_property
def bytes(self):
    return self.finder.get_bytes(self)

@cached_property
def size(self):
    return self.finder.get_size(self)
</pre></div>
</div>
<p>class ResourceContainer(ResourceBase):
is_container = True     # Backwards compatibility</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@cached_property
def resources(self):
    return self.finder.get_resources(self)
</pre></div>
</div>
<p>class ResourceFinder(object):
“””
Resource finder for file system resources.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if sys.platform.startswith(&#39;java&#39;):
    skipped_extensions = (&#39;.pyc&#39;, &#39;.pyo&#39;, &#39;.class&#39;)
else:
    skipped_extensions = (&#39;.pyc&#39;, &#39;.pyo&#39;)

def __init__(self, module):
    self.module = module
    self.loader = getattr(module, &#39;__loader__&#39;, None)
    self.base = os.path.dirname(getattr(module, &#39;__file__&#39;, &#39;&#39;))

def _adjust_path(self, path):
    return os.path.realpath(path)

def _make_path(self, resource_name):
    # Issue #50: need to preserve type of path on Python 2.x
    # like os.path._get_sep
    if isinstance(resource_name, bytes):    # should only happen on 2.x
        sep = b&#39;/&#39;
    else:
        sep = &#39;/&#39;
    parts = resource_name.split(sep)
    parts.insert(0, self.base)
    result = os.path.join(*parts)
    return self._adjust_path(result)

def _find(self, path):
    return os.path.exists(path)

def get_cache_info(self, resource):
    return None, resource.path

def find(self, resource_name):
    path = self._make_path(resource_name)
    if not self._find(path):
        result = None
    else:
        if self._is_directory(path):
            result = ResourceContainer(self, resource_name)
        else:
            result = Resource(self, resource_name)
        result.path = path
    return result

def get_stream(self, resource):
    return open(resource.path, &#39;rb&#39;)

def get_bytes(self, resource):
    with open(resource.path, &#39;rb&#39;) as f:
        return f.read()

def get_size(self, resource):
    return os.path.getsize(resource.path)

def get_resources(self, resource):
    def allowed(f):
        return (f != &#39;__pycache__&#39; and not
                f.endswith(self.skipped_extensions))
    return set([f for f in os.listdir(resource.path) if allowed(f)])

def is_container(self, resource):
    return self._is_directory(resource.path)

_is_directory = staticmethod(os.path.isdir)

def iterator(self, resource_name):
    resource = self.find(resource_name)
    if resource is not None:
        todo = [resource]
        while todo:
            resource = todo.pop(0)
            yield resource
            if resource.is_container:
                rname = resource.name
                for name in resource.resources:
                    if not rname:
                        new_name = name
                    else:
                        new_name = &#39;/&#39;.join([rname, name])
                    child = self.find(new_name)
                    if child.is_container:
                        todo.append(child)
                    else:
                        yield child
</pre></div>
</div>
<p>class ZipResourceFinder(ResourceFinder):
“””
Resource finder for resources in .zip files.
“””
def <strong>init</strong>(self, module):
super(ZipResourceFinder, self).<strong>init</strong>(module)
archive = self.loader.archive
self.prefix_len = 1 + len(archive)
# PyPy doesn’t have a _files attr on zipimporter, and you can’t set one
if hasattr(self.loader, ‘_files’):
self._files = self.loader._files
else:
self._files = zipimport._zip_directory_cache[archive]
self.index = sorted(self._files)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def _adjust_path(self, path):
    return path

def _find(self, path):
    path = path[self.prefix_len:]
    if path in self._files:
        result = True
    else:
        if path and path[-1] != os.sep:
            path = path + os.sep
        i = bisect.bisect(self.index, path)
        try:
            result = self.index[i].startswith(path)
        except IndexError:
            result = False
    if not result:
        logger.debug(&#39;_find failed: %r %r&#39;, path, self.loader.prefix)
    else:
        logger.debug(&#39;_find worked: %r %r&#39;, path, self.loader.prefix)
    return result

def get_cache_info(self, resource):
    prefix = self.loader.archive
    path = resource.path[1 + len(prefix):]
    return prefix, path

def get_bytes(self, resource):
    return self.loader.get_data(resource.path)

def get_stream(self, resource):
    return io.BytesIO(self.get_bytes(resource))

def get_size(self, resource):
    path = resource.path[self.prefix_len:]
    return self._files[path][3]

def get_resources(self, resource):
    path = resource.path[self.prefix_len:]
    if path and path[-1] != os.sep:
        path += os.sep
    plen = len(path)
    result = set()
    i = bisect.bisect(self.index, path)
    while i &lt; len(self.index):
        if not self.index[i].startswith(path):
            break
        s = self.index[i][plen:]
        result.add(s.split(os.sep, 1)[0])   # only immediate children
        i += 1
    return result

def _is_directory(self, path):
    path = path[self.prefix_len:]
    if path and path[-1] != os.sep:
        path += os.sep
    i = bisect.bisect(self.index, path)
    try:
        result = self.index[i].startswith(path)
    except IndexError:
        result = False
    return result
</pre></div>
</div>
<p>_finder_registry = {
type(None): ResourceFinder,
zipimport.zipimporter: ZipResourceFinder
}</p>
<p>try:
# In Python 3.6, _frozen_importlib -&gt; _frozen_importlib_external
try:
import _frozen_importlib_external as _fi
except ImportError:
import _frozen_importlib as _fi
_finder_registry[_fi.SourceFileLoader] = ResourceFinder
_finder_registry[_fi.FileFinder] = ResourceFinder
# See issue #146
_finder_registry[_fi.SourcelessFileLoader] = ResourceFinder
del _fi
except (ImportError, AttributeError):
pass</p>
<p>def register_finder(loader, finder_maker):
_finder_registry[type(loader)] = finder_maker</p>
<p>_finder_cache = {}</p>
<p>def finder(package):
“””
Return a resource finder for a package.
:param package: The name of the package.
:return: A :class:<code class="docutils literal notranslate"><span class="pre">ResourceFinder</span></code> instance for the package.
“””
if package in _finder_cache:
result = _finder_cache[package]
else:
if package not in sys.modules:
<strong>import</strong>(package)
module = sys.modules[package]
path = getattr(module, ‘<strong>path</strong>’, None)
if path is None:
raise DistlibException(‘You cannot get a finder for a module, ‘
‘only for a package’)
loader = getattr(module, ‘<strong>loader</strong>’, None)
finder_maker = _finder_registry.get(type(loader))
if finder_maker is None:
raise DistlibException(‘Unable to locate finder for %r’ % package)
result = finder_maker(module)
_finder_cache[package] = result
return result</p>
<p>_dummy_module = types.ModuleType(str(’<strong>dummy</strong>’))</p>
<p>def finder_for_path(path):
“””
Return a resource finder for a path, which should represent a container.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param path: The path.
:return: A :class:`ResourceFinder` instance for the path.
&quot;&quot;&quot;
result = None
# calls any path hooks, gets importer into cache
pkgutil.get_importer(path)
loader = sys.path_importer_cache.get(path)
finder = _finder_registry.get(type(loader))
if finder:
    module = _dummy_module
    module.__file__ = os.path.join(path, &#39;&#39;)
    module.__loader__ = loader
    result = finder(module)
return result
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>