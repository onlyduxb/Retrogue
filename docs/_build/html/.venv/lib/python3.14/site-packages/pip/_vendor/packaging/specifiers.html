

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>This file is dual licensed under the terms of the Apache License, Version &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">This file is dual licensed under the terms of the Apache License, Version</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/specifiers.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version">
<h1>This file is dual licensed under the terms of the Apache License, Version<a class="headerlink" href="#this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version" title="Link to this heading"></a></h1>
</section>
<section id="and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository">
<h1>2.0, and the BSD License. See the LICENSE file in the root of this repository<a class="headerlink" href="#and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository" title="Link to this heading"></a></h1>
</section>
<section id="for-complete-details">
<h1>for complete details.<a class="headerlink" href="#for-complete-details" title="Link to this heading"></a></h1>
<p>“””
.. testsetup::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pip._vendor.packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier
from pip._vendor.packaging.version import Version
</pre></div>
</div>
<p>“””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import abc
import itertools
import re
from typing import Callable, Iterable, Iterator, TypeVar, Union</p>
<p>from .utils import canonicalize_version
from .version import Version</p>
<p>UnparsedVersion = Union[Version, str]
UnparsedVersionVar = TypeVar(“UnparsedVersionVar”, bound=UnparsedVersion)
CallableOperator = Callable[[Version, str], bool]</p>
<p>def _coerce_version(version: UnparsedVersion) -&gt; Version:
if not isinstance(version, Version):
version = Version(version)
return version</p>
<p>class InvalidSpecifier(ValueError):
“””
Raised when attempting to create a :class:<code class="docutils literal notranslate"><span class="pre">Specifier</span></code> with a specifier
string that is invalid.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; Specifier(&quot;lolwat&quot;)
Traceback (most recent call last):
    ...
packaging.specifiers.InvalidSpecifier: Invalid specifier: &#39;lolwat&#39;
&quot;&quot;&quot;
</pre></div>
</div>
<p>class BaseSpecifier(metaclass=abc.ABCMeta):
&#64;abc.abstractmethod
def <strong>str</strong>(self) -&gt; str:
“””
Returns the str representation of this Specifier-like object. This
should be representative of the Specifier itself.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@abc.abstractmethod
def __hash__(self) -&gt; int:
    &quot;&quot;&quot;
    Returns a hash value for this Specifier-like object.
    &quot;&quot;&quot;

@abc.abstractmethod
def __eq__(self, other: object) -&gt; bool:
    &quot;&quot;&quot;
    Returns a boolean representing whether or not the two Specifier-like
    objects are equal.

    :param other: The other object to check against.
    &quot;&quot;&quot;

@property
@abc.abstractmethod
def prereleases(self) -&gt; bool | None:
    &quot;&quot;&quot;Whether or not pre-releases as a whole are allowed.

    This can be set to either ``True`` or ``False`` to explicitly enable or disable
    prereleases or it can be set to ``None`` (the default) to use default semantics.
    &quot;&quot;&quot;

@prereleases.setter
def prereleases(self, value: bool) -&gt; None:
    &quot;&quot;&quot;Setter for :attr:`prereleases`.

    :param value: The value to set.
    &quot;&quot;&quot;

@abc.abstractmethod
def contains(self, item: str, prereleases: bool | None = None) -&gt; bool:
    &quot;&quot;&quot;
    Determines if the given item is contained within this specifier.
    &quot;&quot;&quot;

@abc.abstractmethod
def filter(
    self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None
) -&gt; Iterator[UnparsedVersionVar]:
    &quot;&quot;&quot;
    Takes an iterable of items and filters them so that only items which
    are contained within this specifier are allowed in it.
    &quot;&quot;&quot;
</pre></div>
</div>
<p>class Specifier(BaseSpecifier):
“””This class abstracts handling of version specifiers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>.. tip::

    It is generally not required to instantiate this manually. You should instead
    prefer to work with :class:`SpecifierSet` instead, which can parse
    comma-separated version specifiers (which is what package metadata contains).
&quot;&quot;&quot;

_operator_regex_str = r&quot;&quot;&quot;
    (?P&lt;operator&gt;(~=|==|!=|&lt;=|&gt;=|&lt;|&gt;|===))
    &quot;&quot;&quot;
_version_regex_str = r&quot;&quot;&quot;
    (?P&lt;version&gt;
        (?:
            # The identity operators allow for an escape hatch that will
            # do an exact string match of the version you wish to install.
            # This will not be parsed by PEP 440 and we cannot determine
            # any semantic meaning from it. This operator is discouraged
            # but included entirely as an escape hatch.
            (?&lt;====)  # Only match for the identity operator
            \s*
            [^\s;)]*  # The arbitrary version can be just about anything,
                      # we match everything except for whitespace, a
                      # semi-colon for marker support, and a closing paren
                      # since versions can be enclosed in them.
        )
        |
        (?:
            # The (non)equality operators allow for wild card and local
            # versions to be specified so we have to define these two
            # operators separately to enable that.
            (?&lt;===|!=)            # Only match for equals and not equals

            \s*
            v?
            (?:[0-9]+!)?          # epoch
            [0-9]+(?:\.[0-9]+)*   # release

            # You cannot use a wild card and a pre-release, post-release, a dev or
            # local version together so group them with a | and make them optional.
            (?:
                \.\*  # Wild card syntax of .*
                |
                (?:                                  # pre release
                    [-_\.]?
                    (alpha|beta|preview|pre|a|b|c|rc)
                    [-_\.]?
                    [0-9]*
                )?
                (?:                                  # post release
                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
                )?
                (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release
                (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local
            )?
        )
        |
        (?:
            # The compatible operator requires at least two digits in the
            # release segment.
            (?&lt;=~=)               # Only match for the compatible operator

            \s*
            v?
            (?:[0-9]+!)?          # epoch
            [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)
            (?:                   # pre release
                [-_\.]?
                (alpha|beta|preview|pre|a|b|c|rc)
                [-_\.]?
                [0-9]*
            )?
            (?:                                   # post release
                (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
            )?
            (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
        )
        |
        (?:
            # All other operators only allow a sub set of what the
            # (non)equality operators do. Specifically they do not allow
            # local versions to be specified nor do they allow the prefix
            # matching wild cards.
            (?&lt;!==|!=|~=)         # We have special cases for these
                                  # operators so we want to make sure they
                                  # don&#39;t match here.

            \s*
            v?
            (?:[0-9]+!)?          # epoch
            [0-9]+(?:\.[0-9]+)*   # release
            (?:                   # pre release
                [-_\.]?
                (alpha|beta|preview|pre|a|b|c|rc)
                [-_\.]?
                [0-9]*
            )?
            (?:                                   # post release
                (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)
            )?
            (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release
        )
    )
    &quot;&quot;&quot;

_regex = re.compile(
    r&quot;^\s*&quot; + _operator_regex_str + _version_regex_str + r&quot;\s*$&quot;,
    re.VERBOSE | re.IGNORECASE,
)

_operators = {
    &quot;~=&quot;: &quot;compatible&quot;,
    &quot;==&quot;: &quot;equal&quot;,
    &quot;!=&quot;: &quot;not_equal&quot;,
    &quot;&lt;=&quot;: &quot;less_than_equal&quot;,
    &quot;&gt;=&quot;: &quot;greater_than_equal&quot;,
    &quot;&lt;&quot;: &quot;less_than&quot;,
    &quot;&gt;&quot;: &quot;greater_than&quot;,
    &quot;===&quot;: &quot;arbitrary&quot;,
}

def __init__(self, spec: str = &quot;&quot;, prereleases: bool | None = None) -&gt; None:
    &quot;&quot;&quot;Initialize a Specifier instance.

    :param spec:
        The string representation of a specifier which will be parsed and
        normalized before use.
    :param prereleases:
        This tells the specifier if it should accept prerelease versions if
        applicable or not. The default of ``None`` will autodetect it from the
        given specifiers.
    :raises InvalidSpecifier:
        If the given specifier is invalid (i.e. bad syntax).
    &quot;&quot;&quot;
    match = self._regex.search(spec)
    if not match:
        raise InvalidSpecifier(f&quot;Invalid specifier: {spec!r}&quot;)

    self._spec: tuple[str, str] = (
        match.group(&quot;operator&quot;).strip(),
        match.group(&quot;version&quot;).strip(),
    )

    # Store whether or not this Specifier should accept prereleases
    self._prereleases = prereleases

# https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515
@property  # type: ignore[override]
def prereleases(self) -&gt; bool:
    # If there is an explicit prereleases set for this, then we&#39;ll just
    # blindly use that.
    if self._prereleases is not None:
        return self._prereleases

    # Look at all of our specifiers and determine if they are inclusive
    # operators, and if they are if they are including an explicit
    # prerelease.
    operator, version = self._spec
    if operator in [&quot;==&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;~=&quot;, &quot;===&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;]:
        # The == specifier can include a trailing .*, if it does we
        # want to remove before parsing.
        if operator == &quot;==&quot; and version.endswith(&quot;.*&quot;):
            version = version[:-2]

        # Parse the version, and if it is a pre-release than this
        # specifier allows pre-releases.
        if Version(version).is_prerelease:
            return True

    return False

@prereleases.setter
def prereleases(self, value: bool) -&gt; None:
    self._prereleases = value

@property
def operator(self) -&gt; str:
    &quot;&quot;&quot;The operator of this specifier.

    &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;).operator
    &#39;==&#39;
    &quot;&quot;&quot;
    return self._spec[0]

@property
def version(self) -&gt; str:
    &quot;&quot;&quot;The version of this specifier.

    &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;).version
    &#39;1.2.3&#39;
    &quot;&quot;&quot;
    return self._spec[1]

def __repr__(self) -&gt; str:
    &quot;&quot;&quot;A representation of the Specifier that shows all internal state.

    &gt;&gt;&gt; Specifier(&#39;&gt;=1.0.0&#39;)
    &lt;Specifier(&#39;&gt;=1.0.0&#39;)&gt;
    &gt;&gt;&gt; Specifier(&#39;&gt;=1.0.0&#39;, prereleases=False)
    &lt;Specifier(&#39;&gt;=1.0.0&#39;, prereleases=False)&gt;
    &gt;&gt;&gt; Specifier(&#39;&gt;=1.0.0&#39;, prereleases=True)
    &lt;Specifier(&#39;&gt;=1.0.0&#39;, prereleases=True)&gt;
    &quot;&quot;&quot;
    pre = (
        f&quot;, prereleases={self.prereleases!r}&quot;
        if self._prereleases is not None
        else &quot;&quot;
    )

    return f&quot;&lt;{self.__class__.__name__}({str(self)!r}{pre})&gt;&quot;

def __str__(self) -&gt; str:
    &quot;&quot;&quot;A string representation of the Specifier that can be round-tripped.

    &gt;&gt;&gt; str(Specifier(&#39;&gt;=1.0.0&#39;))
    &#39;&gt;=1.0.0&#39;
    &gt;&gt;&gt; str(Specifier(&#39;&gt;=1.0.0&#39;, prereleases=False))
    &#39;&gt;=1.0.0&#39;
    &quot;&quot;&quot;
    return &quot;{}{}&quot;.format(*self._spec)

@property
def _canonical_spec(self) -&gt; tuple[str, str]:
    canonical_version = canonicalize_version(
        self._spec[1],
        strip_trailing_zero=(self._spec[0] != &quot;~=&quot;),
    )
    return self._spec[0], canonical_version

def __hash__(self) -&gt; int:
    return hash(self._canonical_spec)

def __eq__(self, other: object) -&gt; bool:
    &quot;&quot;&quot;Whether or not the two Specifier-like objects are equal.

    :param other: The other object to check against.

    The value of :attr:`prereleases` is ignored.

    &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == Specifier(&quot;== 1.2.3.0&quot;)
    True
    &gt;&gt;&gt; (Specifier(&quot;==1.2.3&quot;, prereleases=False) ==
    ...  Specifier(&quot;==1.2.3&quot;, prereleases=True))
    True
    &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == &quot;==1.2.3&quot;
    True
    &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == Specifier(&quot;==1.2.4&quot;)
    False
    &gt;&gt;&gt; Specifier(&quot;==1.2.3&quot;) == Specifier(&quot;~=1.2.3&quot;)
    False
    &quot;&quot;&quot;
    if isinstance(other, str):
        try:
            other = self.__class__(str(other))
        except InvalidSpecifier:
            return NotImplemented
    elif not isinstance(other, self.__class__):
        return NotImplemented

    return self._canonical_spec == other._canonical_spec

def _get_operator(self, op: str) -&gt; CallableOperator:
    operator_callable: CallableOperator = getattr(
        self, f&quot;_compare_{self._operators[op]}&quot;
    )
    return operator_callable

def _compare_compatible(self, prospective: Version, spec: str) -&gt; bool:
    # Compatible releases have an equivalent combination of &gt;= and ==. That
    # is that ~=2.2 is equivalent to &gt;=2.2,==2.*. This allows us to
    # implement this in terms of the other specifiers instead of
    # implementing it ourselves. The only thing we need to do is construct
    # the other specifiers.

    # We want everything but the last item in the version, but we want to
    # ignore suffix segments.
    prefix = _version_join(
        list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]
    )

    # Add the prefix notation to the end of our string
    prefix += &quot;.*&quot;

    return self._get_operator(&quot;&gt;=&quot;)(prospective, spec) and self._get_operator(&quot;==&quot;)(
        prospective, prefix
    )

def _compare_equal(self, prospective: Version, spec: str) -&gt; bool:
    # We need special logic to handle prefix matching
    if spec.endswith(&quot;.*&quot;):
        # In the case of prefix matching we want to ignore local segment.
        normalized_prospective = canonicalize_version(
            prospective.public, strip_trailing_zero=False
        )
        # Get the normalized version string ignoring the trailing .*
        normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)
        # Split the spec out by bangs and dots, and pretend that there is
        # an implicit dot in between a release segment and a pre-release segment.
        split_spec = _version_split(normalized_spec)

        # Split the prospective version out by bangs and dots, and pretend
        # that there is an implicit dot in between a release segment and
        # a pre-release segment.
        split_prospective = _version_split(normalized_prospective)

        # 0-pad the prospective version before shortening it to get the correct
        # shortened version.
        padded_prospective, _ = _pad_version(split_prospective, split_spec)

        # Shorten the prospective version to be the same length as the spec
        # so that we can determine if the specifier is a prefix of the
        # prospective version or not.
        shortened_prospective = padded_prospective[: len(split_spec)]

        return shortened_prospective == split_spec
    else:
        # Convert our spec string into a Version
        spec_version = Version(spec)

        # If the specifier does not have a local segment, then we want to
        # act as if the prospective version also does not have a local
        # segment.
        if not spec_version.local:
            prospective = Version(prospective.public)

        return prospective == spec_version

def _compare_not_equal(self, prospective: Version, spec: str) -&gt; bool:
    return not self._compare_equal(prospective, spec)

def _compare_less_than_equal(self, prospective: Version, spec: str) -&gt; bool:
    # NB: Local version identifiers are NOT permitted in the version
    # specifier, so local version labels can be universally removed from
    # the prospective version.
    return Version(prospective.public) &lt;= Version(spec)

def _compare_greater_than_equal(self, prospective: Version, spec: str) -&gt; bool:
    # NB: Local version identifiers are NOT permitted in the version
    # specifier, so local version labels can be universally removed from
    # the prospective version.
    return Version(prospective.public) &gt;= Version(spec)

def _compare_less_than(self, prospective: Version, spec_str: str) -&gt; bool:
    # Convert our spec to a Version instance, since we&#39;ll want to work with
    # it as a version.
    spec = Version(spec_str)

    # Check to see if the prospective version is less than the spec
    # version. If it&#39;s not we can short circuit and just return False now
    # instead of doing extra unneeded work.
    if not prospective &lt; spec:
        return False

    # This special case is here so that, unless the specifier itself
    # includes is a pre-release version, that we do not accept pre-release
    # versions for the version mentioned in the specifier (e.g. &lt;3.1 should
    # not match 3.1.dev0, but should match 3.0.dev0).
    if not spec.is_prerelease and prospective.is_prerelease:
        if Version(prospective.base_version) == Version(spec.base_version):
            return False

    # If we&#39;ve gotten to here, it means that prospective version is both
    # less than the spec version *and* it&#39;s not a pre-release of the same
    # version in the spec.
    return True

def _compare_greater_than(self, prospective: Version, spec_str: str) -&gt; bool:
    # Convert our spec to a Version instance, since we&#39;ll want to work with
    # it as a version.
    spec = Version(spec_str)

    # Check to see if the prospective version is greater than the spec
    # version. If it&#39;s not we can short circuit and just return False now
    # instead of doing extra unneeded work.
    if not prospective &gt; spec:
        return False

    # This special case is here so that, unless the specifier itself
    # includes is a post-release version, that we do not accept
    # post-release versions for the version mentioned in the specifier
    # (e.g. &gt;3.1 should not match 3.0.post0, but should match 3.2.post0).
    if not spec.is_postrelease and prospective.is_postrelease:
        if Version(prospective.base_version) == Version(spec.base_version):
            return False

    # Ensure that we do not allow a local version of the version mentioned
    # in the specifier, which is technically greater than, to match.
    if prospective.local is not None:
        if Version(prospective.base_version) == Version(spec.base_version):
            return False

    # If we&#39;ve gotten to here, it means that prospective version is both
    # greater than the spec version *and* it&#39;s not a pre-release of the
    # same version in the spec.
    return True

def _compare_arbitrary(self, prospective: Version, spec: str) -&gt; bool:
    return str(prospective).lower() == str(spec).lower()

def __contains__(self, item: str | Version) -&gt; bool:
    &quot;&quot;&quot;Return whether or not the item is contained in this specifier.

    :param item: The item to check for.

    This is used for the ``in`` operator and behaves the same as
    :meth:`contains` with no ``prereleases`` argument passed.

    &gt;&gt;&gt; &quot;1.2.3&quot; in Specifier(&quot;&gt;=1.2.3&quot;)
    True
    &gt;&gt;&gt; Version(&quot;1.2.3&quot;) in Specifier(&quot;&gt;=1.2.3&quot;)
    True
    &gt;&gt;&gt; &quot;1.0.0&quot; in Specifier(&quot;&gt;=1.2.3&quot;)
    False
    &gt;&gt;&gt; &quot;1.3.0a1&quot; in Specifier(&quot;&gt;=1.2.3&quot;)
    False
    &gt;&gt;&gt; &quot;1.3.0a1&quot; in Specifier(&quot;&gt;=1.2.3&quot;, prereleases=True)
    True
    &quot;&quot;&quot;
    return self.contains(item)

def contains(self, item: UnparsedVersion, prereleases: bool | None = None) -&gt; bool:
    &quot;&quot;&quot;Return whether or not the item is contained in this specifier.

    :param item:
        The item to check for, which can be a version string or a
        :class:`Version` instance.
    :param prereleases:
        Whether or not to match prereleases with this Specifier. If set to
        ``None`` (the default), it uses :attr:`prereleases` to determine
        whether or not prereleases are allowed.

    &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.2.3&quot;)
    True
    &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(Version(&quot;1.2.3&quot;))
    True
    &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.0.0&quot;)
    False
    &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.3.0a1&quot;)
    False
    &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;, prereleases=True).contains(&quot;1.3.0a1&quot;)
    True
    &gt;&gt;&gt; Specifier(&quot;&gt;=1.2.3&quot;).contains(&quot;1.3.0a1&quot;, prereleases=True)
    True
    &quot;&quot;&quot;

    # Determine if prereleases are to be allowed or not.
    if prereleases is None:
        prereleases = self.prereleases

    # Normalize item to a Version, this allows us to have a shortcut for
    # &quot;2.0&quot; in Specifier(&quot;&gt;=2&quot;)
    normalized_item = _coerce_version(item)

    # Determine if we should be supporting prereleases in this specifier
    # or not, if we do not support prereleases than we can short circuit
    # logic if this version is a prereleases.
    if normalized_item.is_prerelease and not prereleases:
        return False

    # Actually do the comparison to determine if this item is contained
    # within this Specifier or not.
    operator_callable: CallableOperator = self._get_operator(self.operator)
    return operator_callable(normalized_item, self.version)

def filter(
    self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None
) -&gt; Iterator[UnparsedVersionVar]:
    &quot;&quot;&quot;Filter items in the given iterable, that match the specifier.

    :param iterable:
        An iterable that can contain version strings and :class:`Version` instances.
        The items in the iterable will be filtered according to the specifier.
    :param prereleases:
        Whether or not to allow prereleases in the returned iterator. If set to
        ``None`` (the default), it will be intelligently decide whether to allow
        prereleases or not (based on the :attr:`prereleases` attribute, and
        whether the only versions matching are prereleases).

    This method is smarter than just ``filter(Specifier().contains, [...])``
    because it implements the rule from :pep:`440` that a prerelease item
    SHOULD be accepted if no other versions match the given specifier.

    &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.3&quot;, &quot;1.5a1&quot;]))
    [&#39;1.3&#39;]
    &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.2.3&quot;, &quot;1.3&quot;, Version(&quot;1.4&quot;)]))
    [&#39;1.2.3&#39;, &#39;1.3&#39;, &lt;Version(&#39;1.4&#39;)&gt;]
    &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.5a1&quot;]))
    [&#39;1.5a1&#39;]
    &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;], prereleases=True))
    [&#39;1.3&#39;, &#39;1.5a1&#39;]
    &gt;&gt;&gt; list(Specifier(&quot;&gt;=1.2.3&quot;, prereleases=True).filter([&quot;1.3&quot;, &quot;1.5a1&quot;]))
    [&#39;1.3&#39;, &#39;1.5a1&#39;]
    &quot;&quot;&quot;

    yielded = False
    found_prereleases = []

    kw = {&quot;prereleases&quot;: prereleases if prereleases is not None else True}

    # Attempt to iterate over all the values in the iterable and if any of
    # them match, yield them.
    for version in iterable:
        parsed_version = _coerce_version(version)

        if self.contains(parsed_version, **kw):
            # If our version is a prerelease, and we were not set to allow
            # prereleases, then we&#39;ll store it for later in case nothing
            # else matches this specifier.
            if parsed_version.is_prerelease and not (
                prereleases or self.prereleases
            ):
                found_prereleases.append(version)
            # Either this is not a prerelease, or we should have been
            # accepting prereleases from the beginning.
            else:
                yielded = True
                yield version

    # Now that we&#39;ve iterated over everything, determine if we&#39;ve yielded
    # any values, and if we have not and we have any prereleases stored up
    # then we will go ahead and yield the prereleases.
    if not yielded and found_prereleases:
        for version in found_prereleases:
            yield version
</pre></div>
</div>
<p>_prefix_regex = re.compile(r”^([0-9]+)((?:a|b|c|rc)[0-9]+)$”)</p>
<p>def _version_split(version: str) -&gt; list[str]:
“””Split version into components.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The split components are intended for version comparison. The logic does
not attempt to retain the original version string, so joining the
components back with :func:`_version_join` may not produce the original
version string.
&quot;&quot;&quot;
result: list[str] = []

epoch, _, rest = version.rpartition(&quot;!&quot;)
result.append(epoch or &quot;0&quot;)

for item in rest.split(&quot;.&quot;):
    match = _prefix_regex.search(item)
    if match:
        result.extend(match.groups())
    else:
        result.append(item)
return result
</pre></div>
</div>
<p>def _version_join(components: list[str]) -&gt; str:
“””Join split version components into a version string.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This function assumes the input came from :func:`_version_split`, where the
first component must be the epoch (either empty or numeric), and all other
components numeric.
&quot;&quot;&quot;
epoch, *rest = components
return f&quot;{epoch}!{&#39;.&#39;.join(rest)}&quot;
</pre></div>
</div>
<p>def _is_not_suffix(segment: str) -&gt; bool:
return not any(
segment.startswith(prefix) for prefix in (“dev”, “a”, “b”, “rc”, “post”)
)</p>
<p>def _pad_version(left: list[str], right: list[str]) -&gt; tuple[list[str], list[str]]:
left_split, right_split = [], []</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Get the release segment of our versions
left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))
right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))

# Get the rest of our versions
left_split.append(left[len(left_split[0]) :])
right_split.append(right[len(right_split[0]) :])

# Insert our padding
left_split.insert(1, [&quot;0&quot;] * max(0, len(right_split[0]) - len(left_split[0])))
right_split.insert(1, [&quot;0&quot;] * max(0, len(left_split[0]) - len(right_split[0])))

return (
    list(itertools.chain.from_iterable(left_split)),
    list(itertools.chain.from_iterable(right_split)),
)
</pre></div>
</div>
<p>class SpecifierSet(BaseSpecifier):
“””This class abstracts handling of a set of version specifiers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>It can be passed a single specifier (``&gt;=3.0``), a comma-separated list of
specifiers (``&gt;=3.0,!=3.1``), or no specifier at all.
&quot;&quot;&quot;

def __init__(
    self,
    specifiers: str | Iterable[Specifier] = &quot;&quot;,
    prereleases: bool | None = None,
) -&gt; None:
    &quot;&quot;&quot;Initialize a SpecifierSet instance.

    :param specifiers:
        The string representation of a specifier or a comma-separated list of
        specifiers which will be parsed and normalized before use.
        May also be an iterable of ``Specifier`` instances, which will be used
        as is.
    :param prereleases:
        This tells the SpecifierSet if it should accept prerelease versions if
        applicable or not. The default of ``None`` will autodetect it from the
        given specifiers.

    :raises InvalidSpecifier:
        If the given ``specifiers`` are not parseable than this exception will be
        raised.
    &quot;&quot;&quot;

    if isinstance(specifiers, str):
        # Split on `,` to break each individual specifier into its own item, and
        # strip each item to remove leading/trailing whitespace.
        split_specifiers = [s.strip() for s in specifiers.split(&quot;,&quot;) if s.strip()]

        # Make each individual specifier a Specifier and save in a frozen set
        # for later.
        self._specs = frozenset(map(Specifier, split_specifiers))
    else:
        # Save the supplied specifiers in a frozen set.
        self._specs = frozenset(specifiers)

    # Store our prereleases value so we can use it later to determine if
    # we accept prereleases or not.
    self._prereleases = prereleases

@property
def prereleases(self) -&gt; bool | None:
    # If we have been given an explicit prerelease modifier, then we&#39;ll
    # pass that through here.
    if self._prereleases is not None:
        return self._prereleases

    # If we don&#39;t have any specifiers, and we don&#39;t have a forced value,
    # then we&#39;ll just return None since we don&#39;t know if this should have
    # pre-releases or not.
    if not self._specs:
        return None

    # Otherwise we&#39;ll see if any of the given specifiers accept
    # prereleases, if any of them do we&#39;ll return True, otherwise False.
    return any(s.prereleases for s in self._specs)

@prereleases.setter
def prereleases(self, value: bool) -&gt; None:
    self._prereleases = value

def __repr__(self) -&gt; str:
    &quot;&quot;&quot;A representation of the specifier set that shows all internal state.

    Note that the ordering of the individual specifiers within the set may not
    match the input string.

    &gt;&gt;&gt; SpecifierSet(&#39;&gt;=1.0.0,!=2.0.0&#39;)
    &lt;SpecifierSet(&#39;!=2.0.0,&gt;=1.0.0&#39;)&gt;
    &gt;&gt;&gt; SpecifierSet(&#39;&gt;=1.0.0,!=2.0.0&#39;, prereleases=False)
    &lt;SpecifierSet(&#39;!=2.0.0,&gt;=1.0.0&#39;, prereleases=False)&gt;
    &gt;&gt;&gt; SpecifierSet(&#39;&gt;=1.0.0,!=2.0.0&#39;, prereleases=True)
    &lt;SpecifierSet(&#39;!=2.0.0,&gt;=1.0.0&#39;, prereleases=True)&gt;
    &quot;&quot;&quot;
    pre = (
        f&quot;, prereleases={self.prereleases!r}&quot;
        if self._prereleases is not None
        else &quot;&quot;
    )

    return f&quot;&lt;SpecifierSet({str(self)!r}{pre})&gt;&quot;

def __str__(self) -&gt; str:
    &quot;&quot;&quot;A string representation of the specifier set that can be round-tripped.

    Note that the ordering of the individual specifiers within the set may not
    match the input string.

    &gt;&gt;&gt; str(SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;))
    &#39;!=1.0.1,&gt;=1.0.0&#39;
    &gt;&gt;&gt; str(SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=False))
    &#39;!=1.0.1,&gt;=1.0.0&#39;
    &quot;&quot;&quot;
    return &quot;,&quot;.join(sorted(str(s) for s in self._specs))

def __hash__(self) -&gt; int:
    return hash(self._specs)

def __and__(self, other: SpecifierSet | str) -&gt; SpecifierSet:
    &quot;&quot;&quot;Return a SpecifierSet which is a combination of the two sets.

    :param other: The other object to combine with.

    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) &amp; &#39;&lt;=2.0.0,!=2.0.1&#39;
    &lt;SpecifierSet(&#39;!=1.0.1,!=2.0.1,&lt;=2.0.0,&gt;=1.0.0&#39;)&gt;
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) &amp; SpecifierSet(&#39;&lt;=2.0.0,!=2.0.1&#39;)
    &lt;SpecifierSet(&#39;!=1.0.1,!=2.0.1,&lt;=2.0.0,&gt;=1.0.0&#39;)&gt;
    &quot;&quot;&quot;
    if isinstance(other, str):
        other = SpecifierSet(other)
    elif not isinstance(other, SpecifierSet):
        return NotImplemented

    specifier = SpecifierSet()
    specifier._specs = frozenset(self._specs | other._specs)

    if self._prereleases is None and other._prereleases is not None:
        specifier._prereleases = other._prereleases
    elif self._prereleases is not None and other._prereleases is None:
        specifier._prereleases = self._prereleases
    elif self._prereleases == other._prereleases:
        specifier._prereleases = self._prereleases
    else:
        raise ValueError(
            &quot;Cannot combine SpecifierSets with True and False prerelease overrides.&quot;
        )

    return specifier

def __eq__(self, other: object) -&gt; bool:
    &quot;&quot;&quot;Whether or not the two SpecifierSet-like objects are equal.

    :param other: The other object to check against.

    The value of :attr:`prereleases` is ignored.

    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;)
    True
    &gt;&gt;&gt; (SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=False) ==
    ...  SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=True))
    True
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == &quot;&gt;=1.0.0,!=1.0.1&quot;
    True
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == SpecifierSet(&quot;&gt;=1.0.0&quot;)
    False
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;) == SpecifierSet(&quot;&gt;=1.0.0,!=1.0.2&quot;)
    False
    &quot;&quot;&quot;
    if isinstance(other, (str, Specifier)):
        other = SpecifierSet(str(other))
    elif not isinstance(other, SpecifierSet):
        return NotImplemented

    return self._specs == other._specs

def __len__(self) -&gt; int:
    &quot;&quot;&quot;Returns the number of specifiers in this specifier set.&quot;&quot;&quot;
    return len(self._specs)

def __iter__(self) -&gt; Iterator[Specifier]:
    &quot;&quot;&quot;
    Returns an iterator over all the underlying :class:`Specifier` instances
    in this specifier set.

    &gt;&gt;&gt; sorted(SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;), key=str)
    [&lt;Specifier(&#39;!=1.0.1&#39;)&gt;, &lt;Specifier(&#39;&gt;=1.0.0&#39;)&gt;]
    &quot;&quot;&quot;
    return iter(self._specs)

def __contains__(self, item: UnparsedVersion) -&gt; bool:
    &quot;&quot;&quot;Return whether or not the item is contained in this specifier.

    :param item: The item to check for.

    This is used for the ``in`` operator and behaves the same as
    :meth:`contains` with no ``prereleases`` argument passed.

    &gt;&gt;&gt; &quot;1.2.3&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;)
    True
    &gt;&gt;&gt; Version(&quot;1.2.3&quot;) in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;)
    True
    &gt;&gt;&gt; &quot;1.0.1&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;)
    False
    &gt;&gt;&gt; &quot;1.3.0a1&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;)
    False
    &gt;&gt;&gt; &quot;1.3.0a1&quot; in SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=True)
    True
    &quot;&quot;&quot;
    return self.contains(item)

def contains(
    self,
    item: UnparsedVersion,
    prereleases: bool | None = None,
    installed: bool | None = None,
) -&gt; bool:
    &quot;&quot;&quot;Return whether or not the item is contained in this SpecifierSet.

    :param item:
        The item to check for, which can be a version string or a
        :class:`Version` instance.
    :param prereleases:
        Whether or not to match prereleases with this SpecifierSet. If set to
        ``None`` (the default), it uses :attr:`prereleases` to determine
        whether or not prereleases are allowed.

    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.2.3&quot;)
    True
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(Version(&quot;1.2.3&quot;))
    True
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.0.1&quot;)
    False
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.3.0a1&quot;)
    False
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;, prereleases=True).contains(&quot;1.3.0a1&quot;)
    True
    &gt;&gt;&gt; SpecifierSet(&quot;&gt;=1.0.0,!=1.0.1&quot;).contains(&quot;1.3.0a1&quot;, prereleases=True)
    True
    &quot;&quot;&quot;
    # Ensure that our item is a Version instance.
    if not isinstance(item, Version):
        item = Version(item)

    # Determine if we&#39;re forcing a prerelease or not, if we&#39;re not forcing
    # one for this particular filter call, then we&#39;ll use whatever the
    # SpecifierSet thinks for whether or not we should support prereleases.
    if prereleases is None:
        prereleases = self.prereleases

    # We can determine if we&#39;re going to allow pre-releases by looking to
    # see if any of the underlying items supports them. If none of them do
    # and this item is a pre-release then we do not allow it and we can
    # short circuit that here.
    # Note: This means that 1.0.dev1 would not be contained in something
    #       like &gt;=1.0.devabc however it would be in &gt;=1.0.debabc,&gt;0.0.dev0
    if not prereleases and item.is_prerelease:
        return False

    if installed and item.is_prerelease:
        item = Version(item.base_version)

    # We simply dispatch to the underlying specs here to make sure that the
    # given version is contained within all of them.
    # Note: This use of all() here means that an empty set of specifiers
    #       will always return True, this is an explicit design decision.
    return all(s.contains(item, prereleases=prereleases) for s in self._specs)

def filter(
    self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None
) -&gt; Iterator[UnparsedVersionVar]:
    &quot;&quot;&quot;Filter items in the given iterable, that match the specifiers in this set.

    :param iterable:
        An iterable that can contain version strings and :class:`Version` instances.
        The items in the iterable will be filtered according to the specifier.
    :param prereleases:
        Whether or not to allow prereleases in the returned iterator. If set to
        ``None`` (the default), it will be intelligently decide whether to allow
        prereleases or not (based on the :attr:`prereleases` attribute, and
        whether the only versions matching are prereleases).

    This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``
    because it implements the rule from :pep:`440` that a prerelease item
    SHOULD be accepted if no other versions match the given specifier.

    &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.3&quot;, &quot;1.5a1&quot;]))
    [&#39;1.3&#39;]
    &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.3&quot;, Version(&quot;1.4&quot;)]))
    [&#39;1.3&#39;, &lt;Version(&#39;1.4&#39;)&gt;]
    &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.2&quot;, &quot;1.5a1&quot;]))
    []
    &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;], prereleases=True))
    [&#39;1.3&#39;, &#39;1.5a1&#39;]
    &gt;&gt;&gt; list(SpecifierSet(&quot;&gt;=1.2.3&quot;, prereleases=True).filter([&quot;1.3&quot;, &quot;1.5a1&quot;]))
    [&#39;1.3&#39;, &#39;1.5a1&#39;]

    An &quot;empty&quot; SpecifierSet will filter items based on the presence of prerelease
    versions in the set.

    &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;]))
    [&#39;1.3&#39;]
    &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;).filter([&quot;1.5a1&quot;]))
    [&#39;1.5a1&#39;]
    &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;, prereleases=True).filter([&quot;1.3&quot;, &quot;1.5a1&quot;]))
    [&#39;1.3&#39;, &#39;1.5a1&#39;]
    &gt;&gt;&gt; list(SpecifierSet(&quot;&quot;).filter([&quot;1.3&quot;, &quot;1.5a1&quot;], prereleases=True))
    [&#39;1.3&#39;, &#39;1.5a1&#39;]
    &quot;&quot;&quot;
    # Determine if we&#39;re forcing a prerelease or not, if we&#39;re not forcing
    # one for this particular filter call, then we&#39;ll use whatever the
    # SpecifierSet thinks for whether or not we should support prereleases.
    if prereleases is None:
        prereleases = self.prereleases

    # If we have any specifiers, then we want to wrap our iterable in the
    # filter method for each one, this will act as a logical AND amongst
    # each specifier.
    if self._specs:
        for spec in self._specs:
            iterable = spec.filter(iterable, prereleases=bool(prereleases))
        return iter(iterable)
    # If we do not have any specifiers, then we need to have a rough filter
    # which will filter out any pre-releases, unless there are no final
    # releases.
    else:
        filtered: list[UnparsedVersionVar] = []
        found_prereleases: list[UnparsedVersionVar] = []

        for item in iterable:
            parsed_version = _coerce_version(item)

            # Store any item which is a pre-release for later unless we&#39;ve
            # already found a final version or we are accepting prereleases
            if parsed_version.is_prerelease and not prereleases:
                if not filtered:
                    found_prereleases.append(item)
            else:
                filtered.append(item)

        # If we&#39;ve found no items except for pre-releases, then we&#39;ll go
        # ahead and use the pre-releases
        if not filtered and found_prereleases and prereleases is None:
            return iter(found_prereleases)

        return iter(filtered)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>