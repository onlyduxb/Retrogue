

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/_tokenizer.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import contextlib
import re
from dataclasses import dataclass
from typing import Iterator, NoReturn</p>
<p>from .specifiers import Specifier</p>
<p>&#64;dataclass
class Token:
name: str
text: str
position: int</p>
<p>class ParserSyntaxError(Exception):
“””The provided source text could not be parsed correctly.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    message: str,
    *,
    source: str,
    span: tuple[int, int],
) -&gt; None:
    self.span = span
    self.message = message
    self.source = source

    super().__init__()

def __str__(self) -&gt; str:
    marker = &quot; &quot; * self.span[0] + &quot;~&quot; * (self.span[1] - self.span[0]) + &quot;^&quot;
    return &quot;\n    &quot;.join([self.message, self.source, marker])
</pre></div>
</div>
<p>DEFAULT_RULES: dict[str, str | re.Pattern[str]] = {
“LEFT_PARENTHESIS”: r”(“,
“RIGHT_PARENTHESIS”: r”)”,
“LEFT_BRACKET”: r”[“,
“RIGHT_BRACKET”: r”]”,
“SEMICOLON”: r”;”,
“COMMA”: r”,”,
“QUOTED_STRING”: re.compile(
r”””
(
(’<a href="#id4"><span class="problematic" id="id1">[^']</span></a><em>’)
|
(”<a href="#id5"><span class="problematic" id="id2">[^&quot;]</span></a></em>”)
)
“””,
re.VERBOSE,
),
“OP”: r”(===|==|~=|!=|&lt;=|&gt;=|&lt;|&gt;)”,
“BOOLOP”: r”\b(or|and)\b”,
“IN”: r”\bin\b”,
“NOT”: r”\bnot\b”,
“VARIABLE”: re.compile(
r”””
\b(
python_version
|python_full_version
|os[.<em>]name
|sys[.</em>]platform
|platform_(release|system)
|platform<a class="reference internal" href="#version%7Cmachine%7Cpython_implementation"><span class="xref myst">._</span></a>
|python_implementation
|implementation_(name|version)
|extras?
|dependency_groups
)\b
“””,
re.VERBOSE,
),
“SPECIFIER”: re.compile(
Specifier.<em>operator_regex_str + Specifier.<em>version_regex_str,
re.VERBOSE | re.IGNORECASE,
),
“AT”: r”&#64;”,
“URL”: r”[^ \t]+”,
“IDENTIFIER”: r”\b[a-zA-Z0-9][a-zA-Z0-9.</em>-]*\b”,
“VERSION_PREFIX_TRAIL”: r”.*”,
“VERSION_LOCAL_LABEL_TRAIL”: r”+[a-z0-9]+(?:[-</em>.][a-z0-9]+)*”,
“WS”: r”[ \t]+”,
“END”: r”$”,
}</p>
<p>class Tokenizer:
“””Context-sensitive token parsing.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Provides methods to examine the input stream to check whether the next token
matches.
&quot;&quot;&quot;

def __init__(
    self,
    source: str,
    *,
    rules: dict[str, str | re.Pattern[str]],
) -&gt; None:
    self.source = source
    self.rules: dict[str, re.Pattern[str]] = {
        name: re.compile(pattern) for name, pattern in rules.items()
    }
    self.next_token: Token | None = None
    self.position = 0

def consume(self, name: str) -&gt; None:
    &quot;&quot;&quot;Move beyond provided token name, if at current position.&quot;&quot;&quot;
    if self.check(name):
        self.read()

def check(self, name: str, *, peek: bool = False) -&gt; bool:
    &quot;&quot;&quot;Check whether the next token has the provided name.

    By default, if the check succeeds, the token *must* be read before
    another check. If `peek` is set to `True`, the token is not loaded and
    would need to be checked again.
    &quot;&quot;&quot;
    assert self.next_token is None, (
        f&quot;Cannot check for {name!r}, already have {self.next_token!r}&quot;
    )
    assert name in self.rules, f&quot;Unknown token name: {name!r}&quot;

    expression = self.rules[name]

    match = expression.match(self.source, self.position)
    if match is None:
        return False
    if not peek:
        self.next_token = Token(name, match[0], self.position)
    return True

def expect(self, name: str, *, expected: str) -&gt; Token:
    &quot;&quot;&quot;Expect a certain token name next, failing with a syntax error otherwise.

    The token is *not* read.
    &quot;&quot;&quot;
    if not self.check(name):
        raise self.raise_syntax_error(f&quot;Expected {expected}&quot;)
    return self.read()

def read(self) -&gt; Token:
    &quot;&quot;&quot;Consume the next token and return it.&quot;&quot;&quot;
    token = self.next_token
    assert token is not None

    self.position += len(token.text)
    self.next_token = None

    return token

def raise_syntax_error(
    self,
    message: str,
    *,
    span_start: int | None = None,
    span_end: int | None = None,
) -&gt; NoReturn:
    &quot;&quot;&quot;Raise ParserSyntaxError at the given position.&quot;&quot;&quot;
    span = (
        self.position if span_start is None else span_start,
        self.position if span_end is None else span_end,
    )
    raise ParserSyntaxError(
        message,
        source=self.source,
        span=span,
    )

@contextlib.contextmanager
def enclosing_tokens(
    self, open_token: str, close_token: str, *, around: str
) -&gt; Iterator[None]:
    if self.check(open_token):
        open_position = self.position
        self.read()
    else:
        open_position = None

    yield

    if open_position is None:
        return

    if not self.check(close_token):
        self.raise_syntax_error(
            f&quot;Expected matching {close_token} for {open_token}, after {around}&quot;,
            span_start=open_position,
        )

    self.read()
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>