

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/_collections.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import absolute_import</p>
<p>try:
from collections.abc import Mapping, MutableMapping
except ImportError:
from collections import Mapping, MutableMapping
try:
from threading import RLock
except ImportError:  # Platform-specific: No threads available</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class RLock:
    def __enter__(self):
        pass

    def __exit__(self, exc_type, exc_value, traceback):
        pass
</pre></div>
</div>
<p>from collections import OrderedDict</p>
<p>from .exceptions import InvalidHeader
from .packages import six
from .packages.six import iterkeys, itervalues</p>
<p><strong>all</strong> = [“RecentlyUsedContainer”, “HTTPHeaderDict”]</p>
<p>_Null = object()</p>
<p>class RecentlyUsedContainer(MutableMapping):
“””
Provides a thread-safe dict-like container which maintains up to
<code class="docutils literal notranslate"><span class="pre">maxsize</span></code> keys while throwing away the least-recently-used keys beyond
<code class="docutils literal notranslate"><span class="pre">maxsize</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param maxsize:
    Maximum number of recent elements to retain.

:param dispose_func:
    Every time an item is evicted from the container,
    ``dispose_func(value)`` is called.  Callback which will get called
&quot;&quot;&quot;

ContainerCls = OrderedDict

def __init__(self, maxsize=10, dispose_func=None):
    self._maxsize = maxsize
    self.dispose_func = dispose_func

    self._container = self.ContainerCls()
    self.lock = RLock()

def __getitem__(self, key):
    # Re-insert the item, moving it to the end of the eviction line.
    with self.lock:
        item = self._container.pop(key)
        self._container[key] = item
        return item

def __setitem__(self, key, value):
    evicted_value = _Null
    with self.lock:
        # Possibly evict the existing value of &#39;key&#39;
        evicted_value = self._container.get(key, _Null)
        self._container[key] = value

        # If we didn&#39;t evict an existing value, we might have to evict the
        # least recently used item from the beginning of the container.
        if len(self._container) &gt; self._maxsize:
            _key, evicted_value = self._container.popitem(last=False)

    if self.dispose_func and evicted_value is not _Null:
        self.dispose_func(evicted_value)

def __delitem__(self, key):
    with self.lock:
        value = self._container.pop(key)

    if self.dispose_func:
        self.dispose_func(value)

def __len__(self):
    with self.lock:
        return len(self._container)

def __iter__(self):
    raise NotImplementedError(
        &quot;Iteration over this class is unlikely to be threadsafe.&quot;
    )

def clear(self):
    with self.lock:
        # Copy pointers to all values, then wipe the mapping
        values = list(itervalues(self._container))
        self._container.clear()

    if self.dispose_func:
        for value in values:
            self.dispose_func(value)

def keys(self):
    with self.lock:
        return list(iterkeys(self._container))
</pre></div>
</div>
<p>class HTTPHeaderDict(MutableMapping):
“””
:param headers:
An iterable of field-value pairs. Must not contain multiple field names
when compared case-insensitively.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param kwargs:
    Additional field-value pairs to pass in to ``dict.update``.

A ``dict`` like container for storing HTTP Headers.

Field names are stored and compared case-insensitively in compliance with
RFC 7230. Iteration provides the first case-sensitive key seen for each
case-insensitive pair.

Using ``__setitem__`` syntax overwrites fields that compare equal
case-insensitively in order to maintain ``dict``&#39;s api. For fields that
compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``
in a loop.

If multiple fields that are equal case-insensitively are passed to the
constructor or ``.update``, the behavior is undefined and some will be
lost.

&gt;&gt;&gt; headers = HTTPHeaderDict()
&gt;&gt;&gt; headers.add(&#39;Set-Cookie&#39;, &#39;foo=bar&#39;)
&gt;&gt;&gt; headers.add(&#39;set-cookie&#39;, &#39;baz=quxx&#39;)
&gt;&gt;&gt; headers[&#39;content-length&#39;] = &#39;7&#39;
&gt;&gt;&gt; headers[&#39;SET-cookie&#39;]
&#39;foo=bar, baz=quxx&#39;
&gt;&gt;&gt; headers[&#39;Content-Length&#39;]
&#39;7&#39;
&quot;&quot;&quot;

def __init__(self, headers=None, **kwargs):
    super(HTTPHeaderDict, self).__init__()
    self._container = OrderedDict()
    if headers is not None:
        if isinstance(headers, HTTPHeaderDict):
            self._copy_from(headers)
        else:
            self.extend(headers)
    if kwargs:
        self.extend(kwargs)

def __setitem__(self, key, val):
    self._container[key.lower()] = [key, val]
    return self._container[key.lower()]

def __getitem__(self, key):
    val = self._container[key.lower()]
    return &quot;, &quot;.join(val[1:])

def __delitem__(self, key):
    del self._container[key.lower()]

def __contains__(self, key):
    return key.lower() in self._container

def __eq__(self, other):
    if not isinstance(other, Mapping) and not hasattr(other, &quot;keys&quot;):
        return False
    if not isinstance(other, type(self)):
        other = type(self)(other)
    return dict((k.lower(), v) for k, v in self.itermerged()) == dict(
        (k.lower(), v) for k, v in other.itermerged()
    )

def __ne__(self, other):
    return not self.__eq__(other)

if six.PY2:  # Python 2
    iterkeys = MutableMapping.iterkeys
    itervalues = MutableMapping.itervalues

__marker = object()

def __len__(self):
    return len(self._container)

def __iter__(self):
    # Only provide the originally cased names
    for vals in self._container.values():
        yield vals[0]

def pop(self, key, default=__marker):
    &quot;&quot;&quot;D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
    If key is not found, d is returned if given, otherwise KeyError is raised.
    &quot;&quot;&quot;
    # Using the MutableMapping function directly fails due to the private marker.
    # Using ordinary dict.pop would expose the internal structures.
    # So let&#39;s reinvent the wheel.
    try:
        value = self[key]
    except KeyError:
        if default is self.__marker:
            raise
        return default
    else:
        del self[key]
        return value

def discard(self, key):
    try:
        del self[key]
    except KeyError:
        pass

def add(self, key, val):
    &quot;&quot;&quot;Adds a (name, value) pair, doesn&#39;t overwrite the value if it already
    exists.

    &gt;&gt;&gt; headers = HTTPHeaderDict(foo=&#39;bar&#39;)
    &gt;&gt;&gt; headers.add(&#39;Foo&#39;, &#39;baz&#39;)
    &gt;&gt;&gt; headers[&#39;foo&#39;]
    &#39;bar, baz&#39;
    &quot;&quot;&quot;
    key_lower = key.lower()
    new_vals = [key, val]
    # Keep the common case aka no item present as fast as possible
    vals = self._container.setdefault(key_lower, new_vals)
    if new_vals is not vals:
        vals.append(val)

def extend(self, *args, **kwargs):
    &quot;&quot;&quot;Generic import function for any type of header-like object.
    Adapted version of MutableMapping.update in order to insert items
    with self.add instead of self.__setitem__
    &quot;&quot;&quot;
    if len(args) &gt; 1:
        raise TypeError(
            &quot;extend() takes at most 1 positional &quot;
            &quot;arguments ({0} given)&quot;.format(len(args))
        )
    other = args[0] if len(args) &gt;= 1 else ()

    if isinstance(other, HTTPHeaderDict):
        for key, val in other.iteritems():
            self.add(key, val)
    elif isinstance(other, Mapping):
        for key in other:
            self.add(key, other[key])
    elif hasattr(other, &quot;keys&quot;):
        for key in other.keys():
            self.add(key, other[key])
    else:
        for key, value in other:
            self.add(key, value)

    for key, value in kwargs.items():
        self.add(key, value)

def getlist(self, key, default=__marker):
    &quot;&quot;&quot;Returns a list of all the values for the named field. Returns an
    empty list if the key doesn&#39;t exist.&quot;&quot;&quot;
    try:
        vals = self._container[key.lower()]
    except KeyError:
        if default is self.__marker:
            return []
        return default
    else:
        return vals[1:]

def _prepare_for_method_change(self):
    &quot;&quot;&quot;
    Remove content-specific header fields before changing the request
    method to GET or HEAD according to RFC 9110, Section 15.4.
    &quot;&quot;&quot;
    content_specific_headers = [
        &quot;Content-Encoding&quot;,
        &quot;Content-Language&quot;,
        &quot;Content-Location&quot;,
        &quot;Content-Type&quot;,
        &quot;Content-Length&quot;,
        &quot;Digest&quot;,
        &quot;Last-Modified&quot;,
    ]
    for header in content_specific_headers:
        self.discard(header)
    return self

# Backwards compatibility for httplib
getheaders = getlist
getallmatchingheaders = getlist
iget = getlist

# Backwards compatibility for http.cookiejar
get_all = getlist

def __repr__(self):
    return &quot;%s(%s)&quot; % (type(self).__name__, dict(self.itermerged()))

def _copy_from(self, other):
    for key in other:
        val = other.getlist(key)
        if isinstance(val, list):
            # Don&#39;t need to convert tuples
            val = list(val)
        self._container[key.lower()] = [key] + val

def copy(self):
    clone = type(self)()
    clone._copy_from(self)
    return clone

def iteritems(self):
    &quot;&quot;&quot;Iterate over all header lines, including duplicate ones.&quot;&quot;&quot;
    for key in self:
        vals = self._container[key.lower()]
        for val in vals[1:]:
            yield vals[0], val

def itermerged(self):
    &quot;&quot;&quot;Iterate over all headers, merging duplicate ones together.&quot;&quot;&quot;
    for key in self:
        val = self._container[key.lower()]
        yield val[0], &quot;, &quot;.join(val[1:])

def items(self):
    return list(self.iteritems())

@classmethod
def from_httplib(cls, message):  # Python 2
    &quot;&quot;&quot;Read headers from a Python 2 httplib message object.&quot;&quot;&quot;
    # python2.7 does not expose a proper API for exporting multiheaders
    # efficiently. This function re-reads raw lines from the message
    # object and extracts the multiheaders properly.
    obs_fold_continued_leaders = (&quot; &quot;, &quot;\t&quot;)
    headers = []

    for line in message.headers:
        if line.startswith(obs_fold_continued_leaders):
            if not headers:
                # We received a header line that starts with OWS as described
                # in RFC-7230 S3.2.4. This indicates a multiline header, but
                # there exists no previous header to which we can attach it.
                raise InvalidHeader(
                    &quot;Header continuation with no previous header: %s&quot; % line
                )
            else:
                key, value = headers[-1]
                headers[-1] = (key, value + &quot; &quot; + line.strip())
                continue

        key, value = line.split(&quot;:&quot;, 1)
        headers.append((key, value.strip()))

    return cls(headers)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>