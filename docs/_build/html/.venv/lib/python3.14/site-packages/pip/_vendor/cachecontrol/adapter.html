

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SPDX-FileCopyrightText: 2015 Eric Larson &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SPDX-FileCopyrightText: 2015 Eric Larson</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/cachecontrol/adapter.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="spdx-filecopyrighttext-2015-eric-larson">
<h1>SPDX-FileCopyrightText: 2015 Eric Larson<a class="headerlink" href="#spdx-filecopyrighttext-2015-eric-larson" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="spdx-license-identifier-apache-2-0">
<h1>SPDX-License-Identifier: Apache-2.0<a class="headerlink" href="#spdx-license-identifier-apache-2-0" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import annotations</p>
<p>import functools
import types
import weakref
import zlib
from typing import TYPE_CHECKING, Any, Collection, Mapping</p>
<p>from pip._vendor.requests.adapters import HTTPAdapter</p>
<p>from pip._vendor.cachecontrol.cache import DictCache
from pip._vendor.cachecontrol.controller import PERMANENT_REDIRECT_STATUSES, CacheController
from pip._vendor.cachecontrol.filewrapper import CallbackFileWrapper</p>
<p>if TYPE_CHECKING:
from pip._vendor.requests import PreparedRequest, Response
from pip._vendor.urllib3 import HTTPResponse</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pip._vendor.cachecontrol.cache import BaseCache
from pip._vendor.cachecontrol.heuristics import BaseHeuristic
from pip._vendor.cachecontrol.serialize import Serializer
</pre></div>
</div>
<p>class CacheControlAdapter(HTTPAdapter):
invalidating_methods = {“PUT”, “PATCH”, “DELETE”}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    cache: BaseCache | None = None,
    cache_etags: bool = True,
    controller_class: type[CacheController] | None = None,
    serializer: Serializer | None = None,
    heuristic: BaseHeuristic | None = None,
    cacheable_methods: Collection[str] | None = None,
    *args: Any,
    **kw: Any,
) -&gt; None:
    super().__init__(*args, **kw)
    self.cache = DictCache() if cache is None else cache
    self.heuristic = heuristic
    self.cacheable_methods = cacheable_methods or (&quot;GET&quot;,)

    controller_factory = controller_class or CacheController
    self.controller = controller_factory(
        self.cache, cache_etags=cache_etags, serializer=serializer
    )

def send(
    self,
    request: PreparedRequest,
    stream: bool = False,
    timeout: None | float | tuple[float, float] | tuple[float, None] = None,
    verify: bool | str = True,
    cert: (None | bytes | str | tuple[bytes | str, bytes | str]) = None,
    proxies: Mapping[str, str] | None = None,
    cacheable_methods: Collection[str] | None = None,
) -&gt; Response:
    &quot;&quot;&quot;
    Send a request. Use the request information to see if it
    exists in the cache and cache the response if we need to and can.
    &quot;&quot;&quot;
    cacheable = cacheable_methods or self.cacheable_methods
    if request.method in cacheable:
        try:
            cached_response = self.controller.cached_request(request)
        except zlib.error:
            cached_response = None
        if cached_response:
            return self.build_response(request, cached_response, from_cache=True)

        # check for etags and add headers if appropriate
        request.headers.update(self.controller.conditional_headers(request))

    resp = super().send(request, stream, timeout, verify, cert, proxies)

    return resp

def build_response(  # type: ignore[override]
    self,
    request: PreparedRequest,
    response: HTTPResponse,
    from_cache: bool = False,
    cacheable_methods: Collection[str] | None = None,
) -&gt; Response:
    &quot;&quot;&quot;
    Build a response by making a request or using the cache.

    This will end up calling send and returning a potentially
    cached response
    &quot;&quot;&quot;
    cacheable = cacheable_methods or self.cacheable_methods
    if not from_cache and request.method in cacheable:
        # Check for any heuristics that might update headers
        # before trying to cache.
        if self.heuristic:
            response = self.heuristic.apply(response)

        # apply any expiration heuristics
        if response.status == 304:
            # We must have sent an ETag request. This could mean
            # that we&#39;ve been expired already or that we simply
            # have an etag. In either case, we want to try and
            # update the cache if that is the case.
            cached_response = self.controller.update_cached_response(
                request, response
            )

            if cached_response is not response:
                from_cache = True

            # We are done with the server response, read a
            # possible response body (compliant servers will
            # not return one, but we cannot be 100% sure) and
            # release the connection back to the pool.
            response.read(decode_content=False)
            response.release_conn()

            response = cached_response

        # We always cache the 301 responses
        elif int(response.status) in PERMANENT_REDIRECT_STATUSES:
            self.controller.cache_response(request, response)
        else:
            # Wrap the response file with a wrapper that will cache the
            #   response when the stream has been consumed.
            response._fp = CallbackFileWrapper(  # type: ignore[assignment]
                response._fp,  # type: ignore[arg-type]
                functools.partial(
                    self.controller.cache_response, request, weakref.ref(response)
                ),
            )
            if response.chunked:
                super_update_chunk_length = response.__class__._update_chunk_length

                def _update_chunk_length(
                    weak_self: weakref.ReferenceType[HTTPResponse],
                ) -&gt; None:
                    self = weak_self()
                    if self is None:
                        return

                    super_update_chunk_length(self)
                    if self.chunk_left == 0:
                        self._fp._close()  # type: ignore[union-attr]

                response._update_chunk_length = functools.partial(  # type: ignore[method-assign]
                    _update_chunk_length, weakref.ref(response)
                )

    resp: Response = super().build_response(request, response)

    # See if we should invalidate the cache.
    if request.method in self.invalidating_methods and resp.ok:
        assert request.url is not None
        cache_url = self.controller.cache_url(request.url)
        self.cache.delete(cache_url)

    # Give the request a from_cache attr to let people use it
    resp.from_cache = from_cache  # type: ignore[attr-defined]

    return resp

def close(self) -&gt; None:
    self.cache.close()
    super().close()  # type: ignore[no-untyped-call]
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>