

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notes on the relationship between the provider, the factory, and the &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Notes on the relationship between the provider, the factory, and the</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/resolution/resolvelib/provider.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import math
from collections.abc import Iterable, Iterator, Mapping, Sequence
from functools import cache
from typing import (
TYPE_CHECKING,
TypeVar,
)</p>
<p>from pip._vendor.resolvelib.providers import AbstractProvider</p>
<p>from pip._internal.req.req_install import InstallRequirement</p>
<p>from .base import Candidate, Constraint, Requirement
from .candidates import REQUIRES_PYTHON_IDENTIFIER
from .factory import Factory
from .requirements import ExplicitRequirement</p>
<p>if TYPE_CHECKING:
from pip._vendor.resolvelib.providers import Preference
from pip._vendor.resolvelib.resolvers import RequirementInformation</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PreferenceInformation = RequirementInformation[Requirement, Candidate]

_ProviderBase = AbstractProvider[Requirement, Candidate, str]
</pre></div>
</div>
<p>else:
_ProviderBase = AbstractProvider</p>
<section id="notes-on-the-relationship-between-the-provider-the-factory-and-the">
<h1>Notes on the relationship between the provider, the factory, and the<a class="headerlink" href="#notes-on-the-relationship-between-the-provider-the-factory-and-the" title="Link to this heading"></a></h1>
</section>
<section id="candidate-and-requirement-classes">
<h1>candidate and requirement classes.<a class="headerlink" href="#candidate-and-requirement-classes" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="the-provider-is-a-direct-implementation-of-the-resolvelib-class-its-role">
<h1>The provider is a direct implementation of the resolvelib class. Its role<a class="headerlink" href="#the-provider-is-a-direct-implementation-of-the-resolvelib-class-its-role" title="Link to this heading"></a></h1>
</section>
<section id="is-to-deliver-the-api-that-resolvelib-expects">
<h1>is to deliver the API that resolvelib expects.<a class="headerlink" href="#is-to-deliver-the-api-that-resolvelib-expects" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
</section>
<section id="rather-than-work-with-completely-abstract-requirement-and-candidate">
<h1>Rather than work with completely abstract “requirement” and “candidate”<a class="headerlink" href="#rather-than-work-with-completely-abstract-requirement-and-candidate" title="Link to this heading"></a></h1>
</section>
<section id="concepts-as-resolvelib-does-pip-has-concrete-classes-implementing-these-two">
<h1>concepts as resolvelib does, pip has concrete classes implementing these two<a class="headerlink" href="#concepts-as-resolvelib-does-pip-has-concrete-classes-implementing-these-two" title="Link to this heading"></a></h1>
</section>
<section id="ideas-the-api-of-requirement-and-candidate-objects-are-defined-in-the-base">
<h1>ideas. The API of Requirement and Candidate objects are defined in the base<a class="headerlink" href="#ideas-the-api-of-requirement-and-candidate-objects-are-defined-in-the-base" title="Link to this heading"></a></h1>
</section>
<section id="classes-but-essentially-map-fairly-directly-to-the-equivalent-provider">
<h1>classes, but essentially map fairly directly to the equivalent provider<a class="headerlink" href="#classes-but-essentially-map-fairly-directly-to-the-equivalent-provider" title="Link to this heading"></a></h1>
</section>
<section id="methods-in-particular-find-matches-and-is-satisfied-by-are">
<h1>methods. In particular, <code class="docutils literal notranslate"><span class="pre">find_matches</span></code> and <code class="docutils literal notranslate"><span class="pre">is_satisfied_by</span></code> are<a class="headerlink" href="#methods-in-particular-find-matches-and-is-satisfied-by-are" title="Link to this heading"></a></h1>
</section>
<section id="requirement-methods-and-get-dependencies-is-a-candidate-method">
<h1>requirement methods, and <code class="docutils literal notranslate"><span class="pre">get_dependencies</span></code> is a candidate method.<a class="headerlink" href="#requirement-methods-and-get-dependencies-is-a-candidate-method" title="Link to this heading"></a></h1>
</section>
<section id="id3">
<h1><a class="headerlink" href="#id3" title="Link to this heading"></a></h1>
</section>
<section id="the-factory-is-the-interface-to-pip-s-internal-mechanisms-it-is-stateless">
<h1>The factory is the interface to pip’s internal mechanisms. It is stateless,<a class="headerlink" href="#the-factory-is-the-interface-to-pip-s-internal-mechanisms-it-is-stateless" title="Link to this heading"></a></h1>
</section>
<section id="and-is-created-by-the-resolver-and-held-as-a-property-of-the-provider-it-is">
<h1>and is created by the resolver and held as a property of the provider. It is<a class="headerlink" href="#and-is-created-by-the-resolver-and-held-as-a-property-of-the-provider-it-is" title="Link to this heading"></a></h1>
</section>
<section id="responsible-for-creating-requirement-and-candidate-objects-and-provides">
<h1>responsible for creating Requirement and Candidate objects, and provides<a class="headerlink" href="#responsible-for-creating-requirement-and-candidate-objects-and-provides" title="Link to this heading"></a></h1>
</section>
<section id="services-to-those-objects-access-to-pip-s-finder-and-preparer">
<h1>services to those objects (access to pip’s finder and preparer).<a class="headerlink" href="#services-to-those-objects-access-to-pip-s-finder-and-preparer" title="Link to this heading"></a></h1>
<p>D = TypeVar(“D”)
V = TypeVar(“V”)</p>
<p>def _get_with_identifier(
mapping: Mapping[str, V],
identifier: str,
default: D,
) -&gt; D | V:
“””Get item from a package name lookup mapping with a resolver identifier.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This extra logic is needed when the target mapping is keyed by package
name, which cannot be directly looked up with an identifier (which may
contain requested extras). Additional logic is added to also look up a value
by &quot;cleaning up&quot; the extras from the identifier.
&quot;&quot;&quot;
if identifier in mapping:
    return mapping[identifier]
# HACK: Theoretically we should check whether this identifier is a valid
# &quot;NAME[EXTRAS]&quot; format, and parse out the name part with packaging or
# some regular expression. But since pip&#39;s resolver only spits out three
# kinds of identifiers: normalized PEP 503 names, normalized names plus
# extras, and Requires-Python, we can cheat a bit here.
name, open_bracket, _ = identifier.partition(&quot;[&quot;)
if open_bracket and name in mapping:
    return mapping[name]
return default
</pre></div>
</div>
<p>class PipProvider(_ProviderBase):
“””Pip’s provider implementation for resolvelib.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:params constraints: A mapping of constraints specified by the user. Keys
    are canonicalized project names.
:params ignore_dependencies: Whether the user specified ``--no-deps``.
:params upgrade_strategy: The user-specified upgrade strategy.
:params user_requested: A set of canonicalized package names that the user
    supplied for pip to install/upgrade.
&quot;&quot;&quot;

def __init__(
    self,
    factory: Factory,
    constraints: dict[str, Constraint],
    ignore_dependencies: bool,
    upgrade_strategy: str,
    user_requested: dict[str, int],
) -&gt; None:
    self._factory = factory
    self._constraints = constraints
    self._ignore_dependencies = ignore_dependencies
    self._upgrade_strategy = upgrade_strategy
    self._user_requested = user_requested

@property
def constraints(self) -&gt; dict[str, Constraint]:
    &quot;&quot;&quot;Public view of user-specified constraints.

    Exposes the provider&#39;s constraints mapping without encouraging
    external callers to reach into private attributes.
    &quot;&quot;&quot;
    return self._constraints

def identify(self, requirement_or_candidate: Requirement | Candidate) -&gt; str:
    return requirement_or_candidate.name

def narrow_requirement_selection(
    self,
    identifiers: Iterable[str],
    resolutions: Mapping[str, Candidate],
    candidates: Mapping[str, Iterator[Candidate]],
    information: Mapping[str, Iterator[PreferenceInformation]],
    backtrack_causes: Sequence[PreferenceInformation],
) -&gt; Iterable[str]:
    &quot;&quot;&quot;Produce a subset of identifiers that should be considered before others.

    Currently pip narrows the following selection:
        * Requires-Python, if present is always returned by itself
        * Backtrack causes are considered next because they can be identified
          in linear time here, whereas because get_preference() is called
          for each identifier, it would be quadratic to check for them there.
          Further, the current backtrack causes likely need to be resolved
          before other requirements as a resolution can&#39;t be found while
          there is a conflict.
    &quot;&quot;&quot;
    backtrack_identifiers = set()
    for info in backtrack_causes:
        backtrack_identifiers.add(info.requirement.name)
        if info.parent is not None:
            backtrack_identifiers.add(info.parent.name)

    current_backtrack_causes = []
    for identifier in identifiers:
        # Requires-Python has only one candidate and the check is basically
        # free, so we always do it first to avoid needless work if it fails.
        # This skips calling get_preference() for all other identifiers.
        if identifier == REQUIRES_PYTHON_IDENTIFIER:
            return [identifier]

        # Check if this identifier is a backtrack cause
        if identifier in backtrack_identifiers:
            current_backtrack_causes.append(identifier)
            continue

    if current_backtrack_causes:
        return current_backtrack_causes

    return identifiers

def get_preference(
    self,
    identifier: str,
    resolutions: Mapping[str, Candidate],
    candidates: Mapping[str, Iterator[Candidate]],
    information: Mapping[str, Iterable[PreferenceInformation]],
    backtrack_causes: Sequence[PreferenceInformation],
) -&gt; Preference:
    &quot;&quot;&quot;Produce a sort key for given requirement based on preference.

    The lower the return value is, the more preferred this group of
    arguments is.

    Currently pip considers the following in order:

    * Any requirement that is &quot;direct&quot;, e.g., points to an explicit URL.
    * Any requirement that is &quot;pinned&quot;, i.e., contains the operator ``===``
      or ``==`` without a wildcard.
    * Any requirement that imposes an upper version limit, i.e., contains the
      operator ``&lt;``, ``&lt;=``, ``~=``, or ``==`` with a wildcard. Because
      pip prioritizes the latest version, preferring explicit upper bounds
      can rule out infeasible candidates sooner. This does not imply that
      upper bounds are good practice; they can make dependency management
      and resolution harder.
    * Order user-specified requirements as they are specified, placing
      other requirements afterward.
    * Any &quot;non-free&quot; requirement, i.e., one that contains at least one
      operator, such as ``&gt;=`` or ``!=``.
    * Alphabetical order for consistency (aids debuggability).
    &quot;&quot;&quot;
    try:
        next(iter(information[identifier]))
    except StopIteration:
        # There is no information for this identifier, so there&#39;s no known
        # candidates.
        has_information = False
    else:
        has_information = True

    if not has_information:
        direct = False
        ireqs: tuple[InstallRequirement | None, ...] = ()
    else:
        # Go through the information and for each requirement,
        # check if it&#39;s explicit (e.g., a direct link) and get the
        # InstallRequirement (the second element) from get_candidate_lookup()
        directs, ireqs = zip(
            *(
                (isinstance(r, ExplicitRequirement), r.get_candidate_lookup()[1])
                for r, _ in information[identifier]
            )
        )
        direct = any(directs)

    operators: list[tuple[str, str]] = [
        (specifier.operator, specifier.version)
        for specifier_set in (ireq.specifier for ireq in ireqs if ireq)
        for specifier in specifier_set
    ]

    pinned = any(((op[:2] == &quot;==&quot;) and (&quot;*&quot; not in ver)) for op, ver in operators)
    upper_bounded = any(
        ((op in (&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;~=&quot;)) or (op == &quot;==&quot; and &quot;*&quot; in ver))
        for op, ver in operators
    )
    unfree = bool(operators)
    requested_order = self._user_requested.get(identifier, math.inf)

    return (
        not direct,
        not pinned,
        not upper_bounded,
        requested_order,
        not unfree,
        identifier,
    )

def find_matches(
    self,
    identifier: str,
    requirements: Mapping[str, Iterator[Requirement]],
    incompatibilities: Mapping[str, Iterator[Candidate]],
) -&gt; Iterable[Candidate]:
    def _eligible_for_upgrade(identifier: str) -&gt; bool:
        &quot;&quot;&quot;Are upgrades allowed for this project?

        This checks the upgrade strategy, and whether the project was one
        that the user specified in the command line, in order to decide
        whether we should upgrade if there&#39;s a newer version available.

        (Note that we don&#39;t need access to the `--upgrade` flag, because
        an upgrade strategy of &quot;to-satisfy-only&quot; means that `--upgrade`
        was not specified).
        &quot;&quot;&quot;
        if self._upgrade_strategy == &quot;eager&quot;:
            return True
        elif self._upgrade_strategy == &quot;only-if-needed&quot;:
            user_order = _get_with_identifier(
                self._user_requested,
                identifier,
                default=None,
            )
            return user_order is not None
        return False

    constraint = _get_with_identifier(
        self._constraints,
        identifier,
        default=Constraint.empty(),
    )
    return self._factory.find_candidates(
        identifier=identifier,
        requirements=requirements,
        constraint=constraint,
        prefers_installed=(not _eligible_for_upgrade(identifier)),
        incompatibilities=incompatibilities,
        is_satisfied_by=self.is_satisfied_by,
    )

@staticmethod
@cache
def is_satisfied_by(requirement: Requirement, candidate: Candidate) -&gt; bool:
    return requirement.is_satisfied_by(candidate)

def get_dependencies(self, candidate: Candidate) -&gt; Iterable[Requirement]:
    with_requires = not self._ignore_dependencies
    # iter_dependencies() can perform nontrivial work so delay until needed.
    return (r for r in candidate.iter_dependencies(with_requires) if r is not None)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>