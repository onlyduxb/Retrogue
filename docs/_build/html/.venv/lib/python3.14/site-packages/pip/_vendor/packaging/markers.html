

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>This file is dual licensed under the terms of the Apache License, Version &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">This file is dual licensed under the terms of the Apache License, Version</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/markers.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version">
<h1>This file is dual licensed under the terms of the Apache License, Version<a class="headerlink" href="#this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version" title="Link to this heading"></a></h1>
</section>
<section id="and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository">
<h1>2.0, and the BSD License. See the LICENSE file in the root of this repository<a class="headerlink" href="#and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository" title="Link to this heading"></a></h1>
</section>
<section id="for-complete-details">
<h1>for complete details.<a class="headerlink" href="#for-complete-details" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import annotations</p>
<p>import operator
import os
import platform
import sys
from typing import AbstractSet, Any, Callable, Literal, TypedDict, Union, cast</p>
<p>from ._parser import MarkerAtom, MarkerList, Op, Value, Variable
from ._parser import parse_marker as _parse_marker
from ._tokenizer import ParserSyntaxError
from .specifiers import InvalidSpecifier, Specifier
from .utils import canonicalize_name</p>
<p><strong>all</strong> = [
“EvaluateContext”,
“InvalidMarker”,
“Marker”,
“UndefinedComparison”,
“UndefinedEnvironmentName”,
“default_environment”,
]</p>
<p>Operator = Callable[[str, Union[str, AbstractSet[str]]], bool]
EvaluateContext = Literal[“metadata”, “lock_file”, “requirement”]
MARKERS_ALLOWING_SET = {“extras”, “dependency_groups”}</p>
<p>class InvalidMarker(ValueError):
“””
An invalid marker was found, users should refer to PEP 508.
“””</p>
<p>class UndefinedComparison(ValueError):
“””
An invalid operation was attempted on a value that doesn’t support it.
“””</p>
<p>class UndefinedEnvironmentName(ValueError):
“””
A name was attempted to be used that does not exist inside of the
environment.
“””</p>
<p>class Environment(TypedDict):
implementation_name: str
“””The implementation’s identifier, e.g. <code class="docutils literal notranslate"><span class="pre">'cpython'</span></code>.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>implementation_version: str
&quot;&quot;&quot;
The implementation&#39;s version, e.g. ``&#39;3.13.0a2&#39;`` for CPython 3.13.0a2, or
``&#39;7.3.13&#39;`` for PyPy3.10 v7.3.13.
&quot;&quot;&quot;

os_name: str
&quot;&quot;&quot;
The value of :py:data:`os.name`. The name of the operating system dependent module
imported, e.g. ``&#39;posix&#39;``.
&quot;&quot;&quot;

platform_machine: str
&quot;&quot;&quot;
Returns the machine type, e.g. ``&#39;i386&#39;``.

An empty string if the value cannot be determined.
&quot;&quot;&quot;

platform_release: str
&quot;&quot;&quot;
The system&#39;s release, e.g. ``&#39;2.2.0&#39;`` or ``&#39;NT&#39;``.

An empty string if the value cannot be determined.
&quot;&quot;&quot;

platform_system: str
&quot;&quot;&quot;
The system/OS name, e.g. ``&#39;Linux&#39;``, ``&#39;Windows&#39;`` or ``&#39;Java&#39;``.

An empty string if the value cannot be determined.
&quot;&quot;&quot;

platform_version: str
&quot;&quot;&quot;
The system&#39;s release version, e.g. ``&#39;#3 on degas&#39;``.

An empty string if the value cannot be determined.
&quot;&quot;&quot;

python_full_version: str
&quot;&quot;&quot;
The Python version as string ``&#39;major.minor.patchlevel&#39;``.

Note that unlike the Python :py:data:`sys.version`, this value will always include
the patchlevel (it defaults to 0).
&quot;&quot;&quot;

platform_python_implementation: str
&quot;&quot;&quot;
A string identifying the Python implementation, e.g. ``&#39;CPython&#39;``.
&quot;&quot;&quot;

python_version: str
&quot;&quot;&quot;The Python version as string ``&#39;major.minor&#39;``.&quot;&quot;&quot;

sys_platform: str
&quot;&quot;&quot;
This string contains a platform identifier that can be used to append
platform-specific components to :py:data:`sys.path`, for instance.

For Unix systems, except on Linux and AIX, this is the lowercased OS name as
returned by ``uname -s`` with the first part of the version as returned by
``uname -r`` appended, e.g. ``&#39;sunos5&#39;`` or ``&#39;freebsd8&#39;``, at the time when Python
was built.
&quot;&quot;&quot;
</pre></div>
</div>
<p>def _normalize_extra_values(results: Any) -&gt; Any:
“””
Normalize extra values.
“””
if isinstance(results[0], tuple):
lhs, op, rhs = results[0]
if isinstance(lhs, Variable) and lhs.value == “extra”:
normalized_extra = canonicalize_name(rhs.value)
rhs = Value(normalized_extra)
elif isinstance(rhs, Variable) and rhs.value == “extra”:
normalized_extra = canonicalize_name(lhs.value)
lhs = Value(normalized_extra)
results[0] = lhs, op, rhs
return results</p>
<p>def _format_marker(
marker: list[str] | MarkerAtom | str, first: bool | None = True
) -&gt; str:
assert isinstance(marker, (list, tuple, str))</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Sometimes we have a structure like [[...]] which is a single item list
# where the single item is itself it&#39;s own list. In that case we want skip
# the rest of this function so that we don&#39;t get extraneous () on the
# outside.
if (
    isinstance(marker, list)
    and len(marker) == 1
    and isinstance(marker[0], (list, tuple))
):
    return _format_marker(marker[0])

if isinstance(marker, list):
    inner = (_format_marker(m, first=False) for m in marker)
    if first:
        return &quot; &quot;.join(inner)
    else:
        return &quot;(&quot; + &quot; &quot;.join(inner) + &quot;)&quot;
elif isinstance(marker, tuple):
    return &quot; &quot;.join([m.serialize() for m in marker])
else:
    return marker
</pre></div>
</div>
<p>_operators: dict[str, Operator] = {
“in”: lambda lhs, rhs: lhs in rhs,
“not in”: lambda lhs, rhs: lhs not in rhs,
“&lt;”: operator.lt,
“&lt;=”: operator.le,
“==”: operator.eq,
“!=”: operator.ne,
“&gt;=”: operator.ge,
“&gt;”: operator.gt,
}</p>
<p>def _eval_op(lhs: str, op: Op, rhs: str | AbstractSet[str]) -&gt; bool:
if isinstance(rhs, str):
try:
spec = Specifier(“”.join([op.serialize(), rhs]))
except InvalidSpecifier:
pass
else:
return spec.contains(lhs, prereleases=True)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>oper: Operator | None = _operators.get(op.serialize())
if oper is None:
    raise UndefinedComparison(f&quot;Undefined {op!r} on {lhs!r} and {rhs!r}.&quot;)

return oper(lhs, rhs)
</pre></div>
</div>
<p>def _normalize(
lhs: str, rhs: str | AbstractSet[str], key: str
) -&gt; tuple[str, str | AbstractSet[str]]:
# PEP 685 – Comparison of extra names for optional distribution dependencies
# https://peps.python.org/pep-0685/
# &gt; When comparing extra names, tools MUST normalize the names being
# &gt; compared using the semantics outlined in PEP 503 for names
if key == “extra”:
assert isinstance(rhs, str), “extra value must be a string”
return (canonicalize_name(lhs), canonicalize_name(rhs))
if key in MARKERS_ALLOWING_SET:
if isinstance(rhs, str):  # pragma: no cover
return (canonicalize_name(lhs), canonicalize_name(rhs))
else:
return (canonicalize_name(lhs), {canonicalize_name(v) for v in rhs})</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># other environment markers don&#39;t have such standards
return lhs, rhs
</pre></div>
</div>
<p>def _evaluate_markers(
markers: MarkerList, environment: dict[str, str | AbstractSet[str]]
) -&gt; bool:
groups: list[list[bool]] = [[]]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for marker in markers:
    assert isinstance(marker, (list, tuple, str))

    if isinstance(marker, list):
        groups[-1].append(_evaluate_markers(marker, environment))
    elif isinstance(marker, tuple):
        lhs, op, rhs = marker

        if isinstance(lhs, Variable):
            environment_key = lhs.value
            lhs_value = environment[environment_key]
            rhs_value = rhs.value
        else:
            lhs_value = lhs.value
            environment_key = rhs.value
            rhs_value = environment[environment_key]
        assert isinstance(lhs_value, str), &quot;lhs must be a string&quot;
        lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)
        groups[-1].append(_eval_op(lhs_value, op, rhs_value))
    else:
        assert marker in [&quot;and&quot;, &quot;or&quot;]
        if marker == &quot;or&quot;:
            groups.append([])

return any(all(item) for item in groups)
</pre></div>
</div>
<p>def format_full_version(info: sys._version_info) -&gt; str:
version = f”{info.major}.{info.minor}.{info.micro}”
kind = info.releaselevel
if kind != “final”:
version += kind[0] + str(info.serial)
return version</p>
<p>def default_environment() -&gt; Environment:
iver = format_full_version(sys.implementation.version)
implementation_name = sys.implementation.name
return {
“implementation_name”: implementation_name,
“implementation_version”: iver,
“os_name”: os.name,
“platform_machine”: platform.machine(),
“platform_release”: platform.release(),
“platform_system”: platform.system(),
“platform_version”: platform.version(),
“python_full_version”: platform.python_version(),
“platform_python_implementation”: platform.python_implementation(),
“python_version”: “.”.join(platform.python_version_tuple()[:2]),
“sys_platform”: sys.platform,
}</p>
<p>class Marker:
def <strong>init</strong>(self, marker: str) -&gt; None:
# Note: We create a Marker object without calling this constructor in
#       packaging.requirements.Requirement. If any additional logic is
#       added here, make sure to mirror/adapt Requirement.
try:
self._markers = _normalize_extra_values(_parse_marker(marker))
# The attribute <code class="docutils literal notranslate"><span class="pre">_markers</span></code> can be described in terms of a recursive type:
# MarkerList = List[Union[Tuple[Node, …], str, MarkerList]]
#
# For example, the following expression:
# python_version &gt; “3.6” or (python_version == “3.6” and os_name == “unix”)
#
# is parsed into:
# [
#     (&lt;Variable(‘python_version’)&gt;, &lt;Op(‘&gt;’)&gt;, &lt;Value(‘3.6’)&gt;),
#     ‘and’,
#     [
#         (&lt;Variable(‘python_version’)&gt;, &lt;Op(‘==’)&gt;, &lt;Value(‘3.6’)&gt;),
#         ‘or’,
#         (&lt;Variable(‘os_name’)&gt;, &lt;Op(‘==’)&gt;, &lt;Value(‘unix’)&gt;)
#     ]
# ]
except ParserSyntaxError as e:
raise InvalidMarker(str(e)) from e</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __str__(self) -&gt; str:
    return _format_marker(self._markers)

def __repr__(self) -&gt; str:
    return f&quot;&lt;Marker(&#39;{self}&#39;)&gt;&quot;

def __hash__(self) -&gt; int:
    return hash((self.__class__.__name__, str(self)))

def __eq__(self, other: Any) -&gt; bool:
    if not isinstance(other, Marker):
        return NotImplemented

    return str(self) == str(other)

def evaluate(
    self,
    environment: dict[str, str] | None = None,
    context: EvaluateContext = &quot;metadata&quot;,
) -&gt; bool:
    &quot;&quot;&quot;Evaluate a marker.

    Return the boolean from evaluating the given marker against the
    environment. environment is an optional argument to override all or
    part of the determined environment. The *context* parameter specifies what
    context the markers are being evaluated for, which influences what markers
    are considered valid. Acceptable values are &quot;metadata&quot; (for core metadata;
    default), &quot;lock_file&quot;, and &quot;requirement&quot; (i.e. all other situations).

    The environment is determined from the current Python process.
    &quot;&quot;&quot;
    current_environment = cast(
        &quot;dict[str, str | AbstractSet[str]]&quot;, default_environment()
    )
    if context == &quot;lock_file&quot;:
        current_environment.update(
            extras=frozenset(), dependency_groups=frozenset()
        )
    elif context == &quot;metadata&quot;:
        current_environment[&quot;extra&quot;] = &quot;&quot;
    if environment is not None:
        current_environment.update(environment)
        # The API used to allow setting extra to None. We need to handle this
        # case for backwards compatibility.
        if &quot;extra&quot; in current_environment and current_environment[&quot;extra&quot;] is None:
            current_environment[&quot;extra&quot;] = &quot;&quot;

    return _evaluate_markers(
        self._markers, _repair_python_full_version(current_environment)
    )
</pre></div>
</div>
<p>def _repair_python_full_version(
env: dict[str, str | AbstractSet[str]],
) -&gt; dict[str, str | AbstractSet[str]]:
“””
Work around platform.python_version() returning something that is not PEP 440
compliant for non-tagged Python builds.
“””
python_full_version = cast(str, env[“python_full_version”])
if python_full_version.endswith(“+”):
env[“python_full_version”] = f”{python_full_version}local”
return env</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>