

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/cache.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Cache Management”””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import hashlib
import json
import logging
import os
from pathlib import Path
from typing import Any</p>
<p>from pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version
from pip._vendor.packaging.utils import canonicalize_name</p>
<p>from pip._internal.exceptions import InvalidWheelFilename
from pip._internal.models.direct_url import DirectUrl
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
from pip._internal.utils.urls import path_to_url</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>ORIGIN_JSON_NAME = “origin.json”</p>
<p>def _hash_dict(d: dict[str, str]) -&gt; str:
“””Return a stable sha224 of a dictionary.”””
s = json.dumps(d, sort_keys=True, separators=(“,”, “:”), ensure_ascii=True)
return hashlib.sha224(s.encode(“ascii”)).hexdigest()</p>
<p>class Cache:
“””An abstract class - provides cache directories for data from links</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param cache_dir: The root of the cache.
&quot;&quot;&quot;

def __init__(self, cache_dir: str) -&gt; None:
    super().__init__()
    assert not cache_dir or os.path.isabs(cache_dir)
    self.cache_dir = cache_dir or None

def _get_cache_path_parts(self, link: Link) -&gt; list[str]:
    &quot;&quot;&quot;Get parts of part that must be os.path.joined with cache_dir&quot;&quot;&quot;

    # We want to generate an url to use as our cache key, we don&#39;t want to
    # just reuse the URL because it might have other items in the fragment
    # and we don&#39;t care about those.
    key_parts = {&quot;url&quot;: link.url_without_fragment}
    if link.hash_name is not None and link.hash is not None:
        key_parts[link.hash_name] = link.hash
    if link.subdirectory_fragment:
        key_parts[&quot;subdirectory&quot;] = link.subdirectory_fragment

    # Include interpreter name, major and minor version in cache key
    # to cope with ill-behaved sdists that build a different wheel
    # depending on the python version their setup.py is being run on,
    # and don&#39;t encode the difference in compatibility tags.
    # https://github.com/pypa/pip/issues/7296
    key_parts[&quot;interpreter_name&quot;] = interpreter_name()
    key_parts[&quot;interpreter_version&quot;] = interpreter_version()

    # Encode our key url with sha224, we&#39;ll use this because it has similar
    # security properties to sha256, but with a shorter total output (and
    # thus less secure). However the differences don&#39;t make a lot of
    # difference for our use case here.
    hashed = _hash_dict(key_parts)

    # We want to nest the directories some to prevent having a ton of top
    # level directories where we might run out of sub directories on some
    # FS.
    parts = [hashed[:2], hashed[2:4], hashed[4:6], hashed[6:]]

    return parts

def _get_candidates(self, link: Link, canonical_package_name: str) -&gt; list[Any]:
    can_not_cache = not self.cache_dir or not canonical_package_name or not link
    if can_not_cache:
        return []

    path = self.get_path_for_link(link)
    if os.path.isdir(path):
        return [(candidate, path) for candidate in os.listdir(path)]
    return []

def get_path_for_link(self, link: Link) -&gt; str:
    &quot;&quot;&quot;Return a directory to store cached items in for link.&quot;&quot;&quot;
    raise NotImplementedError()

def get(
    self,
    link: Link,
    package_name: str | None,
    supported_tags: list[Tag],
) -&gt; Link:
    &quot;&quot;&quot;Returns a link to a cached item if it exists, otherwise returns the
    passed link.
    &quot;&quot;&quot;
    raise NotImplementedError()
</pre></div>
</div>
<p>class SimpleWheelCache(Cache):
“””A cache of wheels for future installs.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, cache_dir: str) -&gt; None:
    super().__init__(cache_dir)

def get_path_for_link(self, link: Link) -&gt; str:
    &quot;&quot;&quot;Return a directory to store cached wheels for link

    Because there are M wheels for any one sdist, we provide a directory
    to cache them in, and then consult that directory when looking up
    cache hits.

    We only insert things into the cache if they have plausible version
    numbers, so that we don&#39;t contaminate the cache with things that were
    not unique. E.g. ./package might have dozens of installs done for it
    and build a version of 0.0...and if we built and cached a wheel, we&#39;d
    end up using the same wheel even if the source has been edited.

    :param link: The link of the sdist for which this will cache wheels.
    &quot;&quot;&quot;
    parts = self._get_cache_path_parts(link)
    assert self.cache_dir
    # Store wheels within the root cache_dir
    return os.path.join(self.cache_dir, &quot;wheels&quot;, *parts)

def get(
    self,
    link: Link,
    package_name: str | None,
    supported_tags: list[Tag],
) -&gt; Link:
    candidates = []

    if not package_name:
        return link

    canonical_package_name = canonicalize_name(package_name)
    for wheel_name, wheel_dir in self._get_candidates(link, canonical_package_name):
        try:
            wheel = Wheel(wheel_name)
        except InvalidWheelFilename:
            continue
        if wheel.name != canonical_package_name:
            logger.debug(
                &quot;Ignoring cached wheel %s for %s as it &quot;
                &quot;does not match the expected distribution name %s.&quot;,
                wheel_name,
                link,
                package_name,
            )
            continue
        if not wheel.supported(supported_tags):
            # Built for a different python/arch/etc
            continue
        candidates.append(
            (
                wheel.support_index_min(supported_tags),
                wheel_name,
                wheel_dir,
            )
        )

    if not candidates:
        return link

    _, wheel_name, wheel_dir = min(candidates)
    return Link(path_to_url(os.path.join(wheel_dir, wheel_name)))
</pre></div>
</div>
<p>class EphemWheelCache(SimpleWheelCache):
“””A SimpleWheelCache that creates it’s own temporary cache directory”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self) -&gt; None:
    self._temp_dir = TempDirectory(
        kind=tempdir_kinds.EPHEM_WHEEL_CACHE,
        globally_managed=True,
    )

    super().__init__(self._temp_dir.path)
</pre></div>
</div>
<p>class CacheEntry:
def <strong>init</strong>(
self,
link: Link,
persistent: bool,
):
self.link = link
self.persistent = persistent
self.origin: DirectUrl | None = None
origin_direct_url_path = Path(self.link.file_path).parent / ORIGIN_JSON_NAME
if origin_direct_url_path.exists():
try:
self.origin = DirectUrl.from_json(
origin_direct_url_path.read_text(encoding=”utf-8”)
)
except Exception as e:
logger.warning(
“Ignoring invalid cache entry origin file %s for %s (%s)”,
origin_direct_url_path,
link.filename,
e,
)</p>
<p>class WheelCache(Cache):
“””Wraps EphemWheelCache and SimpleWheelCache into a single Cache</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This Cache allows for gracefully degradation, using the ephem wheel cache
when a certain link is not found in the simple wheel cache first.
&quot;&quot;&quot;

def __init__(self, cache_dir: str) -&gt; None:
    super().__init__(cache_dir)
    self._wheel_cache = SimpleWheelCache(cache_dir)
    self._ephem_cache = EphemWheelCache()

def get_path_for_link(self, link: Link) -&gt; str:
    return self._wheel_cache.get_path_for_link(link)

def get_ephem_path_for_link(self, link: Link) -&gt; str:
    return self._ephem_cache.get_path_for_link(link)

def get(
    self,
    link: Link,
    package_name: str | None,
    supported_tags: list[Tag],
) -&gt; Link:
    cache_entry = self.get_cache_entry(link, package_name, supported_tags)
    if cache_entry is None:
        return link
    return cache_entry.link

def get_cache_entry(
    self,
    link: Link,
    package_name: str | None,
    supported_tags: list[Tag],
) -&gt; CacheEntry | None:
    &quot;&quot;&quot;Returns a CacheEntry with a link to a cached item if it exists or
    None. The cache entry indicates if the item was found in the persistent
    or ephemeral cache.
    &quot;&quot;&quot;
    retval = self._wheel_cache.get(
        link=link,
        package_name=package_name,
        supported_tags=supported_tags,
    )
    if retval is not link:
        return CacheEntry(retval, persistent=True)

    retval = self._ephem_cache.get(
        link=link,
        package_name=package_name,
        supported_tags=supported_tags,
    )
    if retval is not link:
        return CacheEntry(retval, persistent=False)

    return None

@staticmethod
def record_download_origin(cache_dir: str, download_info: DirectUrl) -&gt; None:
    origin_path = Path(cache_dir) / ORIGIN_JSON_NAME
    if origin_path.exists():
        try:
            origin = DirectUrl.from_json(origin_path.read_text(encoding=&quot;utf-8&quot;))
        except Exception as e:
            logger.warning(
                &quot;Could not read origin file %s in cache entry (%s). &quot;
                &quot;Will attempt to overwrite it.&quot;,
                origin_path,
                e,
            )
        else:
            # TODO: use DirectUrl.equivalent when
            # https://github.com/pypa/pip/pull/10564 is merged.
            if origin.url != download_info.url:
                logger.warning(
                    &quot;Origin URL %s in cache entry %s does not match download URL &quot;
                    &quot;%s. This is likely a pip bug or a cache corruption issue. &quot;
                    &quot;Will overwrite it with the new value.&quot;,
                    origin.url,
                    cache_dir,
                    download_info.url,
                )
    origin_path.write_text(download_info.to_json(), encoding=&quot;utf-8&quot;)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>