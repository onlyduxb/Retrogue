

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The following styles are based on https://github.com/pygments/pygments/blob/master/pygments/formatters/terminal.py &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The following styles are based on https://github.com/pygments/pygments/blob/master/pygments/formatters/terminal.py</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/rich/syntax.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import os.path
import re
import sys
import textwrap
from abc import ABC, abstractmethod
from pathlib import Path
from typing import (
Any,
Dict,
Iterable,
List,
NamedTuple,
Optional,
Sequence,
Set,
Tuple,
Type,
Union,
)</p>
<p>from pip._vendor.pygments.lexer import Lexer
from pip._vendor.pygments.lexers import get_lexer_by_name, guess_lexer_for_filename
from pip._vendor.pygments.style import Style as PygmentsStyle
from pip._vendor.pygments.styles import get_style_by_name
from pip._vendor.pygments.token import (
Comment,
Error,
Generic,
Keyword,
Name,
Number,
Operator,
String,
Token,
Whitespace,
)
from pip._vendor.pygments.util import ClassNotFound</p>
<p>from pip._vendor.rich.containers import Lines
from pip._vendor.rich.padding import Padding, PaddingDimensions</p>
<p>from ._loop import loop_first
from .cells import cell_len
from .color import Color, blend_rgb
from .console import Console, ConsoleOptions, JustifyMethod, RenderResult
from .jupyter import JupyterMixin
from .measure import Measurement
from .segment import Segment, Segments
from .style import Style, StyleType
from .text import Text</p>
<p>TokenType = Tuple[str, …]</p>
<p>WINDOWS = sys.platform == “win32”
DEFAULT_THEME = “monokai”</p>
<section id="the-following-styles-are-based-on-https-github-com-pygments-pygments-blob-master-pygments-formatters-terminal-py">
<h1>The following styles are based on https://github.com/pygments/pygments/blob/master/pygments/formatters/terminal.py<a class="headerlink" href="#the-following-styles-are-based-on-https-github-com-pygments-pygments-blob-master-pygments-formatters-terminal-py" title="Link to this heading"></a></h1>
</section>
<section id="a-few-modifications-were-made">
<h1>A few modifications were made<a class="headerlink" href="#a-few-modifications-were-made" title="Link to this heading"></a></h1>
<p>ANSI_LIGHT: Dict[TokenType, Style] = {
Token: Style(),
Whitespace: Style(color=”white”),
Comment: Style(dim=True),
Comment.Preproc: Style(color=”cyan”),
Keyword: Style(color=”blue”),
Keyword.Type: Style(color=”cyan”),
Operator.Word: Style(color=”magenta”),
Name.Builtin: Style(color=”cyan”),
Name.Function: Style(color=”green”),
Name.Namespace: Style(color=”cyan”, underline=True),
Name.Class: Style(color=”green”, underline=True),
Name.Exception: Style(color=”cyan”),
Name.Decorator: Style(color=”magenta”, bold=True),
Name.Variable: Style(color=”red”),
Name.Constant: Style(color=”red”),
Name.Attribute: Style(color=”cyan”),
Name.Tag: Style(color=”bright_blue”),
String: Style(color=”yellow”),
Number: Style(color=”blue”),
Generic.Deleted: Style(color=”bright_red”),
Generic.Inserted: Style(color=”green”),
Generic.Heading: Style(bold=True),
Generic.Subheading: Style(color=”magenta”, bold=True),
Generic.Prompt: Style(bold=True),
Generic.Error: Style(color=”bright_red”),
Error: Style(color=”red”, underline=True),
}</p>
<p>ANSI_DARK: Dict[TokenType, Style] = {
Token: Style(),
Whitespace: Style(color=”bright_black”),
Comment: Style(dim=True),
Comment.Preproc: Style(color=”bright_cyan”),
Keyword: Style(color=”bright_blue”),
Keyword.Type: Style(color=”bright_cyan”),
Operator.Word: Style(color=”bright_magenta”),
Name.Builtin: Style(color=”bright_cyan”),
Name.Function: Style(color=”bright_green”),
Name.Namespace: Style(color=”bright_cyan”, underline=True),
Name.Class: Style(color=”bright_green”, underline=True),
Name.Exception: Style(color=”bright_cyan”),
Name.Decorator: Style(color=”bright_magenta”, bold=True),
Name.Variable: Style(color=”bright_red”),
Name.Constant: Style(color=”bright_red”),
Name.Attribute: Style(color=”bright_cyan”),
Name.Tag: Style(color=”bright_blue”),
String: Style(color=”yellow”),
Number: Style(color=”bright_blue”),
Generic.Deleted: Style(color=”bright_red”),
Generic.Inserted: Style(color=”bright_green”),
Generic.Heading: Style(bold=True),
Generic.Subheading: Style(color=”bright_magenta”, bold=True),
Generic.Prompt: Style(bold=True),
Generic.Error: Style(color=”bright_red”),
Error: Style(color=”red”, underline=True),
}</p>
<p>RICH_SYNTAX_THEMES = {“ansi_light”: ANSI_LIGHT, “ansi_dark”: ANSI_DARK}
NUMBERS_COLUMN_DEFAULT_PADDING = 2</p>
<p>class SyntaxTheme(ABC):
“””Base class for a syntax theme.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@abstractmethod
def get_style_for_token(self, token_type: TokenType) -&gt; Style:
    &quot;&quot;&quot;Get a style for a given Pygments token.&quot;&quot;&quot;
    raise NotImplementedError  # pragma: no cover

@abstractmethod
def get_background_style(self) -&gt; Style:
    &quot;&quot;&quot;Get the background color.&quot;&quot;&quot;
    raise NotImplementedError  # pragma: no cover
</pre></div>
</div>
<p>class PygmentsSyntaxTheme(SyntaxTheme):
“””Syntax theme that delegates to Pygments theme.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, theme: Union[str, Type[PygmentsStyle]]) -&gt; None:
    self._style_cache: Dict[TokenType, Style] = {}
    if isinstance(theme, str):
        try:
            self._pygments_style_class = get_style_by_name(theme)
        except ClassNotFound:
            self._pygments_style_class = get_style_by_name(&quot;default&quot;)
    else:
        self._pygments_style_class = theme

    self._background_color = self._pygments_style_class.background_color
    self._background_style = Style(bgcolor=self._background_color)

def get_style_for_token(self, token_type: TokenType) -&gt; Style:
    &quot;&quot;&quot;Get a style from a Pygments class.&quot;&quot;&quot;
    try:
        return self._style_cache[token_type]
    except KeyError:
        try:
            pygments_style = self._pygments_style_class.style_for_token(token_type)
        except KeyError:
            style = Style.null()
        else:
            color = pygments_style[&quot;color&quot;]
            bgcolor = pygments_style[&quot;bgcolor&quot;]
            style = Style(
                color=&quot;#&quot; + color if color else &quot;#000000&quot;,
                bgcolor=&quot;#&quot; + bgcolor if bgcolor else self._background_color,
                bold=pygments_style[&quot;bold&quot;],
                italic=pygments_style[&quot;italic&quot;],
                underline=pygments_style[&quot;underline&quot;],
            )
        self._style_cache[token_type] = style
    return style

def get_background_style(self) -&gt; Style:
    return self._background_style
</pre></div>
</div>
<p>class ANSISyntaxTheme(SyntaxTheme):
“””Syntax theme to use standard colors.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, style_map: Dict[TokenType, Style]) -&gt; None:
    self.style_map = style_map
    self._missing_style = Style.null()
    self._background_style = Style.null()
    self._style_cache: Dict[TokenType, Style] = {}

def get_style_for_token(self, token_type: TokenType) -&gt; Style:
    &quot;&quot;&quot;Look up style in the style map.&quot;&quot;&quot;
    try:
        return self._style_cache[token_type]
    except KeyError:
        # Styles form a hierarchy
        # We need to go from most to least specific
        # e.g. (&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) to (&quot;foo&quot;, &quot;bar&quot;)  to (&quot;foo&quot;,)
        get_style = self.style_map.get
        token = tuple(token_type)
        style = self._missing_style
        while token:
            _style = get_style(token)
            if _style is not None:
                style = _style
                break
            token = token[:-1]
        self._style_cache[token_type] = style
        return style

def get_background_style(self) -&gt; Style:
    return self._background_style
</pre></div>
</div>
<p>SyntaxPosition = Tuple[int, int]</p>
<p>class _SyntaxHighlightRange(NamedTuple):
“””
A range to highlight in a Syntax object.
<code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> are 2-integers tuples, where the first integer is the line number
(starting from 1) and the second integer is the column index (starting from 0).
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>style: StyleType
start: SyntaxPosition
end: SyntaxPosition
style_before: bool = False
</pre></div>
</div>
<p>class PaddingProperty:
“””Descriptor to get and set padding.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __get__(self, obj: Syntax, objtype: Type[Syntax]) -&gt; Tuple[int, int, int, int]:
    &quot;&quot;&quot;Space around the Syntax.&quot;&quot;&quot;
    return obj._padding

def __set__(self, obj: Syntax, padding: PaddingDimensions) -&gt; None:
    obj._padding = Padding.unpack(padding)
</pre></div>
</div>
<p>class Syntax(JupyterMixin):
“””Construct a Syntax object to render syntax highlighted code.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Args:
    code (str): Code to highlight.
    lexer (Lexer | str): Lexer to use (see https://pygments.org/docs/lexers/)
    theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to &quot;monokai&quot;.
    dedent (bool, optional): Enable stripping of initial whitespace. Defaults to False.
    line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.
    start_line (int, optional): Starting number for line numbers. Defaults to 1.
    line_range (Tuple[int | None, int | None], optional): If given should be a tuple of the start and end line to render.
        A value of None in the tuple indicates the range is open in that direction.
    highlight_lines (Set[int]): A set of line numbers to highlight.
    code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.
    tab_size (int, optional): Size of tabs. Defaults to 4.
    word_wrap (bool, optional): Enable word wrapping.
    background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.
    indent_guides (bool, optional): Show indent guides. Defaults to False.
    padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).
&quot;&quot;&quot;

_pygments_style_class: Type[PygmentsStyle]
_theme: SyntaxTheme

@classmethod
def get_theme(cls, name: Union[str, SyntaxTheme]) -&gt; SyntaxTheme:
    &quot;&quot;&quot;Get a syntax theme instance.&quot;&quot;&quot;
    if isinstance(name, SyntaxTheme):
        return name
    theme: SyntaxTheme
    if name in RICH_SYNTAX_THEMES:
        theme = ANSISyntaxTheme(RICH_SYNTAX_THEMES[name])
    else:
        theme = PygmentsSyntaxTheme(name)
    return theme

def __init__(
    self,
    code: str,
    lexer: Union[Lexer, str],
    *,
    theme: Union[str, SyntaxTheme] = DEFAULT_THEME,
    dedent: bool = False,
    line_numbers: bool = False,
    start_line: int = 1,
    line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,
    highlight_lines: Optional[Set[int]] = None,
    code_width: Optional[int] = None,
    tab_size: int = 4,
    word_wrap: bool = False,
    background_color: Optional[str] = None,
    indent_guides: bool = False,
    padding: PaddingDimensions = 0,
) -&gt; None:
    self.code = code
    self._lexer = lexer
    self.dedent = dedent
    self.line_numbers = line_numbers
    self.start_line = start_line
    self.line_range = line_range
    self.highlight_lines = highlight_lines or set()
    self.code_width = code_width
    self.tab_size = tab_size
    self.word_wrap = word_wrap
    self.background_color = background_color
    self.background_style = (
        Style(bgcolor=background_color) if background_color else Style()
    )
    self.indent_guides = indent_guides
    self._padding = Padding.unpack(padding)

    self._theme = self.get_theme(theme)
    self._stylized_ranges: List[_SyntaxHighlightRange] = []

padding = PaddingProperty()

@classmethod
def from_path(
    cls,
    path: str,
    encoding: str = &quot;utf-8&quot;,
    lexer: Optional[Union[Lexer, str]] = None,
    theme: Union[str, SyntaxTheme] = DEFAULT_THEME,
    dedent: bool = False,
    line_numbers: bool = False,
    line_range: Optional[Tuple[int, int]] = None,
    start_line: int = 1,
    highlight_lines: Optional[Set[int]] = None,
    code_width: Optional[int] = None,
    tab_size: int = 4,
    word_wrap: bool = False,
    background_color: Optional[str] = None,
    indent_guides: bool = False,
    padding: PaddingDimensions = 0,
) -&gt; &quot;Syntax&quot;:
    &quot;&quot;&quot;Construct a Syntax object from a file.

    Args:
        path (str): Path to file to highlight.
        encoding (str): Encoding of file.
        lexer (str | Lexer, optional): Lexer to use. If None, lexer will be auto-detected from path/file content.
        theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to &quot;emacs&quot;.
        dedent (bool, optional): Enable stripping of initial whitespace. Defaults to True.
        line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.
        start_line (int, optional): Starting number for line numbers. Defaults to 1.
        line_range (Tuple[int, int], optional): If given should be a tuple of the start and end line to render.
        highlight_lines (Set[int]): A set of line numbers to highlight.
        code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.
        tab_size (int, optional): Size of tabs. Defaults to 4.
        word_wrap (bool, optional): Enable word wrapping of code.
        background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.
        indent_guides (bool, optional): Show indent guides. Defaults to False.
        padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).

    Returns:
        [Syntax]: A Syntax object that may be printed to the console
    &quot;&quot;&quot;
    code = Path(path).read_text(encoding=encoding)

    if not lexer:
        lexer = cls.guess_lexer(path, code=code)

    return cls(
        code,
        lexer,
        theme=theme,
        dedent=dedent,
        line_numbers=line_numbers,
        line_range=line_range,
        start_line=start_line,
        highlight_lines=highlight_lines,
        code_width=code_width,
        tab_size=tab_size,
        word_wrap=word_wrap,
        background_color=background_color,
        indent_guides=indent_guides,
        padding=padding,
    )

@classmethod
def guess_lexer(cls, path: str, code: Optional[str] = None) -&gt; str:
    &quot;&quot;&quot;Guess the alias of the Pygments lexer to use based on a path and an optional string of code.
    If code is supplied, it will use a combination of the code and the filename to determine the
    best lexer to use. For example, if the file is ``index.html`` and the file contains Django
    templating syntax, then &quot;html+django&quot; will be returned. If the file is ``index.html``, and no
    templating language is used, the &quot;html&quot; lexer will be used. If no string of code
    is supplied, the lexer will be chosen based on the file extension..

    Args:
        path (AnyStr): The path to the file containing the code you wish to know the lexer for.
        code (str, optional): Optional string of code that will be used as a fallback if no lexer
            is found for the supplied path.

    Returns:
        str: The name of the Pygments lexer that best matches the supplied path/code.
    &quot;&quot;&quot;
    lexer: Optional[Lexer] = None
    lexer_name = &quot;default&quot;
    if code:
        try:
            lexer = guess_lexer_for_filename(path, code)
        except ClassNotFound:
            pass

    if not lexer:
        try:
            _, ext = os.path.splitext(path)
            if ext:
                extension = ext.lstrip(&quot;.&quot;).lower()
                lexer = get_lexer_by_name(extension)
        except ClassNotFound:
            pass

    if lexer:
        if lexer.aliases:
            lexer_name = lexer.aliases[0]
        else:
            lexer_name = lexer.name

    return lexer_name

def _get_base_style(self) -&gt; Style:
    &quot;&quot;&quot;Get the base style.&quot;&quot;&quot;
    default_style = self._theme.get_background_style() + self.background_style
    return default_style

def _get_token_color(self, token_type: TokenType) -&gt; Optional[Color]:
    &quot;&quot;&quot;Get a color (if any) for the given token.

    Args:
        token_type (TokenType): A token type tuple from Pygments.

    Returns:
        Optional[Color]: Color from theme, or None for no color.
    &quot;&quot;&quot;
    style = self._theme.get_style_for_token(token_type)
    return style.color

@property
def lexer(self) -&gt; Optional[Lexer]:
    &quot;&quot;&quot;The lexer for this syntax, or None if no lexer was found.

    Tries to find the lexer by name if a string was passed to the constructor.
    &quot;&quot;&quot;

    if isinstance(self._lexer, Lexer):
        return self._lexer
    try:
        return get_lexer_by_name(
            self._lexer,
            stripnl=False,
            ensurenl=True,
            tabsize=self.tab_size,
        )
    except ClassNotFound:
        return None

@property
def default_lexer(self) -&gt; Lexer:
    &quot;&quot;&quot;A Pygments Lexer to use if one is not specified or invalid.&quot;&quot;&quot;
    return get_lexer_by_name(
        &quot;text&quot;,
        stripnl=False,
        ensurenl=True,
        tabsize=self.tab_size,
    )

def highlight(
    self,
    code: str,
    line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,
) -&gt; Text:
    &quot;&quot;&quot;Highlight code and return a Text instance.

    Args:
        code (str): Code to highlight.
        line_range(Tuple[int, int], optional): Optional line range to highlight.

    Returns:
        Text: A text instance containing highlighted syntax.
    &quot;&quot;&quot;

    base_style = self._get_base_style()
    justify: JustifyMethod = (
        &quot;default&quot; if base_style.transparent_background else &quot;left&quot;
    )

    text = Text(
        justify=justify,
        style=base_style,
        tab_size=self.tab_size,
        no_wrap=not self.word_wrap,
    )
    _get_theme_style = self._theme.get_style_for_token

    lexer = self.lexer or self.default_lexer

    if lexer is None:
        text.append(code)
    else:
        if line_range:
            # More complicated path to only stylize a portion of the code
            # This speeds up further operations as there are less spans to process
            line_start, line_end = line_range

            def line_tokenize() -&gt; Iterable[Tuple[Any, str]]:
                &quot;&quot;&quot;Split tokens to one per line.&quot;&quot;&quot;
                assert lexer  # required to make MyPy happy - we know lexer is not None at this point

                for token_type, token in lexer.get_tokens(code):
                    while token:
                        line_token, new_line, token = token.partition(&quot;\n&quot;)
                        yield token_type, line_token + new_line

            def tokens_to_spans() -&gt; Iterable[Tuple[str, Optional[Style]]]:
                &quot;&quot;&quot;Convert tokens to spans.&quot;&quot;&quot;
                tokens = iter(line_tokenize())
                line_no = 0
                _line_start = line_start - 1 if line_start else 0

                # Skip over tokens until line start
                while line_no &lt; _line_start:
                    try:
                        _token_type, token = next(tokens)
                    except StopIteration:
                        break
                    yield (token, None)
                    if token.endswith(&quot;\n&quot;):
                        line_no += 1
                # Generate spans until line end
                for token_type, token in tokens:
                    yield (token, _get_theme_style(token_type))
                    if token.endswith(&quot;\n&quot;):
                        line_no += 1
                        if line_end and line_no &gt;= line_end:
                            break

            text.append_tokens(tokens_to_spans())

        else:
            text.append_tokens(
                (token, _get_theme_style(token_type))
                for token_type, token in lexer.get_tokens(code)
            )
        if self.background_color is not None:
            text.stylize(f&quot;on {self.background_color}&quot;)

    if self._stylized_ranges:
        self._apply_stylized_ranges(text)

    return text

def stylize_range(
    self,
    style: StyleType,
    start: SyntaxPosition,
    end: SyntaxPosition,
    style_before: bool = False,
) -&gt; None:
    &quot;&quot;&quot;
    Adds a custom style on a part of the code, that will be applied to the syntax display when it&#39;s rendered.
    Line numbers are 1-based, while column indexes are 0-based.

    Args:
        style (StyleType): The style to apply.
        start (Tuple[int, int]): The start of the range, in the form `[line number, column index]`.
        end (Tuple[int, int]): The end of the range, in the form `[line number, column index]`.
        style_before (bool): Apply the style before any existing styles.
    &quot;&quot;&quot;
    self._stylized_ranges.append(
        _SyntaxHighlightRange(style, start, end, style_before)
    )

def _get_line_numbers_color(self, blend: float = 0.3) -&gt; Color:
    background_style = self._theme.get_background_style() + self.background_style
    background_color = background_style.bgcolor
    if background_color is None or background_color.is_system_defined:
        return Color.default()
    foreground_color = self._get_token_color(Token.Text)
    if foreground_color is None or foreground_color.is_system_defined:
        return foreground_color or Color.default()
    new_color = blend_rgb(
        background_color.get_truecolor(),
        foreground_color.get_truecolor(),
        cross_fade=blend,
    )
    return Color.from_triplet(new_color)

@property
def _numbers_column_width(self) -&gt; int:
    &quot;&quot;&quot;Get the number of characters used to render the numbers column.&quot;&quot;&quot;
    column_width = 0
    if self.line_numbers:
        column_width = (
            len(str(self.start_line + self.code.count(&quot;\n&quot;)))
            + NUMBERS_COLUMN_DEFAULT_PADDING
        )
    return column_width

def _get_number_styles(self, console: Console) -&gt; Tuple[Style, Style, Style]:
    &quot;&quot;&quot;Get background, number, and highlight styles for line numbers.&quot;&quot;&quot;
    background_style = self._get_base_style()
    if background_style.transparent_background:
        return Style.null(), Style(dim=True), Style.null()
    if console.color_system in (&quot;256&quot;, &quot;truecolor&quot;):
        number_style = Style.chain(
            background_style,
            self._theme.get_style_for_token(Token.Text),
            Style(color=self._get_line_numbers_color()),
            self.background_style,
        )
        highlight_number_style = Style.chain(
            background_style,
            self._theme.get_style_for_token(Token.Text),
            Style(bold=True, color=self._get_line_numbers_color(0.9)),
            self.background_style,
        )
    else:
        number_style = background_style + Style(dim=True)
        highlight_number_style = background_style + Style(dim=False)
    return background_style, number_style, highlight_number_style

def __rich_measure__(
    self, console: &quot;Console&quot;, options: &quot;ConsoleOptions&quot;
) -&gt; &quot;Measurement&quot;:
    _, right, _, left = self.padding
    padding = left + right
    if self.code_width is not None:
        width = self.code_width + self._numbers_column_width + padding + 1
        return Measurement(self._numbers_column_width, width)
    lines = self.code.splitlines()
    width = (
        self._numbers_column_width
        + padding
        + (max(cell_len(line) for line in lines) if lines else 0)
    )
    if self.line_numbers:
        width += 1
    return Measurement(self._numbers_column_width, width)

def __rich_console__(
    self, console: Console, options: ConsoleOptions
) -&gt; RenderResult:
    segments = Segments(self._get_syntax(console, options))
    if any(self.padding):
        yield Padding(segments, style=self._get_base_style(), pad=self.padding)
    else:
        yield segments

def _get_syntax(
    self,
    console: Console,
    options: ConsoleOptions,
) -&gt; Iterable[Segment]:
    &quot;&quot;&quot;
    Get the Segments for the Syntax object, excluding any vertical/horizontal padding
    &quot;&quot;&quot;
    transparent_background = self._get_base_style().transparent_background
    _pad_top, pad_right, _pad_bottom, pad_left = self.padding
    horizontal_padding = pad_left + pad_right
    code_width = (
        (
            (options.max_width - self._numbers_column_width - 1)
            if self.line_numbers
            else options.max_width
        )
        - horizontal_padding
        if self.code_width is None
        else self.code_width
    )
    code_width = max(0, code_width)

    ends_on_nl, processed_code = self._process_code(self.code)
    text = self.highlight(processed_code, self.line_range)

    if not self.line_numbers and not self.word_wrap and not self.line_range:
        if not ends_on_nl:
            text.remove_suffix(&quot;\n&quot;)
        # Simple case of just rendering text
        style = (
            self._get_base_style()
            + self._theme.get_style_for_token(Comment)
            + Style(dim=True)
            + self.background_style
        )
        if self.indent_guides and not options.ascii_only:
            text = text.with_indent_guides(self.tab_size, style=style)
            text.overflow = &quot;crop&quot;
        if style.transparent_background:
            yield from console.render(
                text, options=options.update(width=code_width)
            )
        else:
            syntax_lines = console.render_lines(
                text,
                options.update(width=code_width, height=None, justify=&quot;left&quot;),
                style=self.background_style,
                pad=True,
                new_lines=True,
            )
            for syntax_line in syntax_lines:
                yield from syntax_line
        return

    start_line, end_line = self.line_range or (None, None)
    line_offset = 0
    if start_line:
        line_offset = max(0, start_line - 1)
    lines: Union[List[Text], Lines] = text.split(&quot;\n&quot;, allow_blank=ends_on_nl)
    if self.line_range:
        if line_offset &gt; len(lines):
            return
        lines = lines[line_offset:end_line]

    if self.indent_guides and not options.ascii_only:
        style = (
            self._get_base_style()
            + self._theme.get_style_for_token(Comment)
            + Style(dim=True)
            + self.background_style
        )
        lines = (
            Text(&quot;\n&quot;)
            .join(lines)
            .with_indent_guides(self.tab_size, style=style + Style(italic=False))
            .split(&quot;\n&quot;, allow_blank=True)
        )

    numbers_column_width = self._numbers_column_width
    render_options = options.update(width=code_width)

    highlight_line = self.highlight_lines.__contains__
    _Segment = Segment
    new_line = _Segment(&quot;\n&quot;)

    line_pointer = &quot;&gt; &quot; if options.legacy_windows else &quot;❱ &quot;

    (
        background_style,
        number_style,
        highlight_number_style,
    ) = self._get_number_styles(console)

    for line_no, line in enumerate(lines, self.start_line + line_offset):
        if self.word_wrap:
            wrapped_lines = console.render_lines(
                line,
                render_options.update(height=None, justify=&quot;left&quot;),
                style=background_style,
                pad=not transparent_background,
            )
        else:
            segments = list(line.render(console, end=&quot;&quot;))
            if options.no_wrap:
                wrapped_lines = [segments]
            else:
                wrapped_lines = [
                    _Segment.adjust_line_length(
                        segments,
                        render_options.max_width,
                        style=background_style,
                        pad=not transparent_background,
                    )
                ]

        if self.line_numbers:
            wrapped_line_left_pad = _Segment(
                &quot; &quot; * numbers_column_width + &quot; &quot;, background_style
            )
            for first, wrapped_line in loop_first(wrapped_lines):
                if first:
                    line_column = str(line_no).rjust(numbers_column_width - 2) + &quot; &quot;
                    if highlight_line(line_no):
                        yield _Segment(line_pointer, Style(color=&quot;red&quot;))
                        yield _Segment(line_column, highlight_number_style)
                    else:
                        yield _Segment(&quot;  &quot;, highlight_number_style)
                        yield _Segment(line_column, number_style)
                else:
                    yield wrapped_line_left_pad
                yield from wrapped_line
                yield new_line
        else:
            for wrapped_line in wrapped_lines:
                yield from wrapped_line
                yield new_line

def _apply_stylized_ranges(self, text: Text) -&gt; None:
    &quot;&quot;&quot;
    Apply stylized ranges to a text instance,
    using the given code to determine the right portion to apply the style to.

    Args:
        text (Text): Text instance to apply the style to.
    &quot;&quot;&quot;
    code = text.plain
    newlines_offsets = [
        # Let&#39;s add outer boundaries at each side of the list:
        0,
        # N.B. using &quot;\n&quot; here is much faster than using metacharacters such as &quot;^&quot; or &quot;\Z&quot;:
        *[
            match.start() + 1
            for match in re.finditer(&quot;\n&quot;, code, flags=re.MULTILINE)
        ],
        len(code) + 1,
    ]

    for stylized_range in self._stylized_ranges:
        start = _get_code_index_for_syntax_position(
            newlines_offsets, stylized_range.start
        )
        end = _get_code_index_for_syntax_position(
            newlines_offsets, stylized_range.end
        )
        if start is not None and end is not None:
            if stylized_range.style_before:
                text.stylize_before(stylized_range.style, start, end)
            else:
                text.stylize(stylized_range.style, start, end)

def _process_code(self, code: str) -&gt; Tuple[bool, str]:
    &quot;&quot;&quot;
    Applies various processing to a raw code string
    (normalises it so it always ends with a line return, dedents it if necessary, etc.)

    Args:
        code (str): The raw code string to process

    Returns:
        Tuple[bool, str]: the boolean indicates whether the raw code ends with a line return,
            while the string is the processed code.
    &quot;&quot;&quot;
    ends_on_nl = code.endswith(&quot;\n&quot;)
    processed_code = code if ends_on_nl else code + &quot;\n&quot;
    processed_code = (
        textwrap.dedent(processed_code) if self.dedent else processed_code
    )
    processed_code = processed_code.expandtabs(self.tab_size)
    return ends_on_nl, processed_code
</pre></div>
</div>
<p>def _get_code_index_for_syntax_position(
newlines_offsets: Sequence[int], position: SyntaxPosition
) -&gt; Optional[int]:
“””
Returns the index of the code string for the given positions.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Args:
    newlines_offsets (Sequence[int]): The offset of each newline character found in the code snippet.
    position (SyntaxPosition): The position to search for.

Returns:
    Optional[int]: The index of the code string for this position, or `None`
        if the given position&#39;s line number is out of range (if it&#39;s the column that is out of range
        we silently clamp its value so that it reaches the end of the line)
&quot;&quot;&quot;
lines_count = len(newlines_offsets)

line_number, column_index = position
if line_number &gt; lines_count or len(newlines_offsets) &lt; (line_number + 1):
    return None  # `line_number` is out of range
line_index = line_number - 1
line_length = newlines_offsets[line_index + 1] - newlines_offsets[line_index] - 1
# If `column_index` is out of range: let&#39;s silently clamp it:
column_index = min(line_length, column_index)
return newlines_offsets[line_index] + column_index
</pre></div>
</div>
<p>if <strong>name</strong> == “<strong>main</strong>”:  # pragma: no cover
import argparse
import sys</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>parser = argparse.ArgumentParser(
    description=&quot;Render syntax to the console with Rich&quot;
)
parser.add_argument(
    &quot;path&quot;,
    metavar=&quot;PATH&quot;,
    help=&quot;path to file, or - for stdin&quot;,
)
parser.add_argument(
    &quot;-c&quot;,
    &quot;--force-color&quot;,
    dest=&quot;force_color&quot;,
    action=&quot;store_true&quot;,
    default=None,
    help=&quot;force color for non-terminals&quot;,
)
parser.add_argument(
    &quot;-i&quot;,
    &quot;--indent-guides&quot;,
    dest=&quot;indent_guides&quot;,
    action=&quot;store_true&quot;,
    default=False,
    help=&quot;display indent guides&quot;,
)
parser.add_argument(
    &quot;-l&quot;,
    &quot;--line-numbers&quot;,
    dest=&quot;line_numbers&quot;,
    action=&quot;store_true&quot;,
    help=&quot;render line numbers&quot;,
)
parser.add_argument(
    &quot;-w&quot;,
    &quot;--width&quot;,
    type=int,
    dest=&quot;width&quot;,
    default=None,
    help=&quot;width of output (default will auto-detect)&quot;,
)
parser.add_argument(
    &quot;-r&quot;,
    &quot;--wrap&quot;,
    dest=&quot;word_wrap&quot;,
    action=&quot;store_true&quot;,
    default=False,
    help=&quot;word wrap long lines&quot;,
)
parser.add_argument(
    &quot;-s&quot;,
    &quot;--soft-wrap&quot;,
    action=&quot;store_true&quot;,
    dest=&quot;soft_wrap&quot;,
    default=False,
    help=&quot;enable soft wrapping mode&quot;,
)
parser.add_argument(
    &quot;-t&quot;, &quot;--theme&quot;, dest=&quot;theme&quot;, default=&quot;monokai&quot;, help=&quot;pygments theme&quot;
)
parser.add_argument(
    &quot;-b&quot;,
    &quot;--background-color&quot;,
    dest=&quot;background_color&quot;,
    default=None,
    help=&quot;Override background color&quot;,
)
parser.add_argument(
    &quot;-x&quot;,
    &quot;--lexer&quot;,
    default=None,
    dest=&quot;lexer_name&quot;,
    help=&quot;Lexer name&quot;,
)
parser.add_argument(
    &quot;-p&quot;, &quot;--padding&quot;, type=int, default=0, dest=&quot;padding&quot;, help=&quot;Padding&quot;
)
parser.add_argument(
    &quot;--highlight-line&quot;,
    type=int,
    default=None,
    dest=&quot;highlight_line&quot;,
    help=&quot;The line number (not index!) to highlight&quot;,
)
args = parser.parse_args()

from pip._vendor.rich.console import Console

console = Console(force_terminal=args.force_color, width=args.width)

if args.path == &quot;-&quot;:
    code = sys.stdin.read()
    syntax = Syntax(
        code=code,
        lexer=args.lexer_name,
        line_numbers=args.line_numbers,
        word_wrap=args.word_wrap,
        theme=args.theme,
        background_color=args.background_color,
        indent_guides=args.indent_guides,
        padding=args.padding,
        highlight_lines={args.highlight_line},
    )
else:
    syntax = Syntax.from_path(
        args.path,
        lexer=args.lexer_name,
        line_numbers=args.line_numbers,
        word_wrap=args.word_wrap,
        theme=args.theme,
        background_color=args.background_color,
        indent_guides=args.indent_guides,
        padding=args.padding,
        highlight_lines={args.highlight_line},
    )
console.print(syntax, soft_wrap=args.soft_wrap)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>