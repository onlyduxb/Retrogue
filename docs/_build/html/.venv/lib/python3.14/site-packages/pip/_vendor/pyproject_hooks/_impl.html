

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/pyproject_hooks/_impl.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>import json
import os
import sys
import tempfile
from contextlib import contextmanager
from os.path import abspath
from os.path import join as pjoin
from subprocess import STDOUT, check_call, check_output
from typing import TYPE_CHECKING, Any, Iterator, Mapping, Optional, Sequence</p>
<p>from ._in_process import _in_proc_script_path</p>
<p>if TYPE_CHECKING:
from typing import Protocol</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class SubprocessRunner(Protocol):
    &quot;&quot;&quot;A protocol for the subprocess runner.&quot;&quot;&quot;

    def __call__(
        self,
        cmd: Sequence[str],
        cwd: Optional[str] = None,
        extra_environ: Optional[Mapping[str, str]] = None,
    ) -&gt; None:
        ...
</pre></div>
</div>
<p>def write_json(obj: Mapping[str, Any], path: str, **kwargs) -&gt; None:
with open(path, “w”, encoding=”utf-8”) as f:
json.dump(obj, f, **kwargs)</p>
<p>def read_json(path: str) -&gt; Mapping[str, Any]:
with open(path, encoding=”utf-8”) as f:
return json.load(f)</p>
<p>class BackendUnavailable(Exception):
“””Will be raised if the backend cannot be imported in the hook process.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    traceback: str,
    message: Optional[str] = None,
    backend_name: Optional[str] = None,
    backend_path: Optional[Sequence[str]] = None,
) -&gt; None:
    # Preserving arg order for the sake of API backward compatibility.
    self.backend_name = backend_name
    self.backend_path = backend_path
    self.traceback = traceback
    super().__init__(message or &quot;Error while importing backend&quot;)
</pre></div>
</div>
<p>class HookMissing(Exception):
“””Will be raised on missing hooks (if a fallback can’t be used).”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, hook_name: str) -&gt; None:
    super().__init__(hook_name)
    self.hook_name = hook_name
</pre></div>
</div>
<p>class UnsupportedOperation(Exception):
“””May be raised by build_sdist if the backend indicates that it can’t.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, traceback: str) -&gt; None:
    self.traceback = traceback
</pre></div>
</div>
<p>def default_subprocess_runner(
cmd: Sequence[str],
cwd: Optional[str] = None,
extra_environ: Optional[Mapping[str, str]] = None,
) -&gt; None:
“””The default method of calling the wrapper subprocess.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This uses :func:`subprocess.check_call` under the hood.
&quot;&quot;&quot;
env = os.environ.copy()
if extra_environ:
    env.update(extra_environ)

check_call(cmd, cwd=cwd, env=env)
</pre></div>
</div>
<p>def quiet_subprocess_runner(
cmd: Sequence[str],
cwd: Optional[str] = None,
extra_environ: Optional[Mapping[str, str]] = None,
) -&gt; None:
“””Call the subprocess while suppressing output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This uses :func:`subprocess.check_output` under the hood.
&quot;&quot;&quot;
env = os.environ.copy()
if extra_environ:
    env.update(extra_environ)

check_output(cmd, cwd=cwd, env=env, stderr=STDOUT)
</pre></div>
</div>
<p>def norm_and_check(source_tree: str, requested: str) -&gt; str:
“””Normalise and check a backend path.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Ensure that the requested backend path is specified as a relative path,
and resolves to a location under the given source tree.

Return an absolute version of the requested path.
&quot;&quot;&quot;
if os.path.isabs(requested):
    raise ValueError(&quot;paths must be relative&quot;)

abs_source = os.path.abspath(source_tree)
abs_requested = os.path.normpath(os.path.join(abs_source, requested))
# We have to use commonprefix for Python 2.7 compatibility. So we
# normalise case to avoid problems because commonprefix is a character
# based comparison :-(
norm_source = os.path.normcase(abs_source)
norm_requested = os.path.normcase(abs_requested)
if os.path.commonprefix([norm_source, norm_requested]) != norm_source:
    raise ValueError(&quot;paths must be inside source tree&quot;)

return abs_requested
</pre></div>
</div>
<p>class BuildBackendHookCaller:
“””A wrapper to call the build backend hooks for a source directory.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    source_dir: str,
    build_backend: str,
    backend_path: Optional[Sequence[str]] = None,
    runner: Optional[&quot;SubprocessRunner&quot;] = None,
    python_executable: Optional[str] = None,
) -&gt; None:
    &quot;&quot;&quot;
    :param source_dir: The source directory to invoke the build backend for
    :param build_backend: The build backend spec
    :param backend_path: Additional path entries for the build backend spec
    :param runner: The :ref:`subprocess runner &lt;Subprocess Runners&gt;` to use
    :param python_executable:
        The Python executable used to invoke the build backend
    &quot;&quot;&quot;
    if runner is None:
        runner = default_subprocess_runner

    self.source_dir = abspath(source_dir)
    self.build_backend = build_backend
    if backend_path:
        backend_path = [norm_and_check(self.source_dir, p) for p in backend_path]
    self.backend_path = backend_path
    self._subprocess_runner = runner
    if not python_executable:
        python_executable = sys.executable
    self.python_executable = python_executable

@contextmanager
def subprocess_runner(self, runner: &quot;SubprocessRunner&quot;) -&gt; Iterator[None]:
    &quot;&quot;&quot;A context manager for temporarily overriding the default
    :ref:`subprocess runner &lt;Subprocess Runners&gt;`.

    :param runner: The new subprocess runner to use within the context.

    .. code-block:: python

        hook_caller = BuildBackendHookCaller(...)
        with hook_caller.subprocess_runner(quiet_subprocess_runner):
            ...
    &quot;&quot;&quot;
    prev = self._subprocess_runner
    self._subprocess_runner = runner
    try:
        yield
    finally:
        self._subprocess_runner = prev

def _supported_features(self) -&gt; Sequence[str]:
    &quot;&quot;&quot;Return the list of optional features supported by the backend.&quot;&quot;&quot;
    return self._call_hook(&quot;_supported_features&quot;, {})

def get_requires_for_build_wheel(
    self,
    config_settings: Optional[Mapping[str, Any]] = None,
) -&gt; Sequence[str]:
    &quot;&quot;&quot;Get additional dependencies required for building a wheel.

    :param config_settings: The configuration settings for the build backend
    :returns: A list of :pep:`dependency specifiers &lt;508&gt;`.

    .. admonition:: Fallback

        If the build backend does not defined a hook with this name, an
        empty list will be returned.
    &quot;&quot;&quot;
    return self._call_hook(
        &quot;get_requires_for_build_wheel&quot;, {&quot;config_settings&quot;: config_settings}
    )

def prepare_metadata_for_build_wheel(
    self,
    metadata_directory: str,
    config_settings: Optional[Mapping[str, Any]] = None,
    _allow_fallback: bool = True,
) -&gt; str:
    &quot;&quot;&quot;Prepare a ``*.dist-info`` folder with metadata for this project.

    :param metadata_directory: The directory to write the metadata to
    :param config_settings: The configuration settings for the build backend
    :param _allow_fallback:
        Whether to allow the fallback to building a wheel and extracting
        the metadata from it. Should be passed as a keyword argument only.

    :returns: Name of the newly created subfolder within
              ``metadata_directory``, containing the metadata.

    .. admonition:: Fallback

        If the build backend does not define a hook with this name and
        ``_allow_fallback`` is truthy, the backend will be asked to build a
        wheel via the ``build_wheel`` hook and the dist-info extracted from
        that will be returned.
    &quot;&quot;&quot;
    return self._call_hook(
        &quot;prepare_metadata_for_build_wheel&quot;,
        {
            &quot;metadata_directory&quot;: abspath(metadata_directory),
            &quot;config_settings&quot;: config_settings,
            &quot;_allow_fallback&quot;: _allow_fallback,
        },
    )

def build_wheel(
    self,
    wheel_directory: str,
    config_settings: Optional[Mapping[str, Any]] = None,
    metadata_directory: Optional[str] = None,
) -&gt; str:
    &quot;&quot;&quot;Build a wheel from this project.

    :param wheel_directory: The directory to write the wheel to
    :param config_settings: The configuration settings for the build backend
    :param metadata_directory: The directory to reuse existing metadata from
    :returns:
        The name of the newly created wheel within ``wheel_directory``.

    .. admonition:: Interaction with fallback

        If the ``build_wheel`` hook was called in the fallback for
        :meth:`prepare_metadata_for_build_wheel`, the build backend would
        not be invoked. Instead, the previously built wheel will be copied
        to ``wheel_directory`` and the name of that file will be returned.
    &quot;&quot;&quot;
    if metadata_directory is not None:
        metadata_directory = abspath(metadata_directory)
    return self._call_hook(
        &quot;build_wheel&quot;,
        {
            &quot;wheel_directory&quot;: abspath(wheel_directory),
            &quot;config_settings&quot;: config_settings,
            &quot;metadata_directory&quot;: metadata_directory,
        },
    )

def get_requires_for_build_editable(
    self,
    config_settings: Optional[Mapping[str, Any]] = None,
) -&gt; Sequence[str]:
    &quot;&quot;&quot;Get additional dependencies required for building an editable wheel.

    :param config_settings: The configuration settings for the build backend
    :returns: A list of :pep:`dependency specifiers &lt;508&gt;`.

    .. admonition:: Fallback

        If the build backend does not defined a hook with this name, an
        empty list will be returned.
    &quot;&quot;&quot;
    return self._call_hook(
        &quot;get_requires_for_build_editable&quot;, {&quot;config_settings&quot;: config_settings}
    )

def prepare_metadata_for_build_editable(
    self,
    metadata_directory: str,
    config_settings: Optional[Mapping[str, Any]] = None,
    _allow_fallback: bool = True,
) -&gt; Optional[str]:
    &quot;&quot;&quot;Prepare a ``*.dist-info`` folder with metadata for this project.

    :param metadata_directory: The directory to write the metadata to
    :param config_settings: The configuration settings for the build backend
    :param _allow_fallback:
        Whether to allow the fallback to building a wheel and extracting
        the metadata from it. Should be passed as a keyword argument only.
    :returns: Name of the newly created subfolder within
              ``metadata_directory``, containing the metadata.

    .. admonition:: Fallback

        If the build backend does not define a hook with this name and
        ``_allow_fallback`` is truthy, the backend will be asked to build a
        wheel via the ``build_editable`` hook and the dist-info
        extracted from that will be returned.
    &quot;&quot;&quot;
    return self._call_hook(
        &quot;prepare_metadata_for_build_editable&quot;,
        {
            &quot;metadata_directory&quot;: abspath(metadata_directory),
            &quot;config_settings&quot;: config_settings,
            &quot;_allow_fallback&quot;: _allow_fallback,
        },
    )

def build_editable(
    self,
    wheel_directory: str,
    config_settings: Optional[Mapping[str, Any]] = None,
    metadata_directory: Optional[str] = None,
) -&gt; str:
    &quot;&quot;&quot;Build an editable wheel from this project.

    :param wheel_directory: The directory to write the wheel to
    :param config_settings: The configuration settings for the build backend
    :param metadata_directory: The directory to reuse existing metadata from
    :returns:
        The name of the newly created wheel within ``wheel_directory``.

    .. admonition:: Interaction with fallback

        If the ``build_editable`` hook was called in the fallback for
        :meth:`prepare_metadata_for_build_editable`, the build backend
        would not be invoked. Instead, the previously built wheel will be
        copied to ``wheel_directory`` and the name of that file will be
        returned.
    &quot;&quot;&quot;
    if metadata_directory is not None:
        metadata_directory = abspath(metadata_directory)
    return self._call_hook(
        &quot;build_editable&quot;,
        {
            &quot;wheel_directory&quot;: abspath(wheel_directory),
            &quot;config_settings&quot;: config_settings,
            &quot;metadata_directory&quot;: metadata_directory,
        },
    )

def get_requires_for_build_sdist(
    self,
    config_settings: Optional[Mapping[str, Any]] = None,
) -&gt; Sequence[str]:
    &quot;&quot;&quot;Get additional dependencies required for building an sdist.

    :returns: A list of :pep:`dependency specifiers &lt;508&gt;`.
    &quot;&quot;&quot;
    return self._call_hook(
        &quot;get_requires_for_build_sdist&quot;, {&quot;config_settings&quot;: config_settings}
    )

def build_sdist(
    self,
    sdist_directory: str,
    config_settings: Optional[Mapping[str, Any]] = None,
) -&gt; str:
    &quot;&quot;&quot;Build an sdist from this project.

    :returns:
        The name of the newly created sdist within ``wheel_directory``.
    &quot;&quot;&quot;
    return self._call_hook(
        &quot;build_sdist&quot;,
        {
            &quot;sdist_directory&quot;: abspath(sdist_directory),
            &quot;config_settings&quot;: config_settings,
        },
    )

def _call_hook(self, hook_name: str, kwargs: Mapping[str, Any]) -&gt; Any:
    extra_environ = {&quot;_PYPROJECT_HOOKS_BUILD_BACKEND&quot;: self.build_backend}

    if self.backend_path:
        backend_path = os.pathsep.join(self.backend_path)
        extra_environ[&quot;_PYPROJECT_HOOKS_BACKEND_PATH&quot;] = backend_path

    with tempfile.TemporaryDirectory() as td:
        hook_input = {&quot;kwargs&quot;: kwargs}
        write_json(hook_input, pjoin(td, &quot;input.json&quot;), indent=2)

        # Run the hook in a subprocess
        with _in_proc_script_path() as script:
            python = self.python_executable
            self._subprocess_runner(
                [python, abspath(str(script)), hook_name, td],
                cwd=self.source_dir,
                extra_environ=extra_environ,
            )

        data = read_json(pjoin(td, &quot;output.json&quot;))
        if data.get(&quot;unsupported&quot;):
            raise UnsupportedOperation(data.get(&quot;traceback&quot;, &quot;&quot;))
        if data.get(&quot;no_backend&quot;):
            raise BackendUnavailable(
                data.get(&quot;traceback&quot;, &quot;&quot;),
                message=data.get(&quot;backend_error&quot;, &quot;&quot;),
                backend_name=self.build_backend,
                backend_path=self.backend_path,
            )
        if data.get(&quot;hook_missing&quot;):
            raise HookMissing(data.get(&quot;missing_hook_name&quot;) or hook_name)
        return data[&quot;return_val&quot;]
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>