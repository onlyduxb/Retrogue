

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>We only want to normalize urls with an HTTP(S) scheme. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">We only want to normalize urls with an HTTP(S) scheme.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/util/url.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import absolute_import</p>
<p>import re
from collections import namedtuple</p>
<p>from ..exceptions import LocationParseError
from ..packages import six</p>
<p>url_attrs = [“scheme”, “auth”, “host”, “port”, “path”, “query”, “fragment”]</p>
<section id="we-only-want-to-normalize-urls-with-an-http-s-scheme">
<h1>We only want to normalize urls with an HTTP(S) scheme.<a class="headerlink" href="#we-only-want-to-normalize-urls-with-an-http-s-scheme" title="Link to this heading"></a></h1>
</section>
<section id="urllib3-infers-urls-without-a-scheme-none-to-be-http">
<h1>urllib3 infers URLs without a scheme (None) to be http.<a class="headerlink" href="#urllib3-infers-urls-without-a-scheme-none-to-be-http" title="Link to this heading"></a></h1>
<p>NORMALIZABLE_SCHEMES = (“http”, “https”, None)</p>
</section>
<section id="almost-all-of-these-patterns-were-derived-from-the">
<h1>Almost all of these patterns were derived from the<a class="headerlink" href="#almost-all-of-these-patterns-were-derived-from-the" title="Link to this heading"></a></h1>
</section>
<section id="rfc3986-module-https-github-com-python-hyper-rfc3986">
<h1>‘rfc3986’ module: https://github.com/python-hyper/rfc3986<a class="headerlink" href="#rfc3986-module-https-github-com-python-hyper-rfc3986" title="Link to this heading"></a></h1>
<p>PERCENT_RE = re.compile(r”%[a-fA-F0-9]{2}”)
SCHEME_RE = re.compile(r”^(?:[a-zA-Z][a-zA-Z0-9+-]<em>:|/)”)
URI_RE = re.compile(
r”^(?:([a-zA-Z][a-zA-Z0-9+.-]</em>):)?”
r”(?://(<a href="#id8"><span class="problematic" id="id1">[^\\/?#]</span></a><em>))?”
r”(<a href="#id9"><span class="problematic" id="id2">[^?#]</span></a></em>)”
r”(?:?(<a href="#id10"><span class="problematic" id="id3">[^#]</span></a><em>))?”
r”(?:#(.</em>))?$”,
re.UNICODE | re.DOTALL,
)</p>
<p>IPV4_PAT = r”(?:[0-9]{1,3}.){3}[0-9]{1,3}”
HEX_PAT = “[0-9A-Fa-f]{1,4}”
LS32_PAT = “(?:{hex}:{hex}|{ipv4})”.format(hex=HEX_PAT, ipv4=IPV4_PAT)
_subs = {“hex”: HEX_PAT, “ls32”: LS32_PAT}
_variations = [
#                            6( h16 “:” ) ls32
“(?:%(hex)s:){6}%(ls32)s”,
#                       “::” 5( h16 “:” ) ls32
“::(?:%(hex)s:){5}%(ls32)s”,
# [               h16 ] “::” 4( h16 “:” ) ls32
“(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s”,
# [ *1( h16 “:” ) h16 ] “::” 3( h16 “:” ) ls32
“(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s”,
# [ *2( h16 “:” ) h16 ] “::” 2( h16 “:” ) ls32
“(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s”,
# [ *3( h16 “:” ) h16 ] “::”    h16 “:”   ls32
“(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s”,
# [ *4( h16 “:” ) h16 ] “::”              ls32
“(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s”,
# [ *5( h16 “:” ) h16 ] “::”              h16
“(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s”,
# [ *6( h16 “:” ) h16 ] “::”
“(?:(?:%(hex)s:){0,6}%(hex)s)?::”,
]</p>
<p>UNRESERVED_PAT = r”ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~”
IPV6_PAT = “(?:” + “|”.join([x % _subs for x in _variations]) + “)”
ZONE_ID_PAT = “(?:%25|%)(?:[” + UNRESERVED_PAT + “]|%[a-fA-F0-9]{2})+”
IPV6_ADDRZ_PAT = r”[” + IPV6_PAT + r”(?:” + ZONE_ID_PAT + r”)?]”
REG_NAME_PAT = r”(?:<a href="#id11"><span class="problematic" id="id4">[^\[\]</span></a>%:/?#]|%[a-fA-F0-9]{2})<em>”
TARGET_RE = re.compile(r”^(/<a href="#id12"><span class="problematic" id="id5">[^?#]</span></a></em>)(?:?(<a href="#id13"><span class="problematic" id="id6">[^#]</span></a><em>))?(?:#.</em>)?$”)</p>
<p>IPV4_RE = re.compile(“^” + IPV4_PAT + “$”)
IPV6_RE = re.compile(“^” + IPV6_PAT + “$”)
IPV6_ADDRZ_RE = re.compile(“^” + IPV6_ADDRZ_PAT + “$”)
BRACELESS_IPV6_ADDRZ_RE = re.compile(“^” + IPV6_ADDRZ_PAT[2:-2] + “$”)
ZONE_ID_RE = re.compile(“(” + ZONE_ID_PAT + r”)]$”)</p>
<p>_HOST_PORT_PAT = (“^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$”) % (
REG_NAME_PAT,
IPV4_PAT,
IPV6_ADDRZ_PAT,
)
_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)</p>
<p>UNRESERVED_CHARS = set(
“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~”
)
SUB_DELIM_CHARS = set(“!$&amp;’()*+,;=”)
USERINFO_CHARS = UNRESERVED_CHARS | SUB_DELIM_CHARS | {“:”}
PATH_CHARS = USERINFO_CHARS | {“&#64;”, “/”}
QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {“?”}</p>
<p>class Url(namedtuple(“Url”, url_attrs)):
“””
Data structure for representing an HTTP URL. Used as a return value for
:func:<code class="docutils literal notranslate"><span class="pre">parse_url</span></code>. Both the scheme and host are normalized as they are
both case-insensitive according to RFC 3986.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__slots__ = ()

def __new__(
    cls,
    scheme=None,
    auth=None,
    host=None,
    port=None,
    path=None,
    query=None,
    fragment=None,
):
    if path and not path.startswith(&quot;/&quot;):
        path = &quot;/&quot; + path
    if scheme is not None:
        scheme = scheme.lower()
    return super(Url, cls).__new__(
        cls, scheme, auth, host, port, path, query, fragment
    )

@property
def hostname(self):
    &quot;&quot;&quot;For backwards-compatibility with urlparse. We&#39;re nice like that.&quot;&quot;&quot;
    return self.host

@property
def request_uri(self):
    &quot;&quot;&quot;Absolute path including the query string.&quot;&quot;&quot;
    uri = self.path or &quot;/&quot;

    if self.query is not None:
        uri += &quot;?&quot; + self.query

    return uri

@property
def netloc(self):
    &quot;&quot;&quot;Network location including host and port&quot;&quot;&quot;
    if self.port:
        return &quot;%s:%d&quot; % (self.host, self.port)
    return self.host

@property
def url(self):
    &quot;&quot;&quot;
    Convert self into a url

    This function should more or less round-trip with :func:`.parse_url`. The
    returned url may not be exactly the same as the url inputted to
    :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls
    with a blank port will have : removed).

    Example: ::

        &gt;&gt;&gt; U = parse_url(&#39;http://google.com/mail/&#39;)
        &gt;&gt;&gt; U.url
        &#39;http://google.com/mail/&#39;
        &gt;&gt;&gt; Url(&#39;http&#39;, &#39;username:password&#39;, &#39;host.com&#39;, 80,
        ... &#39;/path&#39;, &#39;query&#39;, &#39;fragment&#39;).url
        &#39;http://username:password@host.com:80/path?query#fragment&#39;
    &quot;&quot;&quot;
    scheme, auth, host, port, path, query, fragment = self
    url = u&quot;&quot;

    # We use &quot;is not None&quot; we want things to happen with empty strings (or 0 port)
    if scheme is not None:
        url += scheme + u&quot;://&quot;
    if auth is not None:
        url += auth + u&quot;@&quot;
    if host is not None:
        url += host
    if port is not None:
        url += u&quot;:&quot; + str(port)
    if path is not None:
        url += path
    if query is not None:
        url += u&quot;?&quot; + query
    if fragment is not None:
        url += u&quot;#&quot; + fragment

    return url

def __str__(self):
    return self.url
</pre></div>
</div>
<p>def split_first(s, delims):
“””
.. deprecated:: 1.25</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Given a string and an iterable of delimiters, split on the first found
delimiter. Return two split parts and the matched delimiter.

If not found, then the first part is the full input string.

Example::

    &gt;&gt;&gt; split_first(&#39;foo/bar?baz&#39;, &#39;?/=&#39;)
    (&#39;foo&#39;, &#39;bar?baz&#39;, &#39;/&#39;)
    &gt;&gt;&gt; split_first(&#39;foo/bar?baz&#39;, &#39;123&#39;)
    (&#39;foo/bar?baz&#39;, &#39;&#39;, None)

Scales linearly with number of delims. Not ideal for large number of delims.
&quot;&quot;&quot;
min_idx = None
min_delim = None
for d in delims:
    idx = s.find(d)
    if idx &lt; 0:
        continue

    if min_idx is None or idx &lt; min_idx:
        min_idx = idx
        min_delim = d

if min_idx is None or min_idx &lt; 0:
    return s, &quot;&quot;, None

return s[:min_idx], s[min_idx + 1 :], min_delim
</pre></div>
</div>
<p>def _encode_invalid_chars(component, allowed_chars, encoding=”utf-8”):
“””Percent-encodes a URI component without reapplying
onto an already percent-encoded component.
“””
if component is None:
return component</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>component = six.ensure_text(component)

# Normalize existing percent-encoded bytes.
# Try to see if the component we&#39;re encoding is already percent-encoded
# so we can skip all &#39;%&#39; characters but still encode all others.
component, percent_encodings = PERCENT_RE.subn(
    lambda match: match.group(0).upper(), component
)

uri_bytes = component.encode(&quot;utf-8&quot;, &quot;surrogatepass&quot;)
is_percent_encoded = percent_encodings == uri_bytes.count(b&quot;%&quot;)
encoded_component = bytearray()

for i in range(0, len(uri_bytes)):
    # Will return a single character bytestring on both Python 2 &amp; 3
    byte = uri_bytes[i : i + 1]
    byte_ord = ord(byte)
    if (is_percent_encoded and byte == b&quot;%&quot;) or (
        byte_ord &lt; 128 and byte.decode() in allowed_chars
    ):
        encoded_component += byte
        continue
    encoded_component.extend(b&quot;%&quot; + (hex(byte_ord)[2:].encode().zfill(2).upper()))

return encoded_component.decode(encoding)
</pre></div>
</div>
<p>def _remove_path_dot_segments(path):
# See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code
segments = path.split(“/”)  # Turn the path into a list of segments
output = []  # Initialize the variable to use to store output</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>for segment in segments:
    # &#39;.&#39; is the current directory, so ignore it, it is superfluous
    if segment == &quot;.&quot;:
        continue
    # Anything other than &#39;..&#39;, should be appended to the output
    elif segment != &quot;..&quot;:
        output.append(segment)
    # In this case segment == &#39;..&#39;, if we can, we should pop the last
    # element
    elif output:
        output.pop()

# If the path starts with &#39;/&#39; and the output is empty or the first string
# is non-empty
if path.startswith(&quot;/&quot;) and (not output or output[0]):
    output.insert(0, &quot;&quot;)

# If the path starts with &#39;/.&#39; or &#39;/..&#39; ensure we add one more empty
# string to add a trailing &#39;/&#39;
if path.endswith((&quot;/.&quot;, &quot;/..&quot;)):
    output.append(&quot;&quot;)

return &quot;/&quot;.join(output)
</pre></div>
</div>
<p>def _normalize_host(host, scheme):
if host:
if isinstance(host, six.binary_type):
host = six.ensure_str(host)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    if scheme in NORMALIZABLE_SCHEMES:
        is_ipv6 = IPV6_ADDRZ_RE.match(host)
        if is_ipv6:
            # IPv6 hosts of the form &#39;a::b%zone&#39; are encoded in a URL as
            # such per RFC 6874: &#39;a::b%25zone&#39;. Unquote the ZoneID
            # separator as necessary to return a valid RFC 4007 scoped IP.
            match = ZONE_ID_RE.search(host)
            if match:
                start, end = match.span(1)
                zone_id = host[start:end]

                if zone_id.startswith(&quot;%25&quot;) and zone_id != &quot;%25&quot;:
                    zone_id = zone_id[3:]
                else:
                    zone_id = zone_id[1:]
                zone_id = &quot;%&quot; + _encode_invalid_chars(zone_id, UNRESERVED_CHARS)
                return host[:start].lower() + zone_id + host[end:]
            else:
                return host.lower()
        elif not IPV4_RE.match(host):
            return six.ensure_str(
                b&quot;.&quot;.join([_idna_encode(label) for label in host.split(&quot;.&quot;)])
            )
return host
</pre></div>
</div>
<p>def _idna_encode(name):
if name and any(ord(x) &gt;= 128 for x in name):
try:
from pip._vendor import idna
except ImportError:
six.raise_from(
LocationParseError(“Unable to parse URL without the ‘idna’ module”),
None,
)
try:
return idna.encode(name.lower(), strict=True, std3_rules=True)
except idna.IDNAError:
six.raise_from(
LocationParseError(u”Name ‘%s’ is not a valid IDNA label” % name), None
)
return name.lower().encode(“ascii”)</p>
<p>def _encode_target(target):
“””Percent-encodes a request target so that there are no invalid characters”””
path, query = TARGET_RE.match(target).groups()
target = _encode_invalid_chars(path, PATH_CHARS)
query = _encode_invalid_chars(query, QUERY_CHARS)
if query is not None:
target += “?” + query
return target</p>
<p>def parse_url(url):
“””
Given a url, return a parsed :class:<code class="docutils literal notranslate"><span class="pre">.Url</span></code> namedtuple. Best-effort is
performed to parse incomplete urls. Fields not provided will be None.
This parser is RFC 3986 and RFC 6874 compliant.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The parser logic and helper functions are based heavily on
work done in the ``rfc3986`` module.

:param str url: URL to parse into a :class:`.Url` namedtuple.

Partly backwards-compatible with :mod:`urlparse`.

Example::

    &gt;&gt;&gt; parse_url(&#39;http://google.com/mail/&#39;)
    Url(scheme=&#39;http&#39;, host=&#39;google.com&#39;, port=None, path=&#39;/mail/&#39;, ...)
    &gt;&gt;&gt; parse_url(&#39;google.com:80&#39;)
    Url(scheme=None, host=&#39;google.com&#39;, port=80, path=None, ...)
    &gt;&gt;&gt; parse_url(&#39;/foo?bar&#39;)
    Url(scheme=None, host=None, port=None, path=&#39;/foo&#39;, query=&#39;bar&#39;, ...)
&quot;&quot;&quot;
if not url:
    # Empty
    return Url()

source_url = url
if not SCHEME_RE.search(url):
    url = &quot;//&quot; + url

try:
    scheme, authority, path, query, fragment = URI_RE.match(url).groups()
    normalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES

    if scheme:
        scheme = scheme.lower()

    if authority:
        auth, _, host_port = authority.rpartition(&quot;@&quot;)
        auth = auth or None
        host, port = _HOST_PORT_RE.match(host_port).groups()
        if auth and normalize_uri:
            auth = _encode_invalid_chars(auth, USERINFO_CHARS)
        if port == &quot;&quot;:
            port = None
    else:
        auth, host, port = None, None, None

    if port is not None:
        port = int(port)
        if not (0 &lt;= port &lt;= 65535):
            raise LocationParseError(url)

    host = _normalize_host(host, scheme)

    if normalize_uri and path:
        path = _remove_path_dot_segments(path)
        path = _encode_invalid_chars(path, PATH_CHARS)
    if normalize_uri and query:
        query = _encode_invalid_chars(query, QUERY_CHARS)
    if normalize_uri and fragment:
        fragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)

except (ValueError, AttributeError):
    return six.raise_from(LocationParseError(source_url), None)

# For the sake of backwards compatibility we put empty
# string values for path if there are any defined values
# beyond the path in the URL.
# TODO: Remove this when we break backwards compatibility.
if not path:
    if query is not None or fragment is not None:
        path = &quot;&quot;
    else:
        path = None

# Ensure that each part of the URL is a `str` for
# backwards compatibility.
if isinstance(url, six.text_type):
    ensure_func = six.ensure_text
else:
    ensure_func = six.ensure_str

def ensure_type(x):
    return x if x is None else ensure_func(x)

return Url(
    scheme=ensure_type(scheme),
    auth=ensure_type(auth),
    host=ensure_type(host),
    port=port,
    path=ensure_type(path),
    query=ensure_type(query),
    fragment=ensure_type(fragment),
)
</pre></div>
</div>
<p>def get_host(url):
“””
Deprecated. Use :func:<code class="docutils literal notranslate"><span class="pre">parse_url</span></code> instead.
“””
p = parse_url(url)
return p.scheme or “http”, p.hostname, p.port</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>