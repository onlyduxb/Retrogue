

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SPDX-License-Identifier: MIT &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SPDX-License-Identifier: MIT</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/tomli/_parser.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="spdx-license-identifier-mit">
<h1>SPDX-License-Identifier: MIT<a class="headerlink" href="#spdx-license-identifier-mit" title="Link to this heading"></a></h1>
</section>
<section id="spdx-filecopyrighttext-2021-taneli-hukkinen">
<h1>SPDX-FileCopyrightText: 2021 Taneli Hukkinen<a class="headerlink" href="#spdx-filecopyrighttext-2021-taneli-hukkinen" title="Link to this heading"></a></h1>
</section>
<section id="licensed-to-psf-under-a-contributor-agreement">
<h1>Licensed to PSF under a Contributor Agreement.<a class="headerlink" href="#licensed-to-psf-under-a-contributor-agreement" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import annotations</p>
<p>import sys
from types import MappingProxyType</p>
<p>from ._re import (
RE_DATETIME,
RE_LOCALTIME,
RE_NUMBER,
match_to_datetime,
match_to_localtime,
match_to_number,
)</p>
<p>TYPE_CHECKING = False
if TYPE_CHECKING:
from collections.abc import Iterable
from typing import IO, Any, Final</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from ._types import Key, ParseFloat, Pos
</pre></div>
</div>
</section>
<section id="inline-tables-arrays-are-implemented-using-recursion-pathologically">
<h1>Inline tables/arrays are implemented using recursion. Pathologically<a class="headerlink" href="#inline-tables-arrays-are-implemented-using-recursion-pathologically" title="Link to this heading"></a></h1>
</section>
<section id="nested-documents-cause-pure-python-to-raise-recursionerror-which-is-ok">
<h1>nested documents cause pure Python to raise RecursionError (which is OK),<a class="headerlink" href="#nested-documents-cause-pure-python-to-raise-recursionerror-which-is-ok" title="Link to this heading"></a></h1>
</section>
<section id="but-mypyc-binary-wheels-will-crash-unrecoverably-not-ok-according-to">
<h1>but mypyc binary wheels will crash unrecoverably (not OK). According to<a class="headerlink" href="#but-mypyc-binary-wheels-will-crash-unrecoverably-not-ok-according-to" title="Link to this heading"></a></h1>
</section>
<section id="mypyc-docs-this-will-be-fixed-in-the-future">
<h1>mypyc docs this will be fixed in the future:<a class="headerlink" href="#mypyc-docs-this-will-be-fixed-in-the-future" title="Link to this heading"></a></h1>
</section>
<section id="https-mypyc-readthedocs-io-en-latest-differences-from-python-html-stack-overflows">
<h1>https://mypyc.readthedocs.io/en/latest/differences_from_python.html#stack-overflows<a class="headerlink" href="#https-mypyc-readthedocs-io-en-latest-differences-from-python-html-stack-overflows" title="Link to this heading"></a></h1>
</section>
<section id="before-mypyc-s-fix-is-in-recursion-needs-to-be-limited-by-this-library">
<h1>Before mypyc’s fix is in, recursion needs to be limited by this library.<a class="headerlink" href="#before-mypyc-s-fix-is-in-recursion-needs-to-be-limited-by-this-library" title="Link to this heading"></a></h1>
</section>
<section id="choosing-sys-getrecursionlimit-as-maximum-inline-table-array-nesting">
<h1>Choosing <code class="docutils literal notranslate"><span class="pre">sys.getrecursionlimit()</span></code> as maximum inline table/array nesting<a class="headerlink" href="#choosing-sys-getrecursionlimit-as-maximum-inline-table-array-nesting" title="Link to this heading"></a></h1>
</section>
<section id="level-as-it-allows-more-nesting-than-pure-python-but-still-seems-a-far">
<h1>level, as it allows more nesting than pure Python, but still seems a far<a class="headerlink" href="#level-as-it-allows-more-nesting-than-pure-python-but-still-seems-a-far" title="Link to this heading"></a></h1>
</section>
<section id="lower-number-than-where-mypyc-binaries-crash">
<h1>lower number than where mypyc binaries crash.<a class="headerlink" href="#lower-number-than-where-mypyc-binaries-crash" title="Link to this heading"></a></h1>
<p>MAX_INLINE_NESTING: Final = sys.getrecursionlimit()</p>
<p>ASCII_CTRL: Final = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))</p>
</section>
<section id="neither-of-these-sets-include-quotation-mark-or-backslash-they-are">
<h1>Neither of these sets include quotation mark or backslash. They are<a class="headerlink" href="#neither-of-these-sets-include-quotation-mark-or-backslash-they-are" title="Link to this heading"></a></h1>
</section>
<section id="currently-handled-as-separate-cases-in-the-parser-functions">
<h1>currently handled as separate cases in the parser functions.<a class="headerlink" href="#currently-handled-as-separate-cases-in-the-parser-functions" title="Link to this heading"></a></h1>
<p>ILLEGAL_BASIC_STR_CHARS: Final = ASCII_CTRL - frozenset(“\t”)
ILLEGAL_MULTILINE_BASIC_STR_CHARS: Final = ASCII_CTRL - frozenset(“\t\n”)</p>
<p>ILLEGAL_LITERAL_STR_CHARS: Final = ILLEGAL_BASIC_STR_CHARS
ILLEGAL_MULTILINE_LITERAL_STR_CHARS: Final = ILLEGAL_MULTILINE_BASIC_STR_CHARS</p>
<p>ILLEGAL_COMMENT_CHARS: Final = ILLEGAL_BASIC_STR_CHARS</p>
<p>TOML_WS: Final = frozenset(” \t”)
TOML_WS_AND_NEWLINE: Final = TOML_WS | frozenset(“\n”)
BARE_KEY_CHARS: Final = frozenset(
“abcdefghijklmnopqrstuvwxyz” “ABCDEFGHIJKLMNOPQRSTUVWXYZ” “0123456789” “-_”
)
KEY_INITIAL_CHARS: Final = BARE_KEY_CHARS | frozenset(“”’”)
HEXDIGIT_CHARS: Final = frozenset(“abcdef” “ABCDEF” “0123456789”)</p>
<p>BASIC_STR_ESCAPE_REPLACEMENTS: Final = MappingProxyType(
{
“\b”: “\u0008”,  # backspace
“\t”: “\u0009”,  # tab
“\n”: “\u000a”,  # linefeed
“\f”: “\u000c”,  # form feed
“\r”: “\u000d”,  # carriage return
‘&quot;’: “\u0022”,  # quote
“\”: “\u005c”,  # backslash
}
)</p>
<p>class DEPRECATED_DEFAULT:
“””Sentinel to be used as default arg during deprecation
period of TOMLDecodeError’s free-form arguments.”””</p>
<p>class TOMLDecodeError(ValueError):
“””An error raised if a document is not valid TOML.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Adds the following attributes to ValueError:
msg: The unformatted error message
doc: The TOML document being parsed
pos: The index of doc where parsing failed
lineno: The line corresponding to pos
colno: The column corresponding to pos
&quot;&quot;&quot;

def __init__(
    self,
    msg: str | type[DEPRECATED_DEFAULT] = DEPRECATED_DEFAULT,
    doc: str | type[DEPRECATED_DEFAULT] = DEPRECATED_DEFAULT,
    pos: Pos | type[DEPRECATED_DEFAULT] = DEPRECATED_DEFAULT,
    *args: Any,
):
    if (
        args
        or not isinstance(msg, str)
        or not isinstance(doc, str)
        or not isinstance(pos, int)
    ):
        import warnings

        warnings.warn(
            &quot;Free-form arguments for TOMLDecodeError are deprecated. &quot;
            &quot;Please set &#39;msg&#39; (str), &#39;doc&#39; (str) and &#39;pos&#39; (int) arguments only.&quot;,
            DeprecationWarning,
            stacklevel=2,
        )
        if pos is not DEPRECATED_DEFAULT:
            args = pos, *args
        if doc is not DEPRECATED_DEFAULT:
            args = doc, *args
        if msg is not DEPRECATED_DEFAULT:
            args = msg, *args
        ValueError.__init__(self, *args)
        return

    lineno = doc.count(&quot;\n&quot;, 0, pos) + 1
    if lineno == 1:
        colno = pos + 1
    else:
        colno = pos - doc.rindex(&quot;\n&quot;, 0, pos)

    if pos &gt;= len(doc):
        coord_repr = &quot;end of document&quot;
    else:
        coord_repr = f&quot;line {lineno}, column {colno}&quot;
    errmsg = f&quot;{msg} (at {coord_repr})&quot;
    ValueError.__init__(self, errmsg)

    self.msg = msg
    self.doc = doc
    self.pos = pos
    self.lineno = lineno
    self.colno = colno
</pre></div>
</div>
<p>def load(__fp: IO[bytes], *, parse_float: ParseFloat = float) -&gt; dict[str, Any]:
“””Parse TOML from a binary file object.”””
b = __fp.read()
try:
s = b.decode()
except AttributeError:
raise TypeError(
“File must be opened in binary mode, e.g. use <code class="docutils literal notranslate"><span class="pre">open('foo.toml',</span> <span class="pre">'rb')</span></code>”
) from None
return loads(s, parse_float=parse_float)</p>
<p>def loads(__s: str, *, parse_float: ParseFloat = float) -&gt; dict[str, Any]:  # noqa: C901
“””Parse TOML from a string.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># The spec allows converting &quot;\r\n&quot; to &quot;\n&quot;, even in string
# literals. Let&#39;s do so to simplify parsing.
try:
    src = __s.replace(&quot;\r\n&quot;, &quot;\n&quot;)
except (AttributeError, TypeError):
    raise TypeError(
        f&quot;Expected str object, not &#39;{type(__s).__qualname__}&#39;&quot;
    ) from None
pos = 0
out = Output()
header: Key = ()
parse_float = make_safe_parse_float(parse_float)

# Parse one statement at a time
# (typically means one line in TOML source)
while True:
    # 1. Skip line leading whitespace
    pos = skip_chars(src, pos, TOML_WS)

    # 2. Parse rules. Expect one of the following:
    #    - end of file
    #    - end of line
    #    - comment
    #    - key/value pair
    #    - append dict to list (and move to its namespace)
    #    - create dict (and move to its namespace)
    # Skip trailing whitespace when applicable.
    try:
        char = src[pos]
    except IndexError:
        break
    if char == &quot;\n&quot;:
        pos += 1
        continue
    if char in KEY_INITIAL_CHARS:
        pos = key_value_rule(src, pos, out, header, parse_float)
        pos = skip_chars(src, pos, TOML_WS)
    elif char == &quot;[&quot;:
        try:
            second_char: str | None = src[pos + 1]
        except IndexError:
            second_char = None
        out.flags.finalize_pending()
        if second_char == &quot;[&quot;:
            pos, header = create_list_rule(src, pos, out)
        else:
            pos, header = create_dict_rule(src, pos, out)
        pos = skip_chars(src, pos, TOML_WS)
    elif char != &quot;#&quot;:
        raise TOMLDecodeError(&quot;Invalid statement&quot;, src, pos)

    # 3. Skip comment
    pos = skip_comment(src, pos)

    # 4. Expect end of line or end of file
    try:
        char = src[pos]
    except IndexError:
        break
    if char != &quot;\n&quot;:
        raise TOMLDecodeError(
            &quot;Expected newline or end of document after a statement&quot;, src, pos
        )
    pos += 1

return out.data.dict
</pre></div>
</div>
<p>class Flags:
“””Flags that map to parsed keys/namespaces.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Marks an immutable namespace (inline array or inline table).
FROZEN: Final = 0
# Marks a nest that has been explicitly created and can no longer
# be opened using the &quot;[table]&quot; syntax.
EXPLICIT_NEST: Final = 1

def __init__(self) -&gt; None:
    self._flags: dict[str, dict[Any, Any]] = {}
    self._pending_flags: set[tuple[Key, int]] = set()

def add_pending(self, key: Key, flag: int) -&gt; None:
    self._pending_flags.add((key, flag))

def finalize_pending(self) -&gt; None:
    for key, flag in self._pending_flags:
        self.set(key, flag, recursive=False)
    self._pending_flags.clear()

def unset_all(self, key: Key) -&gt; None:
    cont = self._flags
    for k in key[:-1]:
        if k not in cont:
            return
        cont = cont[k][&quot;nested&quot;]
    cont.pop(key[-1], None)

def set(self, key: Key, flag: int, *, recursive: bool) -&gt; None:  # noqa: A003
    cont = self._flags
    key_parent, key_stem = key[:-1], key[-1]
    for k in key_parent:
        if k not in cont:
            cont[k] = {&quot;flags&quot;: set(), &quot;recursive_flags&quot;: set(), &quot;nested&quot;: {}}
        cont = cont[k][&quot;nested&quot;]
    if key_stem not in cont:
        cont[key_stem] = {&quot;flags&quot;: set(), &quot;recursive_flags&quot;: set(), &quot;nested&quot;: {}}
    cont[key_stem][&quot;recursive_flags&quot; if recursive else &quot;flags&quot;].add(flag)

def is_(self, key: Key, flag: int) -&gt; bool:
    if not key:
        return False  # document root has no flags
    cont = self._flags
    for k in key[:-1]:
        if k not in cont:
            return False
        inner_cont = cont[k]
        if flag in inner_cont[&quot;recursive_flags&quot;]:
            return True
        cont = inner_cont[&quot;nested&quot;]
    key_stem = key[-1]
    if key_stem in cont:
        inner_cont = cont[key_stem]
        return flag in inner_cont[&quot;flags&quot;] or flag in inner_cont[&quot;recursive_flags&quot;]
    return False
</pre></div>
</div>
<p>class NestedDict:
def <strong>init</strong>(self) -&gt; None:
# The parsed content of the TOML document
self.dict: dict[str, Any] = {}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def get_or_create_nest(
    self,
    key: Key,
    *,
    access_lists: bool = True,
) -&gt; dict[str, Any]:
    cont: Any = self.dict
    for k in key:
        if k not in cont:
            cont[k] = {}
        cont = cont[k]
        if access_lists and isinstance(cont, list):
            cont = cont[-1]
        if not isinstance(cont, dict):
            raise KeyError(&quot;There is no nest behind this key&quot;)
    return cont  # type: ignore[no-any-return]

def append_nest_to_list(self, key: Key) -&gt; None:
    cont = self.get_or_create_nest(key[:-1])
    last_key = key[-1]
    if last_key in cont:
        list_ = cont[last_key]
        if not isinstance(list_, list):
            raise KeyError(&quot;An object other than list found behind this key&quot;)
        list_.append({})
    else:
        cont[last_key] = [{}]
</pre></div>
</div>
<p>class Output:
def <strong>init</strong>(self) -&gt; None:
self.data = NestedDict()
self.flags = Flags()</p>
<p>def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -&gt; Pos:
try:
while src[pos] in chars:
pos += 1
except IndexError:
pass
return pos</p>
<p>def skip_until(
src: str,
pos: Pos,
expect: str,
*,
error_on: frozenset[str],
error_on_eof: bool,
) -&gt; Pos:
try:
new_pos = src.index(expect, pos)
except ValueError:
new_pos = len(src)
if error_on_eof:
raise TOMLDecodeError(f”Expected {expect!r}”, src, new_pos) from None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if not error_on.isdisjoint(src[pos:new_pos]):
    while src[pos] not in error_on:
        pos += 1
    raise TOMLDecodeError(f&quot;Found invalid character {src[pos]!r}&quot;, src, pos)
return new_pos
</pre></div>
</div>
<p>def skip_comment(src: str, pos: Pos) -&gt; Pos:
try:
char: str | None = src[pos]
except IndexError:
char = None
if char == “#”:
return skip_until(
src, pos + 1, “\n”, error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False
)
return pos</p>
<p>def skip_comments_and_array_ws(src: str, pos: Pos) -&gt; Pos:
while True:
pos_before_skip = pos
pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)
pos = skip_comment(src, pos)
if pos == pos_before_skip:
return pos</p>
<p>def create_dict_rule(src: str, pos: Pos, out: Output) -&gt; tuple[Pos, Key]:
pos += 1  # Skip “[”
pos = skip_chars(src, pos, TOML_WS)
pos, key = parse_key(src, pos)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):
    raise TOMLDecodeError(f&quot;Cannot declare {key} twice&quot;, src, pos)
out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)
try:
    out.data.get_or_create_nest(key)
except KeyError:
    raise TOMLDecodeError(&quot;Cannot overwrite a value&quot;, src, pos) from None

if not src.startswith(&quot;]&quot;, pos):
    raise TOMLDecodeError(
        &quot;Expected &#39;]&#39; at the end of a table declaration&quot;, src, pos
    )
return pos + 1, key
</pre></div>
</div>
<p>def create_list_rule(src: str, pos: Pos, out: Output) -&gt; tuple[Pos, Key]:
pos += 2  # Skip “[[”
pos = skip_chars(src, pos, TOML_WS)
pos, key = parse_key(src, pos)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if out.flags.is_(key, Flags.FROZEN):
    raise TOMLDecodeError(f&quot;Cannot mutate immutable namespace {key}&quot;, src, pos)
# Free the namespace now that it points to another empty list item...
out.flags.unset_all(key)
# ...but this key precisely is still prohibited from table declaration
out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)
try:
    out.data.append_nest_to_list(key)
except KeyError:
    raise TOMLDecodeError(&quot;Cannot overwrite a value&quot;, src, pos) from None

if not src.startswith(&quot;]]&quot;, pos):
    raise TOMLDecodeError(
        &quot;Expected &#39;]]&#39; at the end of an array declaration&quot;, src, pos
    )
return pos + 2, key
</pre></div>
</div>
<p>def key_value_rule(
src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat
) -&gt; Pos:
pos, key, value = parse_key_value_pair(src, pos, parse_float, nest_lvl=0)
key_parent, key_stem = key[:-1], key[-1]
abs_key_parent = header + key_parent</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))
for cont_key in relative_path_cont_keys:
    # Check that dotted key syntax does not redefine an existing table
    if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):
        raise TOMLDecodeError(f&quot;Cannot redefine namespace {cont_key}&quot;, src, pos)
    # Containers in the relative path can&#39;t be opened with the table syntax or
    # dotted key/value syntax in following table sections.
    out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)

if out.flags.is_(abs_key_parent, Flags.FROZEN):
    raise TOMLDecodeError(
        f&quot;Cannot mutate immutable namespace {abs_key_parent}&quot;, src, pos
    )

try:
    nest = out.data.get_or_create_nest(abs_key_parent)
except KeyError:
    raise TOMLDecodeError(&quot;Cannot overwrite a value&quot;, src, pos) from None
if key_stem in nest:
    raise TOMLDecodeError(&quot;Cannot overwrite a value&quot;, src, pos)
# Mark inline table and array namespaces recursively immutable
if isinstance(value, (dict, list)):
    out.flags.set(header + key, Flags.FROZEN, recursive=True)
nest[key_stem] = value
return pos
</pre></div>
</div>
<p>def parse_key_value_pair(
src: str, pos: Pos, parse_float: ParseFloat, nest_lvl: int
) -&gt; tuple[Pos, Key, Any]:
pos, key = parse_key(src, pos)
try:
char: str | None = src[pos]
except IndexError:
char = None
if char != “=”:
raise TOMLDecodeError(“Expected ‘=’ after a key in a key/value pair”, src, pos)
pos += 1
pos = skip_chars(src, pos, TOML_WS)
pos, value = parse_value(src, pos, parse_float, nest_lvl)
return pos, key, value</p>
<p>def parse_key(src: str, pos: Pos) -&gt; tuple[Pos, Key]:
pos, key_part = parse_key_part(src, pos)
key: Key = (key_part,)
pos = skip_chars(src, pos, TOML_WS)
while True:
try:
char: str | None = src[pos]
except IndexError:
char = None
if char != “.”:
return pos, key
pos += 1
pos = skip_chars(src, pos, TOML_WS)
pos, key_part = parse_key_part(src, pos)
key += (key_part,)
pos = skip_chars(src, pos, TOML_WS)</p>
<p>def parse_key_part(src: str, pos: Pos) -&gt; tuple[Pos, str]:
try:
char: str | None = src[pos]
except IndexError:
char = None
if char in BARE_KEY_CHARS:
start_pos = pos
pos = skip_chars(src, pos, BARE_KEY_CHARS)
return pos, src[start_pos:pos]
if char == “’”:
return parse_literal_str(src, pos)
if char == ‘”’:
return parse_one_line_basic_str(src, pos)
raise TOMLDecodeError(“Invalid initial character for a key part”, src, pos)</p>
<p>def parse_one_line_basic_str(src: str, pos: Pos) -&gt; tuple[Pos, str]:
pos += 1
return parse_basic_str(src, pos, multiline=False)</p>
<p>def parse_array(
src: str, pos: Pos, parse_float: ParseFloat, nest_lvl: int
) -&gt; tuple[Pos, list[Any]]:
pos += 1
array: list[Any] = []</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos = skip_comments_and_array_ws(src, pos)
if src.startswith(&quot;]&quot;, pos):
    return pos + 1, array
while True:
    pos, val = parse_value(src, pos, parse_float, nest_lvl)
    array.append(val)
    pos = skip_comments_and_array_ws(src, pos)

    c = src[pos : pos + 1]
    if c == &quot;]&quot;:
        return pos + 1, array
    if c != &quot;,&quot;:
        raise TOMLDecodeError(&quot;Unclosed array&quot;, src, pos)
    pos += 1

    pos = skip_comments_and_array_ws(src, pos)
    if src.startswith(&quot;]&quot;, pos):
        return pos + 1, array
</pre></div>
</div>
<p>def parse_inline_table(
src: str, pos: Pos, parse_float: ParseFloat, nest_lvl: int
) -&gt; tuple[Pos, dict[str, Any]]:
pos += 1
nested_dict = NestedDict()
flags = Flags()</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pos = skip_chars(src, pos, TOML_WS)
if src.startswith(&quot;}&quot;, pos):
    return pos + 1, nested_dict.dict
while True:
    pos, key, value = parse_key_value_pair(src, pos, parse_float, nest_lvl)
    key_parent, key_stem = key[:-1], key[-1]
    if flags.is_(key, Flags.FROZEN):
        raise TOMLDecodeError(f&quot;Cannot mutate immutable namespace {key}&quot;, src, pos)
    try:
        nest = nested_dict.get_or_create_nest(key_parent, access_lists=False)
    except KeyError:
        raise TOMLDecodeError(&quot;Cannot overwrite a value&quot;, src, pos) from None
    if key_stem in nest:
        raise TOMLDecodeError(f&quot;Duplicate inline table key {key_stem!r}&quot;, src, pos)
    nest[key_stem] = value
    pos = skip_chars(src, pos, TOML_WS)
    c = src[pos : pos + 1]
    if c == &quot;}&quot;:
        return pos + 1, nested_dict.dict
    if c != &quot;,&quot;:
        raise TOMLDecodeError(&quot;Unclosed inline table&quot;, src, pos)
    if isinstance(value, (dict, list)):
        flags.set(key, Flags.FROZEN, recursive=True)
    pos += 1
    pos = skip_chars(src, pos, TOML_WS)
</pre></div>
</div>
<p>def parse_basic_str_escape(
src: str, pos: Pos, *, multiline: bool = False
) -&gt; tuple[Pos, str]:
escape_id = src[pos : pos + 2]
pos += 2
if multiline and escape_id in {”\ “, “\t”, “\n”}:
# Skip whitespace until next non-whitespace character or end of
# the doc. Error if non-whitespace is found before newline.
if escape_id != “\n”:
pos = skip_chars(src, pos, TOML_WS)
try:
char = src[pos]
except IndexError:
return pos, “”
if char != “\n”:
raise TOMLDecodeError(“Unescaped ‘' in a string”, src, pos)
pos += 1
pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)
return pos, “”
if escape_id == “\u”:
return parse_hex_char(src, pos, 4)
if escape_id == “\U”:
return parse_hex_char(src, pos, 8)
try:
return pos, BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]
except KeyError:
raise TOMLDecodeError(“Unescaped ‘' in a string”, src, pos) from None</p>
<p>def parse_basic_str_escape_multiline(src: str, pos: Pos) -&gt; tuple[Pos, str]:
return parse_basic_str_escape(src, pos, multiline=True)</p>
<p>def parse_hex_char(src: str, pos: Pos, hex_len: int) -&gt; tuple[Pos, str]:
hex_str = src[pos : pos + hex_len]
if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):
raise TOMLDecodeError(“Invalid hex value”, src, pos)
pos += hex_len
hex_int = int(hex_str, 16)
if not is_unicode_scalar_value(hex_int):
raise TOMLDecodeError(
“Escaped character is not a Unicode scalar value”, src, pos
)
return pos, chr(hex_int)</p>
<p>def parse_literal_str(src: str, pos: Pos) -&gt; tuple[Pos, str]:
pos += 1  # Skip starting apostrophe
start_pos = pos
pos = skip_until(
src, pos, “’”, error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True
)
return pos + 1, src[start_pos:pos]  # Skip ending apostrophe</p>
<p>def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -&gt; tuple[Pos, str]:
pos += 3
if src.startswith(“\n”, pos):
pos += 1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if literal:
    delim = &quot;&#39;&quot;
    end_pos = skip_until(
        src,
        pos,
        &quot;&#39;&#39;&#39;&quot;,
        error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,
        error_on_eof=True,
    )
    result = src[pos:end_pos]
    pos = end_pos + 3
else:
    delim = &#39;&quot;&#39;
    pos, result = parse_basic_str(src, pos, multiline=True)

# Add at maximum two extra apostrophes/quotes if the end sequence
# is 4 or 5 chars long instead of just 3.
if not src.startswith(delim, pos):
    return pos, result
pos += 1
if not src.startswith(delim, pos):
    return pos, result + delim
pos += 1
return pos, result + (delim * 2)
</pre></div>
</div>
<p>def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -&gt; tuple[Pos, str]:
if multiline:
error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS
parse_escapes = parse_basic_str_escape_multiline
else:
error_on = ILLEGAL_BASIC_STR_CHARS
parse_escapes = parse_basic_str_escape
result = “”
start_pos = pos
while True:
try:
char = src[pos]
except IndexError:
raise TOMLDecodeError(“Unterminated string”, src, pos) from None
if char == ‘”’:
if not multiline:
return pos + 1, result + src[start_pos:pos]
if src.startswith(‘”””’, pos):
return pos + 3, result + src[start_pos:pos]
pos += 1
continue
if char == “&quot;:
result += src[start_pos:pos]
pos, parsed_escape = parse_escapes(src, pos)
result += parsed_escape
start_pos = pos
continue
if char in error_on:
raise TOMLDecodeError(f”Illegal character {char!r}”, src, pos)
pos += 1</p>
<p>def parse_value(  # noqa: C901
src: str, pos: Pos, parse_float: ParseFloat, nest_lvl: int
) -&gt; tuple[Pos, Any]:
if nest_lvl &gt; MAX_INLINE_NESTING:
# Pure Python should have raised RecursionError already.
# This ensures mypyc binaries eventually do the same.
raise RecursionError(  # pragma: no cover
“TOML inline arrays/tables are nested more than the allowed”
f” {MAX_INLINE_NESTING} levels”
)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>try:
    char: str | None = src[pos]
except IndexError:
    char = None

# IMPORTANT: order conditions based on speed of checking and likelihood

# Basic strings
if char == &#39;&quot;&#39;:
    if src.startswith(&#39;&quot;&quot;&quot;&#39;, pos):
        return parse_multiline_str(src, pos, literal=False)
    return parse_one_line_basic_str(src, pos)

# Literal strings
if char == &quot;&#39;&quot;:
    if src.startswith(&quot;&#39;&#39;&#39;&quot;, pos):
        return parse_multiline_str(src, pos, literal=True)
    return parse_literal_str(src, pos)

# Booleans
if char == &quot;t&quot;:
    if src.startswith(&quot;true&quot;, pos):
        return pos + 4, True
if char == &quot;f&quot;:
    if src.startswith(&quot;false&quot;, pos):
        return pos + 5, False

# Arrays
if char == &quot;[&quot;:
    return parse_array(src, pos, parse_float, nest_lvl + 1)

# Inline tables
if char == &quot;{&quot;:
    return parse_inline_table(src, pos, parse_float, nest_lvl + 1)

# Dates and times
datetime_match = RE_DATETIME.match(src, pos)
if datetime_match:
    try:
        datetime_obj = match_to_datetime(datetime_match)
    except ValueError as e:
        raise TOMLDecodeError(&quot;Invalid date or datetime&quot;, src, pos) from e
    return datetime_match.end(), datetime_obj
localtime_match = RE_LOCALTIME.match(src, pos)
if localtime_match:
    return localtime_match.end(), match_to_localtime(localtime_match)

# Integers and &quot;normal&quot; floats.
# The regex will greedily match any type starting with a decimal
# char, so needs to be located after handling of dates and times.
number_match = RE_NUMBER.match(src, pos)
if number_match:
    return number_match.end(), match_to_number(number_match, parse_float)

# Special floats
first_three = src[pos : pos + 3]
if first_three in {&quot;inf&quot;, &quot;nan&quot;}:
    return pos + 3, parse_float(first_three)
first_four = src[pos : pos + 4]
if first_four in {&quot;-inf&quot;, &quot;+inf&quot;, &quot;-nan&quot;, &quot;+nan&quot;}:
    return pos + 4, parse_float(first_four)

raise TOMLDecodeError(&quot;Invalid value&quot;, src, pos)
</pre></div>
</div>
<p>def is_unicode_scalar_value(codepoint: int) -&gt; bool:
return (0 &lt;= codepoint &lt;= 55295) or (57344 &lt;= codepoint &lt;= 1114111)</p>
<p>def make_safe_parse_float(parse_float: ParseFloat) -&gt; ParseFloat:
“””A decorator to make <code class="docutils literal notranslate"><span class="pre">parse_float</span></code> safe.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>`parse_float` must not return dicts or lists, because these types
would be mixed with parsed TOML tables and arrays, thus confusing
the parser. The returned decorated callable raises `ValueError`
instead of returning illegal types.
&quot;&quot;&quot;
# The default `float` callable never returns illegal types. Optimize it.
if parse_float is float:
    return float

def safe_parse_float(float_str: str) -&gt; Any:
    float_value = parse_float(float_str)
    if isinstance(float_value, (dict, list)):
        raise ValueError(&quot;parse_float must not return dicts or lists&quot;)
    return float_value

return safe_parse_float
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>