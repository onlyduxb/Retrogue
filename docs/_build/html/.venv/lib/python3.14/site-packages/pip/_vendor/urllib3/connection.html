

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>When it comes time to update this value as a part of regular maintenance &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">When it comes time to update this value as a part of regular maintenance</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/connection.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import absolute_import</p>
<p>import datetime
import logging
import os
import re
import socket
import warnings
from socket import error as SocketError
from socket import timeout as SocketTimeout</p>
<p>from .packages import six
from .packages.six.moves.http_client import HTTPConnection as _HTTPConnection
from .packages.six.moves.http_client import HTTPException  # noqa: F401
from .util.proxy import create_proxy_ssl_context</p>
<p>try:  # Compiled with SSL?
import ssl</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>BaseSSLError = ssl.SSLError
</pre></div>
</div>
<p>except (ImportError, AttributeError):  # Platform-specific: No SSL.
ssl = None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class BaseSSLError(BaseException):
    pass
</pre></div>
</div>
<p>try:
# Python 3: not a no-op, we’re adding this to the namespace so it can be imported.
ConnectionError = ConnectionError
except NameError:
# Python 2
class ConnectionError(Exception):
pass</p>
<p>try:  # Python 3:
# Not a no-op, we’re adding this to the namespace so it can be imported.
BrokenPipeError = BrokenPipeError
except NameError:  # Python 2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class BrokenPipeError(Exception):
    pass
</pre></div>
</div>
<p>from ._collections import HTTPHeaderDict  # noqa (historical, removed in v2)
from .<em>version import <strong>version</strong>
from .exceptions import (
ConnectTimeoutError,
NewConnectionError,
SubjectAltNameWarning,
SystemTimeWarning,
)
from .util import SKIP_HEADER, SKIPPABLE_HEADERS, connection
from .util.ssl</em> import (
assert_fingerprint,
create_urllib3_context,
is_ipaddress,
resolve_cert_reqs,
resolve_ssl_version,
ssl_wrap_socket,
)
from .util.ssl_match_hostname import CertificateError, match_hostname</p>
<p>log = logging.getLogger(<strong>name</strong>)</p>
<p>port_by_scheme = {“http”: 80, “https”: 443}</p>
<section id="when-it-comes-time-to-update-this-value-as-a-part-of-regular-maintenance">
<h1>When it comes time to update this value as a part of regular maintenance<a class="headerlink" href="#when-it-comes-time-to-update-this-value-as-a-part-of-regular-maintenance" title="Link to this heading"></a></h1>
</section>
<section id="ie-test-recent-date-is-failing-update-it-to-6-months-before-the-current-date">
<h1>(ie test_recent_date is failing) update it to ~6 months before the current date.<a class="headerlink" href="#ie-test-recent-date-is-failing-update-it-to-6-months-before-the-current-date" title="Link to this heading"></a></h1>
<p>RECENT_DATE = datetime.date(2024, 1, 1)</p>
<p>_CONTAINS_CONTROL_CHAR_RE = re.compile(r”<a href="#id3"><span class="problematic" id="id1">[^-!#$%&amp;'*+.^_`|~0-9a-zA-Z]</span></a>”)</p>
<p>class HTTPConnection(_HTTPConnection, object):
“””
Based on :class:<code class="docutils literal notranslate"><span class="pre">http.client.HTTPConnection</span></code> but provides an extra constructor
backwards-compatibility layer between older and newer Pythons.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Additional keyword parameters are used to configure attributes of the connection.
Accepted parameters include:

- ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`
- ``source_address``: Set the source address for the current connection.
- ``socket_options``: Set specific options on the underlying socket. If not specified, then
  defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling
  Nagle&#39;s algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.

  For example, if you wish to enable TCP Keep Alive in addition to the defaults,
  you might pass:

  .. code-block:: python

     HTTPConnection.default_socket_options + [
         (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
     ]

  Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).
&quot;&quot;&quot;

default_port = port_by_scheme[&quot;http&quot;]

#: Disable Nagle&#39;s algorithm by default.
#: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``
default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]

#: Whether this connection verifies the host&#39;s certificate.
is_verified = False

#: Whether this proxy connection (if used) verifies the proxy host&#39;s
#: certificate.
proxy_is_verified = None

def __init__(self, *args, **kw):
    if not six.PY2:
        kw.pop(&quot;strict&quot;, None)

    # Pre-set source_address.
    self.source_address = kw.get(&quot;source_address&quot;)

    #: The socket options provided by the user. If no options are
    #: provided, we use the default options.
    self.socket_options = kw.pop(&quot;socket_options&quot;, self.default_socket_options)

    # Proxy options provided by the user.
    self.proxy = kw.pop(&quot;proxy&quot;, None)
    self.proxy_config = kw.pop(&quot;proxy_config&quot;, None)

    _HTTPConnection.__init__(self, *args, **kw)

@property
def host(self):
    &quot;&quot;&quot;
    Getter method to remove any trailing dots that indicate the hostname is an FQDN.

    In general, SSL certificates don&#39;t include the trailing dot indicating a
    fully-qualified domain name, and thus, they don&#39;t validate properly when
    checked against a domain name that includes the dot. In addition, some
    servers may not expect to receive the trailing dot when provided.

    However, the hostname with trailing dot is critical to DNS resolution; doing a
    lookup with the trailing dot will properly only resolve the appropriate FQDN,
    whereas a lookup without a trailing dot will search the system&#39;s search domain
    list. Thus, it&#39;s important to keep the original host around for use only in
    those cases where it&#39;s appropriate (i.e., when doing DNS lookup to establish the
    actual TCP connection across which we&#39;re going to send HTTP requests).
    &quot;&quot;&quot;
    return self._dns_host.rstrip(&quot;.&quot;)

@host.setter
def host(self, value):
    &quot;&quot;&quot;
    Setter for the `host` property.

    We assume that only urllib3 uses the _dns_host attribute; httplib itself
    only uses `host`, and it seems reasonable that other libraries follow suit.
    &quot;&quot;&quot;
    self._dns_host = value

def _new_conn(self):
    &quot;&quot;&quot;Establish a socket connection and set nodelay settings on it.

    :return: New socket connection.
    &quot;&quot;&quot;
    extra_kw = {}
    if self.source_address:
        extra_kw[&quot;source_address&quot;] = self.source_address

    if self.socket_options:
        extra_kw[&quot;socket_options&quot;] = self.socket_options

    try:
        conn = connection.create_connection(
            (self._dns_host, self.port), self.timeout, **extra_kw
        )

    except SocketTimeout:
        raise ConnectTimeoutError(
            self,
            &quot;Connection to %s timed out. (connect timeout=%s)&quot;
            % (self.host, self.timeout),
        )

    except SocketError as e:
        raise NewConnectionError(
            self, &quot;Failed to establish a new connection: %s&quot; % e
        )

    return conn

def _is_using_tunnel(self):
    # Google App Engine&#39;s httplib does not define _tunnel_host
    return getattr(self, &quot;_tunnel_host&quot;, None)

def _prepare_conn(self, conn):
    self.sock = conn
    if self._is_using_tunnel():
        # TODO: Fix tunnel so it doesn&#39;t depend on self.sock state.
        self._tunnel()
        # Mark this connection as not reusable
        self.auto_open = 0

def connect(self):
    conn = self._new_conn()
    self._prepare_conn(conn)

def putrequest(self, method, url, *args, **kwargs):
    &quot;&quot;&quot; &quot;&quot;&quot;
    # Empty docstring because the indentation of CPython&#39;s implementation
    # is broken but we don&#39;t want this method in our documentation.
    match = _CONTAINS_CONTROL_CHAR_RE.search(method)
    if match:
        raise ValueError(
            &quot;Method cannot contain non-token characters %r (found at least %r)&quot;
            % (method, match.group())
        )

    return _HTTPConnection.putrequest(self, method, url, *args, **kwargs)

def putheader(self, header, *values):
    &quot;&quot;&quot; &quot;&quot;&quot;
    if not any(isinstance(v, str) and v == SKIP_HEADER for v in values):
        _HTTPConnection.putheader(self, header, *values)
    elif six.ensure_str(header.lower()) not in SKIPPABLE_HEADERS:
        raise ValueError(
            &quot;urllib3.util.SKIP_HEADER only supports &#39;%s&#39;&quot;
            % (&quot;&#39;, &#39;&quot;.join(map(str.title, sorted(SKIPPABLE_HEADERS))),)
        )

def request(self, method, url, body=None, headers=None):
    # Update the inner socket&#39;s timeout value to send the request.
    # This only triggers if the connection is re-used.
    if getattr(self, &quot;sock&quot;, None) is not None:
        self.sock.settimeout(self.timeout)

    if headers is None:
        headers = {}
    else:
        # Avoid modifying the headers passed into .request()
        headers = headers.copy()
    if &quot;user-agent&quot; not in (six.ensure_str(k.lower()) for k in headers):
        headers[&quot;User-Agent&quot;] = _get_default_user_agent()
    super(HTTPConnection, self).request(method, url, body=body, headers=headers)

def request_chunked(self, method, url, body=None, headers=None):
    &quot;&quot;&quot;
    Alternative to the common request method, which sends the
    body with chunked encoding and not as one block
    &quot;&quot;&quot;
    headers = headers or {}
    header_keys = set([six.ensure_str(k.lower()) for k in headers])
    skip_accept_encoding = &quot;accept-encoding&quot; in header_keys
    skip_host = &quot;host&quot; in header_keys
    self.putrequest(
        method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host
    )
    if &quot;user-agent&quot; not in header_keys:
        self.putheader(&quot;User-Agent&quot;, _get_default_user_agent())
    for header, value in headers.items():
        self.putheader(header, value)
    if &quot;transfer-encoding&quot; not in header_keys:
        self.putheader(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)
    self.endheaders()

    if body is not None:
        stringish_types = six.string_types + (bytes,)
        if isinstance(body, stringish_types):
            body = (body,)
        for chunk in body:
            if not chunk:
                continue
            if not isinstance(chunk, bytes):
                chunk = chunk.encode(&quot;utf8&quot;)
            len_str = hex(len(chunk))[2:]
            to_send = bytearray(len_str.encode())
            to_send += b&quot;\r\n&quot;
            to_send += chunk
            to_send += b&quot;\r\n&quot;
            self.send(to_send)

    # After the if clause, to always have a closed body
    self.send(b&quot;0\r\n\r\n&quot;)
</pre></div>
</div>
<p>class HTTPSConnection(HTTPConnection):
“””
Many of the parameters to this constructor are passed to the underlying SSL
socket by means of :py:func:<code class="docutils literal notranslate"><span class="pre">urllib3.util.ssl_wrap_socket</span></code>.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>default_port = port_by_scheme[&quot;https&quot;]

cert_reqs = None
ca_certs = None
ca_cert_dir = None
ca_cert_data = None
ssl_version = None
assert_fingerprint = None
tls_in_tls_required = False

def __init__(
    self,
    host,
    port=None,
    key_file=None,
    cert_file=None,
    key_password=None,
    strict=None,
    timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
    ssl_context=None,
    server_hostname=None,
    **kw
):

    HTTPConnection.__init__(self, host, port, strict=strict, timeout=timeout, **kw)

    self.key_file = key_file
    self.cert_file = cert_file
    self.key_password = key_password
    self.ssl_context = ssl_context
    self.server_hostname = server_hostname

    # Required property for Google AppEngine 1.9.0 which otherwise causes
    # HTTPS requests to go out as HTTP. (See Issue #356)
    self._protocol = &quot;https&quot;

def set_cert(
    self,
    key_file=None,
    cert_file=None,
    cert_reqs=None,
    key_password=None,
    ca_certs=None,
    assert_hostname=None,
    assert_fingerprint=None,
    ca_cert_dir=None,
    ca_cert_data=None,
):
    &quot;&quot;&quot;
    This method should only be called once, before the connection is used.
    &quot;&quot;&quot;
    # If cert_reqs is not provided we&#39;ll assume CERT_REQUIRED unless we also
    # have an SSLContext object in which case we&#39;ll use its verify_mode.
    if cert_reqs is None:
        if self.ssl_context is not None:
            cert_reqs = self.ssl_context.verify_mode
        else:
            cert_reqs = resolve_cert_reqs(None)

    self.key_file = key_file
    self.cert_file = cert_file
    self.cert_reqs = cert_reqs
    self.key_password = key_password
    self.assert_hostname = assert_hostname
    self.assert_fingerprint = assert_fingerprint
    self.ca_certs = ca_certs and os.path.expanduser(ca_certs)
    self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)
    self.ca_cert_data = ca_cert_data

def connect(self):
    # Add certificate verification
    self.sock = conn = self._new_conn()
    hostname = self.host
    tls_in_tls = False

    if self._is_using_tunnel():
        if self.tls_in_tls_required:
            self.sock = conn = self._connect_tls_proxy(hostname, conn)
            tls_in_tls = True

        # Calls self._set_hostport(), so self.host is
        # self._tunnel_host below.
        self._tunnel()
        # Mark this connection as not reusable
        self.auto_open = 0

        # Override the host with the one we&#39;re requesting data from.
        hostname = self._tunnel_host

    server_hostname = hostname
    if self.server_hostname is not None:
        server_hostname = self.server_hostname

    is_time_off = datetime.date.today() &lt; RECENT_DATE
    if is_time_off:
        warnings.warn(
            (
                &quot;System time is way off (before {0}). This will probably &quot;
                &quot;lead to SSL verification errors&quot;
            ).format(RECENT_DATE),
            SystemTimeWarning,
        )

    # Wrap socket using verification with the root certs in
    # trusted_root_certs
    default_ssl_context = False
    if self.ssl_context is None:
        default_ssl_context = True
        self.ssl_context = create_urllib3_context(
            ssl_version=resolve_ssl_version(self.ssl_version),
            cert_reqs=resolve_cert_reqs(self.cert_reqs),
        )

    context = self.ssl_context
    context.verify_mode = resolve_cert_reqs(self.cert_reqs)

    # Try to load OS default certs if none are given.
    # Works well on Windows (requires Python3.4+)
    if (
        not self.ca_certs
        and not self.ca_cert_dir
        and not self.ca_cert_data
        and default_ssl_context
        and hasattr(context, &quot;load_default_certs&quot;)
    ):
        context.load_default_certs()

    self.sock = ssl_wrap_socket(
        sock=conn,
        keyfile=self.key_file,
        certfile=self.cert_file,
        key_password=self.key_password,
        ca_certs=self.ca_certs,
        ca_cert_dir=self.ca_cert_dir,
        ca_cert_data=self.ca_cert_data,
        server_hostname=server_hostname,
        ssl_context=context,
        tls_in_tls=tls_in_tls,
    )

    # If we&#39;re using all defaults and the connection
    # is TLSv1 or TLSv1.1 we throw a DeprecationWarning
    # for the host.
    if (
        default_ssl_context
        and self.ssl_version is None
        and hasattr(self.sock, &quot;version&quot;)
        and self.sock.version() in {&quot;TLSv1&quot;, &quot;TLSv1.1&quot;}
    ):  # Defensive:
        warnings.warn(
            &quot;Negotiating TLSv1/TLSv1.1 by default is deprecated &quot;
            &quot;and will be disabled in urllib3 v2.0.0. Connecting to &quot;
            &quot;&#39;%s&#39; with &#39;%s&#39; can be enabled by explicitly opting-in &quot;
            &quot;with &#39;ssl_version&#39;&quot; % (self.host, self.sock.version()),
            DeprecationWarning,
        )

    if self.assert_fingerprint:
        assert_fingerprint(
            self.sock.getpeercert(binary_form=True), self.assert_fingerprint
        )
    elif (
        context.verify_mode != ssl.CERT_NONE
        and not getattr(context, &quot;check_hostname&quot;, False)
        and self.assert_hostname is not False
    ):
        # While urllib3 attempts to always turn off hostname matching from
        # the TLS library, this cannot always be done. So we check whether
        # the TLS Library still thinks it&#39;s matching hostnames.
        cert = self.sock.getpeercert()
        if not cert.get(&quot;subjectAltName&quot;, ()):
            warnings.warn(
                (
                    &quot;Certificate for {0} has no `subjectAltName`, falling back to check for a &quot;
                    &quot;`commonName` for now. This feature is being removed by major browsers and &quot;
                    &quot;deprecated by RFC 2818. (See https://github.com/urllib3/urllib3/issues/497 &quot;
                    &quot;for details.)&quot;.format(hostname)
                ),
                SubjectAltNameWarning,
            )
        _match_hostname(cert, self.assert_hostname or server_hostname)

    self.is_verified = (
        context.verify_mode == ssl.CERT_REQUIRED
        or self.assert_fingerprint is not None
    )

def _connect_tls_proxy(self, hostname, conn):
    &quot;&quot;&quot;
    Establish a TLS connection to the proxy using the provided SSL context.
    &quot;&quot;&quot;
    proxy_config = self.proxy_config
    ssl_context = proxy_config.ssl_context
    if ssl_context:
        # If the user provided a proxy context, we assume CA and client
        # certificates have already been set
        return ssl_wrap_socket(
            sock=conn,
            server_hostname=hostname,
            ssl_context=ssl_context,
        )

    ssl_context = create_proxy_ssl_context(
        self.ssl_version,
        self.cert_reqs,
        self.ca_certs,
        self.ca_cert_dir,
        self.ca_cert_data,
    )

    # If no cert was provided, use only the default options for server
    # certificate validation
    socket = ssl_wrap_socket(
        sock=conn,
        ca_certs=self.ca_certs,
        ca_cert_dir=self.ca_cert_dir,
        ca_cert_data=self.ca_cert_data,
        server_hostname=hostname,
        ssl_context=ssl_context,
    )

    if ssl_context.verify_mode != ssl.CERT_NONE and not getattr(
        ssl_context, &quot;check_hostname&quot;, False
    ):
        # While urllib3 attempts to always turn off hostname matching from
        # the TLS library, this cannot always be done. So we check whether
        # the TLS Library still thinks it&#39;s matching hostnames.
        cert = socket.getpeercert()
        if not cert.get(&quot;subjectAltName&quot;, ()):
            warnings.warn(
                (
                    &quot;Certificate for {0} has no `subjectAltName`, falling back to check for a &quot;
                    &quot;`commonName` for now. This feature is being removed by major browsers and &quot;
                    &quot;deprecated by RFC 2818. (See https://github.com/urllib3/urllib3/issues/497 &quot;
                    &quot;for details.)&quot;.format(hostname)
                ),
                SubjectAltNameWarning,
            )
        _match_hostname(cert, hostname)

    self.proxy_is_verified = ssl_context.verify_mode == ssl.CERT_REQUIRED
    return socket
</pre></div>
</div>
<p>def _match_hostname(cert, asserted_hostname):
# Our upstream implementation of ssl.match_hostname()
# only applies this normalization to IP addresses so it doesn’t
# match DNS SANs so we do the same thing!
stripped_hostname = asserted_hostname.strip(“u[]”)
if is_ipaddress(stripped_hostname):
asserted_hostname = stripped_hostname</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>try:
    match_hostname(cert, asserted_hostname)
except CertificateError as e:
    log.warning(
        &quot;Certificate did not match expected hostname: %s. Certificate: %s&quot;,
        asserted_hostname,
        cert,
    )
    # Add cert to exception and reraise so client code can inspect
    # the cert when catching the exception, if they want to
    e._peer_cert = cert
    raise
</pre></div>
</div>
<p>def _get_default_user_agent():
return “python-urllib3/%s” % <strong>version</strong></p>
<p>class DummyConnection(object):
“””Used to detect a failed ConnectionCls import.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pass
</pre></div>
</div>
<p>if not ssl:
HTTPSConnection = DummyConnection  # noqa: F811</p>
<p>VerifiedHTTPSConnection = HTTPSConnection</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>