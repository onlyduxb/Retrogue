

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kinds of temporary directories. Only needed for ones that are &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Kinds of temporary directories. Only needed for ones that are</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/utils/temp_dir.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import errno
import itertools
import logging
import os.path
import tempfile
import traceback
from collections.abc import Generator
from contextlib import ExitStack, contextmanager
from pathlib import Path
from typing import (
Any,
Callable,
TypeVar,
)</p>
<p>from pip._internal.utils.misc import enum, rmtree</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>_T = TypeVar(“_T”, bound=”TempDirectory”)</p>
<section id="kinds-of-temporary-directories-only-needed-for-ones-that-are">
<h1>Kinds of temporary directories. Only needed for ones that are<a class="headerlink" href="#kinds-of-temporary-directories-only-needed-for-ones-that-are" title="Link to this heading"></a></h1>
</section>
<section id="globally-managed">
<h1>globally-managed.<a class="headerlink" href="#globally-managed" title="Link to this heading"></a></h1>
<p>tempdir_kinds = enum(
BUILD_ENV=”build-env”,
EPHEM_WHEEL_CACHE=”ephem-wheel-cache”,
REQ_BUILD=”req-build”,
)</p>
<p>_tempdir_manager: ExitStack | None = None</p>
<p>&#64;contextmanager
def global_tempdir_manager() -&gt; Generator[None, None, None]:
global _tempdir_manager
with ExitStack() as stack:
old_tempdir_manager, _tempdir_manager = _tempdir_manager, stack
try:
yield
finally:
_tempdir_manager = old_tempdir_manager</p>
<p>class TempDirectoryTypeRegistry:
“””Manages temp directory behavior”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self) -&gt; None:
    self._should_delete: dict[str, bool] = {}

def set_delete(self, kind: str, value: bool) -&gt; None:
    &quot;&quot;&quot;Indicate whether a TempDirectory of the given kind should be
    auto-deleted.
    &quot;&quot;&quot;
    self._should_delete[kind] = value

def get_delete(self, kind: str) -&gt; bool:
    &quot;&quot;&quot;Get configured auto-delete flag for a given TempDirectory type,
    default True.
    &quot;&quot;&quot;
    return self._should_delete.get(kind, True)
</pre></div>
</div>
<p>_tempdir_registry: TempDirectoryTypeRegistry | None = None</p>
<p>&#64;contextmanager
def tempdir_registry() -&gt; Generator[TempDirectoryTypeRegistry, None, None]:
“””Provides a scoped global tempdir registry that can be used to dictate
whether directories should be deleted.
“””
global _tempdir_registry
old_tempdir_registry = _tempdir_registry
_tempdir_registry = TempDirectoryTypeRegistry()
try:
yield _tempdir_registry
finally:
_tempdir_registry = old_tempdir_registry</p>
<p>class _Default:
pass</p>
<p>_default = _Default()</p>
<p>class TempDirectory:
“””Helper class that owns and cleans up a temporary directory.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This class can be used as a context manager or as an OO representation of a
temporary directory.

Attributes:
    path
        Location to the created temporary directory
    delete
        Whether the directory should be deleted when exiting
        (when used as a contextmanager)

Methods:
    cleanup()
        Deletes the temporary directory

When used as a context manager, if the delete attribute is True, on
exiting the context the temporary directory is deleted.
&quot;&quot;&quot;

def __init__(
    self,
    path: str | None = None,
    delete: bool | None | _Default = _default,
    kind: str = &quot;temp&quot;,
    globally_managed: bool = False,
    ignore_cleanup_errors: bool = True,
):
    super().__init__()

    if delete is _default:
        if path is not None:
            # If we were given an explicit directory, resolve delete option
            # now.
            delete = False
        else:
            # Otherwise, we wait until cleanup and see what
            # tempdir_registry says.
            delete = None

    # The only time we specify path is in for editables where it
    # is the value of the --src option.
    if path is None:
        path = self._create(kind)

    self._path = path
    self._deleted = False
    self.delete = delete
    self.kind = kind
    self.ignore_cleanup_errors = ignore_cleanup_errors

    if globally_managed:
        assert _tempdir_manager is not None
        _tempdir_manager.enter_context(self)

@property
def path(self) -&gt; str:
    assert not self._deleted, f&quot;Attempted to access deleted path: {self._path}&quot;
    return self._path

def __repr__(self) -&gt; str:
    return f&quot;&lt;{self.__class__.__name__} {self.path!r}&gt;&quot;

def __enter__(self: _T) -&gt; _T:
    return self

def __exit__(self, exc: Any, value: Any, tb: Any) -&gt; None:
    if self.delete is not None:
        delete = self.delete
    elif _tempdir_registry:
        delete = _tempdir_registry.get_delete(self.kind)
    else:
        delete = True

    if delete:
        self.cleanup()

def _create(self, kind: str) -&gt; str:
    &quot;&quot;&quot;Create a temporary directory and store its path in self.path&quot;&quot;&quot;
    # We realpath here because some systems have their default tmpdir
    # symlinked to another directory.  This tends to confuse build
    # scripts, so we canonicalize the path by traversing potential
    # symlinks here.
    path = os.path.realpath(tempfile.mkdtemp(prefix=f&quot;pip-{kind}-&quot;))
    logger.debug(&quot;Created temporary directory: %s&quot;, path)
    return path

def cleanup(self) -&gt; None:
    &quot;&quot;&quot;Remove the temporary directory created and reset state&quot;&quot;&quot;
    self._deleted = True
    if not os.path.exists(self._path):
        return

    errors: list[BaseException] = []

    def onerror(
        func: Callable[..., Any],
        path: Path,
        exc_val: BaseException,
    ) -&gt; None:
        &quot;&quot;&quot;Log a warning for a `rmtree` error and continue&quot;&quot;&quot;
        formatted_exc = &quot;\n&quot;.join(
            traceback.format_exception_only(type(exc_val), exc_val)
        )
        formatted_exc = formatted_exc.rstrip()  # remove trailing new line
        if func in (os.unlink, os.remove, os.rmdir):
            logger.debug(
                &quot;Failed to remove a temporary file &#39;%s&#39; due to %s.\n&quot;,
                path,
                formatted_exc,
            )
        else:
            logger.debug(&quot;%s failed with %s.&quot;, func.__qualname__, formatted_exc)
        errors.append(exc_val)

    if self.ignore_cleanup_errors:
        try:
            # first try with @retry; retrying to handle ephemeral errors
            rmtree(self._path, ignore_errors=False)
        except OSError:
            # last pass ignore/log all errors
            rmtree(self._path, onexc=onerror)
        if errors:
            logger.warning(
                &quot;Failed to remove contents in a temporary directory &#39;%s&#39;.\n&quot;
                &quot;You can safely remove it manually.&quot;,
                self._path,
            )
    else:
        rmtree(self._path)
</pre></div>
</div>
<p>class AdjacentTempDirectory(TempDirectory):
“””Helper class that creates a temporary directory adjacent to a real one.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Attributes:
    original
        The original directory to create a temp directory for.
    path
        After calling create() or entering, contains the full
        path to the temporary directory.
    delete
        Whether the directory should be deleted when exiting
        (when used as a contextmanager)

&quot;&quot;&quot;

# The characters that may be used to name the temp directory
# We always prepend a ~ and then rotate through these until
# a usable name is found.
# pkg_resources raises a different error for .dist-info folder
# with leading &#39;-&#39; and invalid metadata
LEADING_CHARS = &quot;-~.=%0123456789&quot;

def __init__(self, original: str, delete: bool | None = None) -&gt; None:
    self.original = original.rstrip(&quot;/\\&quot;)
    super().__init__(delete=delete)

@classmethod
def _generate_names(cls, name: str) -&gt; Generator[str, None, None]:
    &quot;&quot;&quot;Generates a series of temporary names.

    The algorithm replaces the leading characters in the name
    with ones that are valid filesystem characters, but are not
    valid package names (for both Python and pip definitions of
    package).
    &quot;&quot;&quot;
    for i in range(1, len(name)):
        for candidate in itertools.combinations_with_replacement(
            cls.LEADING_CHARS, i - 1
        ):
            new_name = &quot;~&quot; + &quot;&quot;.join(candidate) + name[i:]
            if new_name != name:
                yield new_name

    # If we make it this far, we will have to make a longer name
    for i in range(len(cls.LEADING_CHARS)):
        for candidate in itertools.combinations_with_replacement(
            cls.LEADING_CHARS, i
        ):
            new_name = &quot;~&quot; + &quot;&quot;.join(candidate) + name
            if new_name != name:
                yield new_name

def _create(self, kind: str) -&gt; str:
    root, name = os.path.split(self.original)
    for candidate in self._generate_names(name):
        path = os.path.join(root, candidate)
        try:
            os.mkdir(path)
        except OSError as ex:
            # Continue if the name exists already
            if ex.errno != errno.EEXIST:
                raise
        else:
            path = os.path.realpath(path)
            break
    else:
        # Final fallback on the default behavior.
        path = os.path.realpath(tempfile.mkdtemp(prefix=f&quot;pip-{kind}-&quot;))

    logger.debug(&quot;Created temporary directory: %s&quot;, path)
    return path
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>