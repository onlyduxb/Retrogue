

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alias methods from _appengine_environ to maintain public API interface. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Alias methods from _appengine_environ to maintain public API interface.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/contrib/appengine.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
This module provides a pool manager that uses Google App Engine’s
<code class="docutils literal notranslate"><span class="pre">URLFetch</span> <span class="pre">Service</span> <span class="pre">&lt;https://cloud.google.com/appengine/docs/python/urlfetch&gt;</span></code>_.</p>
<p>Example usage::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pip._vendor.urllib3 import PoolManager
from pip._vendor.urllib3.contrib.appengine import AppEngineManager, is_appengine_sandbox

if is_appengine_sandbox():
    # AppEngineManager uses AppEngine&#39;s URLFetch API behind the scenes
    http = AppEngineManager()
else:
    # PoolManager uses a socket-level API behind the scenes
    http = PoolManager()

r = http.request(&#39;GET&#39;, &#39;https://google.com/&#39;)
</pre></div>
</div>
<p>There are <code class="docutils literal notranslate"><span class="pre">limitations</span> <span class="pre">&lt;https://cloud.google.com/appengine/docs/python/\</span> <span class="pre">urlfetch/#Python_Quotas_and_limits&gt;</span></code>_ to the URLFetch service and it may not be
the best choice for your application. There are three options for using
urllib3 on Google App Engine:</p>
<ol class="arabic">
<li><p>You can use :class:<code class="docutils literal notranslate"><span class="pre">AppEngineManager</span></code> with URLFetch. URLFetch is
cost-effective in many circumstances as long as your usage is within the
limitations.</p></li>
<li><p>You can use a normal :class:<code class="docutils literal notranslate"><span class="pre">~urllib3.PoolManager</span></code> by enabling sockets.
Sockets also have <code class="docutils literal notranslate"><span class="pre">limitations</span> <span class="pre">and</span> <span class="pre">restrictions</span> <span class="pre">&lt;https://cloud.google.com/appengine/docs/python/sockets/\</span> <span class="pre">#limitations-and-restrictions&gt;</span></code>_ and have a lower free quota than URLFetch.
To use sockets, be sure to specify the following in your <code class="docutils literal notranslate"><span class="pre">app.yaml</span></code>::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> env_variables:
     GAE_USE_SOCKETS_HTTPLIB : &#39;true&#39;
</pre></div>
</div>
</li>
<li><p>If you are using <code class="docutils literal notranslate"><span class="pre">App</span> <span class="pre">Engine</span> <span class="pre">Flexible</span> <span class="pre">&lt;https://cloud.google.com/appengine/docs/flexible/&gt;</span></code>_, you can use the standard
:class:<code class="docutils literal notranslate"><span class="pre">PoolManager</span></code> without any configuration or special environment variables.
“””</p></li>
</ol>
<p>from <strong>future</strong> import absolute_import</p>
<p>import io
import logging
import warnings</p>
<p>from ..exceptions import (
HTTPError,
HTTPWarning,
MaxRetryError,
ProtocolError,
SSLError,
TimeoutError,
)
from ..packages.six.moves.urllib.parse import urljoin
from ..request import RequestMethods
from ..response import HTTPResponse
from ..util.retry import Retry
from ..util.timeout import Timeout
from . import _appengine_environ</p>
<p>try:
from google.appengine.api import urlfetch
except ImportError:
urlfetch = None</p>
<p>log = logging.getLogger(<strong>name</strong>)</p>
<p>class AppEnginePlatformWarning(HTTPWarning):
pass</p>
<p>class AppEnginePlatformError(HTTPError):
pass</p>
<p>class AppEngineManager(RequestMethods):
“””
Connection manager for Google App Engine sandbox applications.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This manager uses the URLFetch service directly instead of using the
emulated httplib, and is subject to URLFetch limitations as described in
the App Engine documentation `here
&lt;https://cloud.google.com/appengine/docs/python/urlfetch&gt;`_.

Notably it will raise an :class:`AppEnginePlatformError` if:
    * URLFetch is not available.
    * If you attempt to use this on App Engine Flexible, as full socket
      support is available.
    * If a request size is more than 10 megabytes.
    * If a response size is more than 32 megabytes.
    * If you use an unsupported request method such as OPTIONS.

Beyond those cases, it will raise normal urllib3 errors.
&quot;&quot;&quot;

def __init__(
    self,
    headers=None,
    retries=None,
    validate_certificate=True,
    urlfetch_retries=True,
):
    if not urlfetch:
        raise AppEnginePlatformError(
            &quot;URLFetch is not available in this environment.&quot;
        )

    warnings.warn(
        &quot;urllib3 is using URLFetch on Google App Engine sandbox instead &quot;
        &quot;of sockets. To use sockets directly instead of URLFetch see &quot;
        &quot;https://urllib3.readthedocs.io/en/1.26.x/reference/urllib3.contrib.html.&quot;,
        AppEnginePlatformWarning,
    )

    RequestMethods.__init__(self, headers)
    self.validate_certificate = validate_certificate
    self.urlfetch_retries = urlfetch_retries

    self.retries = retries or Retry.DEFAULT

def __enter__(self):
    return self

def __exit__(self, exc_type, exc_val, exc_tb):
    # Return False to re-raise any potential exceptions
    return False

def urlopen(
    self,
    method,
    url,
    body=None,
    headers=None,
    retries=None,
    redirect=True,
    timeout=Timeout.DEFAULT_TIMEOUT,
    **response_kw
):

    retries = self._get_retries(retries, redirect)

    try:
        follow_redirects = redirect and retries.redirect != 0 and retries.total
        response = urlfetch.fetch(
            url,
            payload=body,
            method=method,
            headers=headers or {},
            allow_truncated=False,
            follow_redirects=self.urlfetch_retries and follow_redirects,
            deadline=self._get_absolute_timeout(timeout),
            validate_certificate=self.validate_certificate,
        )
    except urlfetch.DeadlineExceededError as e:
        raise TimeoutError(self, e)

    except urlfetch.InvalidURLError as e:
        if &quot;too large&quot; in str(e):
            raise AppEnginePlatformError(
                &quot;URLFetch request too large, URLFetch only &quot;
                &quot;supports requests up to 10mb in size.&quot;,
                e,
            )
        raise ProtocolError(e)

    except urlfetch.DownloadError as e:
        if &quot;Too many redirects&quot; in str(e):
            raise MaxRetryError(self, url, reason=e)
        raise ProtocolError(e)

    except urlfetch.ResponseTooLargeError as e:
        raise AppEnginePlatformError(
            &quot;URLFetch response too large, URLFetch only supports&quot;
            &quot;responses up to 32mb in size.&quot;,
            e,
        )

    except urlfetch.SSLCertificateError as e:
        raise SSLError(e)

    except urlfetch.InvalidMethodError as e:
        raise AppEnginePlatformError(
            &quot;URLFetch does not support method: %s&quot; % method, e
        )

    http_response = self._urlfetch_response_to_http_response(
        response, retries=retries, **response_kw
    )

    # Handle redirect?
    redirect_location = redirect and http_response.get_redirect_location()
    if redirect_location:
        # Check for redirect response
        if self.urlfetch_retries and retries.raise_on_redirect:
            raise MaxRetryError(self, url, &quot;too many redirects&quot;)
        else:
            if http_response.status == 303:
                method = &quot;GET&quot;

            try:
                retries = retries.increment(
                    method, url, response=http_response, _pool=self
                )
            except MaxRetryError:
                if retries.raise_on_redirect:
                    raise MaxRetryError(self, url, &quot;too many redirects&quot;)
                return http_response

            retries.sleep_for_retry(http_response)
            log.debug(&quot;Redirecting %s -&gt; %s&quot;, url, redirect_location)
            redirect_url = urljoin(url, redirect_location)
            return self.urlopen(
                method,
                redirect_url,
                body,
                headers,
                retries=retries,
                redirect=redirect,
                timeout=timeout,
                **response_kw
            )

    # Check if we should retry the HTTP response.
    has_retry_after = bool(http_response.headers.get(&quot;Retry-After&quot;))
    if retries.is_retry(method, http_response.status, has_retry_after):
        retries = retries.increment(method, url, response=http_response, _pool=self)
        log.debug(&quot;Retry: %s&quot;, url)
        retries.sleep(http_response)
        return self.urlopen(
            method,
            url,
            body=body,
            headers=headers,
            retries=retries,
            redirect=redirect,
            timeout=timeout,
            **response_kw
        )

    return http_response

def _urlfetch_response_to_http_response(self, urlfetch_resp, **response_kw):

    if is_prod_appengine():
        # Production GAE handles deflate encoding automatically, but does
        # not remove the encoding header.
        content_encoding = urlfetch_resp.headers.get(&quot;content-encoding&quot;)

        if content_encoding == &quot;deflate&quot;:
            del urlfetch_resp.headers[&quot;content-encoding&quot;]

    transfer_encoding = urlfetch_resp.headers.get(&quot;transfer-encoding&quot;)
    # We have a full response&#39;s content,
    # so let&#39;s make sure we don&#39;t report ourselves as chunked data.
    if transfer_encoding == &quot;chunked&quot;:
        encodings = transfer_encoding.split(&quot;,&quot;)
        encodings.remove(&quot;chunked&quot;)
        urlfetch_resp.headers[&quot;transfer-encoding&quot;] = &quot;,&quot;.join(encodings)

    original_response = HTTPResponse(
        # In order for decoding to work, we must present the content as
        # a file-like object.
        body=io.BytesIO(urlfetch_resp.content),
        msg=urlfetch_resp.header_msg,
        headers=urlfetch_resp.headers,
        status=urlfetch_resp.status_code,
        **response_kw
    )

    return HTTPResponse(
        body=io.BytesIO(urlfetch_resp.content),
        headers=urlfetch_resp.headers,
        status=urlfetch_resp.status_code,
        original_response=original_response,
        **response_kw
    )

def _get_absolute_timeout(self, timeout):
    if timeout is Timeout.DEFAULT_TIMEOUT:
        return None  # Defer to URLFetch&#39;s default.
    if isinstance(timeout, Timeout):
        if timeout._read is not None or timeout._connect is not None:
            warnings.warn(
                &quot;URLFetch does not support granular timeout settings, &quot;
                &quot;reverting to total or default URLFetch timeout.&quot;,
                AppEnginePlatformWarning,
            )
        return timeout.total
    return timeout

def _get_retries(self, retries, redirect):
    if not isinstance(retries, Retry):
        retries = Retry.from_int(retries, redirect=redirect, default=self.retries)

    if retries.connect or retries.read or retries.redirect:
        warnings.warn(
            &quot;URLFetch only supports total retries and does not &quot;
            &quot;recognize connect, read, or redirect retry parameters.&quot;,
            AppEnginePlatformWarning,
        )

    return retries
</pre></div>
</div>
<section id="alias-methods-from-appengine-environ-to-maintain-public-api-interface">
<h1>Alias methods from _appengine_environ to maintain public API interface.<a class="headerlink" href="#alias-methods-from-appengine-environ-to-maintain-public-api-interface" title="Link to this heading"></a></h1>
<p>is_appengine = _appengine_environ.is_appengine
is_appengine_sandbox = _appengine_environ.is_appengine_sandbox
is_local_appengine = _appengine_environ.is_local_appengine
is_prod_appengine = _appengine_environ.is_prod_appengine
is_prod_appengine_mvms = _appengine_environ.is_prod_appengine_mvms</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>