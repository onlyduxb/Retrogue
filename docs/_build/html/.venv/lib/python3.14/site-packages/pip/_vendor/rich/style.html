

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Style instances and style definitions are often interchangeable &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Style instances and style definitions are often interchangeable</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/rich/style.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>import sys
from functools import lru_cache
from operator import attrgetter
from pickle import dumps, loads
from random import randint
from typing import Any, Dict, Iterable, List, Optional, Type, Union, cast</p>
<p>from . import errors
from .color import Color, ColorParseError, ColorSystem, blend_rgb
from .repr import Result, rich_repr
from .terminal_theme import DEFAULT_TERMINAL_THEME, TerminalTheme</p>
<p>_hash_getter = attrgetter(
“_color”, “_bgcolor”, “_attributes”, “_set_attributes”, “_link”, “_meta”
)</p>
<section id="style-instances-and-style-definitions-are-often-interchangeable">
<h1>Style instances and style definitions are often interchangeable<a class="headerlink" href="#style-instances-and-style-definitions-are-often-interchangeable" title="Link to this heading"></a></h1>
<p>StyleType = Union[str, “Style”]</p>
<p>class _Bit:
“””A descriptor to get/set a style attribute bit.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__slots__ = [&quot;bit&quot;]

def __init__(self, bit_no: int) -&gt; None:
    self.bit = 1 &lt;&lt; bit_no

def __get__(self, obj: &quot;Style&quot;, objtype: Type[&quot;Style&quot;]) -&gt; Optional[bool]:
    if obj._set_attributes &amp; self.bit:
        return obj._attributes &amp; self.bit != 0
    return None
</pre></div>
</div>
<p>&#64;rich_repr
class Style:
“””A terminal style.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A terminal style consists of a color (`color`), a background color (`bgcolor`), and a number of attributes, such
as bold, italic etc. The attributes have 3 states: they can either be on
(``True``), off (``False``), or not set (``None``).

Args:
    color (Union[Color, str], optional): Color of terminal text. Defaults to None.
    bgcolor (Union[Color, str], optional): Color of terminal background. Defaults to None.
    bold (bool, optional): Enable bold text. Defaults to None.
    dim (bool, optional): Enable dim text. Defaults to None.
    italic (bool, optional): Enable italic text. Defaults to None.
    underline (bool, optional): Enable underlined text. Defaults to None.
    blink (bool, optional): Enabled blinking text. Defaults to None.
    blink2 (bool, optional): Enable fast blinking text. Defaults to None.
    reverse (bool, optional): Enabled reverse text. Defaults to None.
    conceal (bool, optional): Enable concealed text. Defaults to None.
    strike (bool, optional): Enable strikethrough text. Defaults to None.
    underline2 (bool, optional): Enable doubly underlined text. Defaults to None.
    frame (bool, optional): Enable framed text. Defaults to None.
    encircle (bool, optional): Enable encircled text. Defaults to None.
    overline (bool, optional): Enable overlined text. Defaults to None.
    link (str, link): Link URL. Defaults to None.

&quot;&quot;&quot;

_color: Optional[Color]
_bgcolor: Optional[Color]
_attributes: int
_set_attributes: int
_hash: Optional[int]
_null: bool
_meta: Optional[bytes]

__slots__ = [
    &quot;_color&quot;,
    &quot;_bgcolor&quot;,
    &quot;_attributes&quot;,
    &quot;_set_attributes&quot;,
    &quot;_link&quot;,
    &quot;_link_id&quot;,
    &quot;_ansi&quot;,
    &quot;_style_definition&quot;,
    &quot;_hash&quot;,
    &quot;_null&quot;,
    &quot;_meta&quot;,
]

# maps bits on to SGR parameter
_style_map = {
    0: &quot;1&quot;,
    1: &quot;2&quot;,
    2: &quot;3&quot;,
    3: &quot;4&quot;,
    4: &quot;5&quot;,
    5: &quot;6&quot;,
    6: &quot;7&quot;,
    7: &quot;8&quot;,
    8: &quot;9&quot;,
    9: &quot;21&quot;,
    10: &quot;51&quot;,
    11: &quot;52&quot;,
    12: &quot;53&quot;,
}

STYLE_ATTRIBUTES = {
    &quot;dim&quot;: &quot;dim&quot;,
    &quot;d&quot;: &quot;dim&quot;,
    &quot;bold&quot;: &quot;bold&quot;,
    &quot;b&quot;: &quot;bold&quot;,
    &quot;italic&quot;: &quot;italic&quot;,
    &quot;i&quot;: &quot;italic&quot;,
    &quot;underline&quot;: &quot;underline&quot;,
    &quot;u&quot;: &quot;underline&quot;,
    &quot;blink&quot;: &quot;blink&quot;,
    &quot;blink2&quot;: &quot;blink2&quot;,
    &quot;reverse&quot;: &quot;reverse&quot;,
    &quot;r&quot;: &quot;reverse&quot;,
    &quot;conceal&quot;: &quot;conceal&quot;,
    &quot;c&quot;: &quot;conceal&quot;,
    &quot;strike&quot;: &quot;strike&quot;,
    &quot;s&quot;: &quot;strike&quot;,
    &quot;underline2&quot;: &quot;underline2&quot;,
    &quot;uu&quot;: &quot;underline2&quot;,
    &quot;frame&quot;: &quot;frame&quot;,
    &quot;encircle&quot;: &quot;encircle&quot;,
    &quot;overline&quot;: &quot;overline&quot;,
    &quot;o&quot;: &quot;overline&quot;,
}

def __init__(
    self,
    *,
    color: Optional[Union[Color, str]] = None,
    bgcolor: Optional[Union[Color, str]] = None,
    bold: Optional[bool] = None,
    dim: Optional[bool] = None,
    italic: Optional[bool] = None,
    underline: Optional[bool] = None,
    blink: Optional[bool] = None,
    blink2: Optional[bool] = None,
    reverse: Optional[bool] = None,
    conceal: Optional[bool] = None,
    strike: Optional[bool] = None,
    underline2: Optional[bool] = None,
    frame: Optional[bool] = None,
    encircle: Optional[bool] = None,
    overline: Optional[bool] = None,
    link: Optional[str] = None,
    meta: Optional[Dict[str, Any]] = None,
):
    self._ansi: Optional[str] = None
    self._style_definition: Optional[str] = None

    def _make_color(color: Union[Color, str]) -&gt; Color:
        return color if isinstance(color, Color) else Color.parse(color)

    self._color = None if color is None else _make_color(color)
    self._bgcolor = None if bgcolor is None else _make_color(bgcolor)
    self._set_attributes = sum(
        (
            bold is not None,
            dim is not None and 2,
            italic is not None and 4,
            underline is not None and 8,
            blink is not None and 16,
            blink2 is not None and 32,
            reverse is not None and 64,
            conceal is not None and 128,
            strike is not None and 256,
            underline2 is not None and 512,
            frame is not None and 1024,
            encircle is not None and 2048,
            overline is not None and 4096,
        )
    )
    self._attributes = (
        sum(
            (
                bold and 1 or 0,
                dim and 2 or 0,
                italic and 4 or 0,
                underline and 8 or 0,
                blink and 16 or 0,
                blink2 and 32 or 0,
                reverse and 64 or 0,
                conceal and 128 or 0,
                strike and 256 or 0,
                underline2 and 512 or 0,
                frame and 1024 or 0,
                encircle and 2048 or 0,
                overline and 4096 or 0,
            )
        )
        if self._set_attributes
        else 0
    )

    self._link = link
    self._meta = None if meta is None else dumps(meta)
    self._link_id = (
        f&quot;{randint(0, 999999)}{hash(self._meta)}&quot; if (link or meta) else &quot;&quot;
    )
    self._hash: Optional[int] = None
    self._null = not (self._set_attributes or color or bgcolor or link or meta)

@classmethod
def null(cls) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Create an &#39;null&#39; style, equivalent to Style(), but more performant.&quot;&quot;&quot;
    return NULL_STYLE

@classmethod
def from_color(
    cls, color: Optional[Color] = None, bgcolor: Optional[Color] = None
) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Create a new style with colors and no attributes.

    Returns:
        color (Optional[Color]): A (foreground) color, or None for no color. Defaults to None.
        bgcolor (Optional[Color]): A (background) color, or None for no color. Defaults to None.
    &quot;&quot;&quot;
    style: Style = cls.__new__(Style)
    style._ansi = None
    style._style_definition = None
    style._color = color
    style._bgcolor = bgcolor
    style._set_attributes = 0
    style._attributes = 0
    style._link = None
    style._link_id = &quot;&quot;
    style._meta = None
    style._null = not (color or bgcolor)
    style._hash = None
    return style

@classmethod
def from_meta(cls, meta: Optional[Dict[str, Any]]) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Create a new style with meta data.

    Returns:
        meta (Optional[Dict[str, Any]]): A dictionary of meta data. Defaults to None.
    &quot;&quot;&quot;
    style: Style = cls.__new__(Style)
    style._ansi = None
    style._style_definition = None
    style._color = None
    style._bgcolor = None
    style._set_attributes = 0
    style._attributes = 0
    style._link = None
    style._meta = dumps(meta)
    style._link_id = f&quot;{randint(0, 999999)}{hash(style._meta)}&quot;
    style._hash = None
    style._null = not (meta)
    return style

@classmethod
def on(cls, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Create a blank style with meta information.

    Example:
        style = Style.on(click=self.on_click)

    Args:
        meta (Optional[Dict[str, Any]], optional): An optional dict of meta information.
        **handlers (Any): Keyword arguments are translated in to handlers.

    Returns:
        Style: A Style with meta information attached.
    &quot;&quot;&quot;
    meta = {} if meta is None else meta
    meta.update({f&quot;@{key}&quot;: value for key, value in handlers.items()})
    return cls.from_meta(meta)

bold = _Bit(0)
dim = _Bit(1)
italic = _Bit(2)
underline = _Bit(3)
blink = _Bit(4)
blink2 = _Bit(5)
reverse = _Bit(6)
conceal = _Bit(7)
strike = _Bit(8)
underline2 = _Bit(9)
frame = _Bit(10)
encircle = _Bit(11)
overline = _Bit(12)

@property
def link_id(self) -&gt; str:
    &quot;&quot;&quot;Get a link id, used in ansi code for links.&quot;&quot;&quot;
    return self._link_id

def __str__(self) -&gt; str:
    &quot;&quot;&quot;Re-generate style definition from attributes.&quot;&quot;&quot;
    if self._style_definition is None:
        attributes: List[str] = []
        append = attributes.append
        bits = self._set_attributes
        if bits &amp; 0b0000000001111:
            if bits &amp; 1:
                append(&quot;bold&quot; if self.bold else &quot;not bold&quot;)
            if bits &amp; (1 &lt;&lt; 1):
                append(&quot;dim&quot; if self.dim else &quot;not dim&quot;)
            if bits &amp; (1 &lt;&lt; 2):
                append(&quot;italic&quot; if self.italic else &quot;not italic&quot;)
            if bits &amp; (1 &lt;&lt; 3):
                append(&quot;underline&quot; if self.underline else &quot;not underline&quot;)
        if bits &amp; 0b0000111110000:
            if bits &amp; (1 &lt;&lt; 4):
                append(&quot;blink&quot; if self.blink else &quot;not blink&quot;)
            if bits &amp; (1 &lt;&lt; 5):
                append(&quot;blink2&quot; if self.blink2 else &quot;not blink2&quot;)
            if bits &amp; (1 &lt;&lt; 6):
                append(&quot;reverse&quot; if self.reverse else &quot;not reverse&quot;)
            if bits &amp; (1 &lt;&lt; 7):
                append(&quot;conceal&quot; if self.conceal else &quot;not conceal&quot;)
            if bits &amp; (1 &lt;&lt; 8):
                append(&quot;strike&quot; if self.strike else &quot;not strike&quot;)
        if bits &amp; 0b1111000000000:
            if bits &amp; (1 &lt;&lt; 9):
                append(&quot;underline2&quot; if self.underline2 else &quot;not underline2&quot;)
            if bits &amp; (1 &lt;&lt; 10):
                append(&quot;frame&quot; if self.frame else &quot;not frame&quot;)
            if bits &amp; (1 &lt;&lt; 11):
                append(&quot;encircle&quot; if self.encircle else &quot;not encircle&quot;)
            if bits &amp; (1 &lt;&lt; 12):
                append(&quot;overline&quot; if self.overline else &quot;not overline&quot;)
        if self._color is not None:
            append(self._color.name)
        if self._bgcolor is not None:
            append(&quot;on&quot;)
            append(self._bgcolor.name)
        if self._link:
            append(&quot;link&quot;)
            append(self._link)
        self._style_definition = &quot; &quot;.join(attributes) or &quot;none&quot;
    return self._style_definition

def __bool__(self) -&gt; bool:
    &quot;&quot;&quot;A Style is false if it has no attributes, colors, or links.&quot;&quot;&quot;
    return not self._null

def _make_ansi_codes(self, color_system: ColorSystem) -&gt; str:
    &quot;&quot;&quot;Generate ANSI codes for this style.

    Args:
        color_system (ColorSystem): Color system.

    Returns:
        str: String containing codes.
    &quot;&quot;&quot;

    if self._ansi is None:
        sgr: List[str] = []
        append = sgr.append
        _style_map = self._style_map
        attributes = self._attributes &amp; self._set_attributes
        if attributes:
            if attributes &amp; 1:
                append(_style_map[0])
            if attributes &amp; 2:
                append(_style_map[1])
            if attributes &amp; 4:
                append(_style_map[2])
            if attributes &amp; 8:
                append(_style_map[3])
            if attributes &amp; 0b0000111110000:
                for bit in range(4, 9):
                    if attributes &amp; (1 &lt;&lt; bit):
                        append(_style_map[bit])
            if attributes &amp; 0b1111000000000:
                for bit in range(9, 13):
                    if attributes &amp; (1 &lt;&lt; bit):
                        append(_style_map[bit])
        if self._color is not None:
            sgr.extend(self._color.downgrade(color_system).get_ansi_codes())
        if self._bgcolor is not None:
            sgr.extend(
                self._bgcolor.downgrade(color_system).get_ansi_codes(
                    foreground=False
                )
            )
        self._ansi = &quot;;&quot;.join(sgr)
    return self._ansi

@classmethod
@lru_cache(maxsize=1024)
def normalize(cls, style: str) -&gt; str:
    &quot;&quot;&quot;Normalize a style definition so that styles with the same effect have the same string
    representation.

    Args:
        style (str): A style definition.

    Returns:
        str: Normal form of style definition.
    &quot;&quot;&quot;
    try:
        return str(cls.parse(style))
    except errors.StyleSyntaxError:
        return style.strip().lower()

@classmethod
def pick_first(cls, *values: Optional[StyleType]) -&gt; StyleType:
    &quot;&quot;&quot;Pick first non-None style.&quot;&quot;&quot;
    for value in values:
        if value is not None:
            return value
    raise ValueError(&quot;expected at least one non-None style&quot;)

def __rich_repr__(self) -&gt; Result:
    yield &quot;color&quot;, self.color, None
    yield &quot;bgcolor&quot;, self.bgcolor, None
    yield &quot;bold&quot;, self.bold, None,
    yield &quot;dim&quot;, self.dim, None,
    yield &quot;italic&quot;, self.italic, None
    yield &quot;underline&quot;, self.underline, None,
    yield &quot;blink&quot;, self.blink, None
    yield &quot;blink2&quot;, self.blink2, None
    yield &quot;reverse&quot;, self.reverse, None
    yield &quot;conceal&quot;, self.conceal, None
    yield &quot;strike&quot;, self.strike, None
    yield &quot;underline2&quot;, self.underline2, None
    yield &quot;frame&quot;, self.frame, None
    yield &quot;encircle&quot;, self.encircle, None
    yield &quot;link&quot;, self.link, None
    if self._meta:
        yield &quot;meta&quot;, self.meta

def __eq__(self, other: Any) -&gt; bool:
    if not isinstance(other, Style):
        return NotImplemented
    return self.__hash__() == other.__hash__()

def __ne__(self, other: Any) -&gt; bool:
    if not isinstance(other, Style):
        return NotImplemented
    return self.__hash__() != other.__hash__()

def __hash__(self) -&gt; int:
    if self._hash is not None:
        return self._hash
    self._hash = hash(_hash_getter(self))
    return self._hash

@property
def color(self) -&gt; Optional[Color]:
    &quot;&quot;&quot;The foreground color or None if it is not set.&quot;&quot;&quot;
    return self._color

@property
def bgcolor(self) -&gt; Optional[Color]:
    &quot;&quot;&quot;The background color or None if it is not set.&quot;&quot;&quot;
    return self._bgcolor

@property
def link(self) -&gt; Optional[str]:
    &quot;&quot;&quot;Link text, if set.&quot;&quot;&quot;
    return self._link

@property
def transparent_background(self) -&gt; bool:
    &quot;&quot;&quot;Check if the style specified a transparent background.&quot;&quot;&quot;
    return self.bgcolor is None or self.bgcolor.is_default

@property
def background_style(self) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;A Style with background only.&quot;&quot;&quot;
    return Style(bgcolor=self.bgcolor)

@property
def meta(self) -&gt; Dict[str, Any]:
    &quot;&quot;&quot;Get meta information (can not be changed after construction).&quot;&quot;&quot;
    return {} if self._meta is None else cast(Dict[str, Any], loads(self._meta))

@property
def without_color(self) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Get a copy of the style with color removed.&quot;&quot;&quot;
    if self._null:
        return NULL_STYLE
    style: Style = self.__new__(Style)
    style._ansi = None
    style._style_definition = None
    style._color = None
    style._bgcolor = None
    style._attributes = self._attributes
    style._set_attributes = self._set_attributes
    style._link = self._link
    style._link_id = f&quot;{randint(0, 999999)}&quot; if self._link else &quot;&quot;
    style._null = False
    style._meta = None
    style._hash = None
    return style

@classmethod
@lru_cache(maxsize=4096)
def parse(cls, style_definition: str) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Parse a style definition.

    Args:
        style_definition (str): A string containing a style.

    Raises:
        errors.StyleSyntaxError: If the style definition syntax is invalid.

    Returns:
        `Style`: A Style instance.
    &quot;&quot;&quot;
    if style_definition.strip() == &quot;none&quot; or not style_definition:
        return cls.null()

    STYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES
    color: Optional[str] = None
    bgcolor: Optional[str] = None
    attributes: Dict[str, Optional[Any]] = {}
    link: Optional[str] = None

    words = iter(style_definition.split())
    for original_word in words:
        word = original_word.lower()
        if word == &quot;on&quot;:
            word = next(words, &quot;&quot;)
            if not word:
                raise errors.StyleSyntaxError(&quot;color expected after &#39;on&#39;&quot;)
            try:
                Color.parse(word)
            except ColorParseError as error:
                raise errors.StyleSyntaxError(
                    f&quot;unable to parse {word!r} as background color; {error}&quot;
                ) from None
            bgcolor = word

        elif word == &quot;not&quot;:
            word = next(words, &quot;&quot;)
            attribute = STYLE_ATTRIBUTES.get(word)
            if attribute is None:
                raise errors.StyleSyntaxError(
                    f&quot;expected style attribute after &#39;not&#39;, found {word!r}&quot;
                )
            attributes[attribute] = False

        elif word == &quot;link&quot;:
            word = next(words, &quot;&quot;)
            if not word:
                raise errors.StyleSyntaxError(&quot;URL expected after &#39;link&#39;&quot;)
            link = word

        elif word in STYLE_ATTRIBUTES:
            attributes[STYLE_ATTRIBUTES[word]] = True

        else:
            try:
                Color.parse(word)
            except ColorParseError as error:
                raise errors.StyleSyntaxError(
                    f&quot;unable to parse {word!r} as color; {error}&quot;
                ) from None
            color = word
    style = Style(color=color, bgcolor=bgcolor, link=link, **attributes)
    return style

@lru_cache(maxsize=1024)
def get_html_style(self, theme: Optional[TerminalTheme] = None) -&gt; str:
    &quot;&quot;&quot;Get a CSS style rule.&quot;&quot;&quot;
    theme = theme or DEFAULT_TERMINAL_THEME
    css: List[str] = []
    append = css.append

    color = self.color
    bgcolor = self.bgcolor
    if self.reverse:
        color, bgcolor = bgcolor, color
    if self.dim:
        foreground_color = (
            theme.foreground_color if color is None else color.get_truecolor(theme)
        )
        color = Color.from_triplet(
            blend_rgb(foreground_color, theme.background_color, 0.5)
        )
    if color is not None:
        theme_color = color.get_truecolor(theme)
        append(f&quot;color: {theme_color.hex}&quot;)
        append(f&quot;text-decoration-color: {theme_color.hex}&quot;)
    if bgcolor is not None:
        theme_color = bgcolor.get_truecolor(theme, foreground=False)
        append(f&quot;background-color: {theme_color.hex}&quot;)
    if self.bold:
        append(&quot;font-weight: bold&quot;)
    if self.italic:
        append(&quot;font-style: italic&quot;)
    if self.underline:
        append(&quot;text-decoration: underline&quot;)
    if self.strike:
        append(&quot;text-decoration: line-through&quot;)
    if self.overline:
        append(&quot;text-decoration: overline&quot;)
    return &quot;; &quot;.join(css)

@classmethod
def combine(cls, styles: Iterable[&quot;Style&quot;]) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Combine styles and get result.

    Args:
        styles (Iterable[Style]): Styles to combine.

    Returns:
        Style: A new style instance.
    &quot;&quot;&quot;
    iter_styles = iter(styles)
    return sum(iter_styles, next(iter_styles))

@classmethod
def chain(cls, *styles: &quot;Style&quot;) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Combine styles from positional argument in to a single style.

    Args:
        *styles (Iterable[Style]): Styles to combine.

    Returns:
        Style: A new style instance.
    &quot;&quot;&quot;
    iter_styles = iter(styles)
    return sum(iter_styles, next(iter_styles))

def copy(self) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Get a copy of this style.

    Returns:
        Style: A new Style instance with identical attributes.
    &quot;&quot;&quot;
    if self._null:
        return NULL_STYLE
    style: Style = self.__new__(Style)
    style._ansi = self._ansi
    style._style_definition = self._style_definition
    style._color = self._color
    style._bgcolor = self._bgcolor
    style._attributes = self._attributes
    style._set_attributes = self._set_attributes
    style._link = self._link
    style._link_id = f&quot;{randint(0, 999999)}&quot; if self._link else &quot;&quot;
    style._hash = self._hash
    style._null = False
    style._meta = self._meta
    return style

@lru_cache(maxsize=128)
def clear_meta_and_links(self) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Get a copy of this style with link and meta information removed.

    Returns:
        Style: New style object.
    &quot;&quot;&quot;
    if self._null:
        return NULL_STYLE
    style: Style = self.__new__(Style)
    style._ansi = self._ansi
    style._style_definition = self._style_definition
    style._color = self._color
    style._bgcolor = self._bgcolor
    style._attributes = self._attributes
    style._set_attributes = self._set_attributes
    style._link = None
    style._link_id = &quot;&quot;
    style._hash = None
    style._null = False
    style._meta = None
    return style

def update_link(self, link: Optional[str] = None) -&gt; &quot;Style&quot;:
    &quot;&quot;&quot;Get a copy with a different value for link.

    Args:
        link (str, optional): New value for link. Defaults to None.

    Returns:
        Style: A new Style instance.
    &quot;&quot;&quot;
    style: Style = self.__new__(Style)
    style._ansi = self._ansi
    style._style_definition = self._style_definition
    style._color = self._color
    style._bgcolor = self._bgcolor
    style._attributes = self._attributes
    style._set_attributes = self._set_attributes
    style._link = link
    style._link_id = f&quot;{randint(0, 999999)}&quot; if link else &quot;&quot;
    style._hash = None
    style._null = False
    style._meta = self._meta
    return style

def render(
    self,
    text: str = &quot;&quot;,
    *,
    color_system: Optional[ColorSystem] = ColorSystem.TRUECOLOR,
    legacy_windows: bool = False,
) -&gt; str:
    &quot;&quot;&quot;Render the ANSI codes for the style.

    Args:
        text (str, optional): A string to style. Defaults to &quot;&quot;.
        color_system (Optional[ColorSystem], optional): Color system to render to. Defaults to ColorSystem.TRUECOLOR.

    Returns:
        str: A string containing ANSI style codes.
    &quot;&quot;&quot;
    if not text or color_system is None:
        return text
    attrs = self._ansi or self._make_ansi_codes(color_system)
    rendered = f&quot;\x1b[{attrs}m{text}\x1b[0m&quot; if attrs else text
    if self._link and not legacy_windows:
        rendered = (
            f&quot;\x1b]8;id={self._link_id};{self._link}\x1b\\{rendered}\x1b]8;;\x1b\\&quot;
        )
    return rendered

def test(self, text: Optional[str] = None) -&gt; None:
    &quot;&quot;&quot;Write text with style directly to terminal.

    This method is for testing purposes only.

    Args:
        text (Optional[str], optional): Text to style or None for style name.

    &quot;&quot;&quot;
    text = text or str(self)
    sys.stdout.write(f&quot;{self.render(text)}\n&quot;)

@lru_cache(maxsize=1024)
def _add(self, style: Optional[&quot;Style&quot;]) -&gt; &quot;Style&quot;:
    if style is None or style._null:
        return self
    if self._null:
        return style
    new_style: Style = self.__new__(Style)
    new_style._ansi = None
    new_style._style_definition = None
    new_style._color = style._color or self._color
    new_style._bgcolor = style._bgcolor or self._bgcolor
    new_style._attributes = (self._attributes &amp; ~style._set_attributes) | (
        style._attributes &amp; style._set_attributes
    )
    new_style._set_attributes = self._set_attributes | style._set_attributes
    new_style._link = style._link or self._link
    new_style._link_id = style._link_id or self._link_id
    new_style._null = style._null
    if self._meta and style._meta:
        new_style._meta = dumps({**self.meta, **style.meta})
    else:
        new_style._meta = self._meta or style._meta
    new_style._hash = None
    return new_style

def __add__(self, style: Optional[&quot;Style&quot;]) -&gt; &quot;Style&quot;:
    combined_style = self._add(style)
    return combined_style.copy() if combined_style.link else combined_style
</pre></div>
</div>
<p>NULL_STYLE = Style()</p>
<p>class StyleStack:
“””A stack of styles.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>__slots__ = [&quot;_stack&quot;]

def __init__(self, default_style: &quot;Style&quot;) -&gt; None:
    self._stack: List[Style] = [default_style]

def __repr__(self) -&gt; str:
    return f&quot;&lt;stylestack {self._stack!r}&gt;&quot;

@property
def current(self) -&gt; Style:
    &quot;&quot;&quot;Get the Style at the top of the stack.&quot;&quot;&quot;
    return self._stack[-1]

def push(self, style: Style) -&gt; None:
    &quot;&quot;&quot;Push a new style on to the stack.

    Args:
        style (Style): New style to combine with current style.
    &quot;&quot;&quot;
    self._stack.append(self._stack[-1] + style)

def pop(self) -&gt; Style:
    &quot;&quot;&quot;Pop last style and discard.

    Returns:
        Style: New current style (also available as stack.current)
    &quot;&quot;&quot;
    self._stack.pop()
    return self._stack[-1]
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>