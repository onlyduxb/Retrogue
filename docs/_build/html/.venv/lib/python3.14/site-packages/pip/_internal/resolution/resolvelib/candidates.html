

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Avoid conflicting with the PyPI package “Python”. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Avoid conflicting with the PyPI package “Python”.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/resolution/resolvelib/candidates.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import logging
import sys
from collections.abc import Iterable
from typing import TYPE_CHECKING, Any, Union, cast</p>
<p>from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version</p>
<p>from pip._internal.exceptions import (
FailedToPrepareCandidate,
HashError,
InstallationSubprocessError,
InvalidInstalledPackage,
MetadataInconsistent,
MetadataInvalid,
)
from pip._internal.metadata import BaseDistribution
from pip._internal.models.link import Link, links_equivalent
from pip._internal.models.wheel import Wheel
from pip._internal.req.constructors import (
install_req_from_editable,
install_req_from_line,
)
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils.direct_url_helpers import direct_url_from_link
from pip._internal.utils.misc import normalize_version_info</p>
<p>from .base import Candidate, Requirement, format_name</p>
<p>if TYPE_CHECKING:
from .factory import Factory</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>BaseCandidate = Union[
“AlreadyInstalledCandidate”,
“EditableCandidate”,
“LinkCandidate”,
]</p>
<section id="avoid-conflicting-with-the-pypi-package-python">
<h1>Avoid conflicting with the PyPI package “Python”.<a class="headerlink" href="#avoid-conflicting-with-the-pypi-package-python" title="Link to this heading"></a></h1>
<p>REQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, “<Python from Requires-Python>”)</p>
<p>def as_base_candidate(candidate: Candidate) -&gt; BaseCandidate | None:
“””The runtime version of BaseCandidate.”””
base_candidate_classes = (
AlreadyInstalledCandidate,
EditableCandidate,
LinkCandidate,
)
if isinstance(candidate, base_candidate_classes):
return candidate
return None</p>
<p>def make_install_req_from_link(
link: Link, template: InstallRequirement
) -&gt; InstallRequirement:
assert not template.editable, “template is editable”
if template.req:
line = str(template.req)
else:
line = link.url
ireq = install_req_from_line(
line,
user_supplied=template.user_supplied,
comes_from=template.comes_from,
isolated=template.isolated,
constraint=template.constraint,
hash_options=template.hash_options,
config_settings=template.config_settings,
)
ireq.original_link = template.original_link
ireq.link = link
ireq.extras = template.extras
return ireq</p>
<p>def make_install_req_from_editable(
link: Link, template: InstallRequirement
) -&gt; InstallRequirement:
assert template.editable, “template not editable”
if template.name:
req_string = f”{template.name} &#64; {link.url}”
else:
req_string = link.url
ireq = install_req_from_editable(
req_string,
user_supplied=template.user_supplied,
comes_from=template.comes_from,
isolated=template.isolated,
constraint=template.constraint,
permit_editable_wheels=template.permit_editable_wheels,
hash_options=template.hash_options,
config_settings=template.config_settings,
)
ireq.extras = template.extras
return ireq</p>
<p>def _make_install_req_from_dist(
dist: BaseDistribution, template: InstallRequirement
) -&gt; InstallRequirement:
if template.req:
line = str(template.req)
elif template.link:
line = f”{dist.canonical_name} &#64; {template.link.url}”
else:
line = f”{dist.canonical_name}=={dist.version}”
ireq = install_req_from_line(
line,
user_supplied=template.user_supplied,
comes_from=template.comes_from,
isolated=template.isolated,
constraint=template.constraint,
hash_options=template.hash_options,
config_settings=template.config_settings,
)
ireq.satisfied_by = dist
return ireq</p>
<p>class _InstallRequirementBackedCandidate(Candidate):
“””A candidate backed by an <code class="docutils literal notranslate"><span class="pre">InstallRequirement</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This represents a package request with the target not being already
in the environment, and needs to be fetched and installed. The backing
``InstallRequirement`` is responsible for most of the leg work; this
class exposes appropriate information to the resolver.

:param link: The link passed to the ``InstallRequirement``. The backing
    ``InstallRequirement`` will use this link to fetch the distribution.
:param source_link: The link this candidate &quot;originates&quot; from. This is
    different from ``link`` when the link is found in the wheel cache.
    ``link`` would point to the wheel cache, while this points to the
    found remote link (e.g. from pypi.org).
&quot;&quot;&quot;

dist: BaseDistribution
is_installed = False

def __init__(
    self,
    link: Link,
    source_link: Link,
    ireq: InstallRequirement,
    factory: Factory,
    name: NormalizedName | None = None,
    version: Version | None = None,
) -&gt; None:
    self._link = link
    self._source_link = source_link
    self._factory = factory
    self._ireq = ireq
    self._name = name
    self._version = version
    self.dist = self._prepare()
    self._hash: int | None = None

def __str__(self) -&gt; str:
    return f&quot;{self.name} {self.version}&quot;

def __repr__(self) -&gt; str:
    return f&quot;{self.__class__.__name__}({str(self._link)!r})&quot;

def __hash__(self) -&gt; int:
    if self._hash is not None:
        return self._hash

    self._hash = hash((self.__class__, self._link))
    return self._hash

def __eq__(self, other: Any) -&gt; bool:
    if isinstance(other, self.__class__):
        return links_equivalent(self._link, other._link)
    return False

@property
def source_link(self) -&gt; Link | None:
    return self._source_link

@property
def project_name(self) -&gt; NormalizedName:
    &quot;&quot;&quot;The normalised name of the project the candidate refers to&quot;&quot;&quot;
    if self._name is None:
        self._name = self.dist.canonical_name
    return self._name

@property
def name(self) -&gt; str:
    return self.project_name

@property
def version(self) -&gt; Version:
    if self._version is None:
        self._version = self.dist.version
    return self._version

def format_for_error(self) -&gt; str:
    return (
        f&quot;{self.name} {self.version} &quot;
        f&quot;(from {self._link.file_path if self._link.is_file else self._link})&quot;
    )

def _prepare_distribution(self) -&gt; BaseDistribution:
    raise NotImplementedError(&quot;Override in subclass&quot;)

def _check_metadata_consistency(self, dist: BaseDistribution) -&gt; None:
    &quot;&quot;&quot;Check for consistency of project name and version of dist.&quot;&quot;&quot;
    if self._name is not None and self._name != dist.canonical_name:
        raise MetadataInconsistent(
            self._ireq,
            &quot;name&quot;,
            self._name,
            dist.canonical_name,
        )
    if self._version is not None and self._version != dist.version:
        raise MetadataInconsistent(
            self._ireq,
            &quot;version&quot;,
            str(self._version),
            str(dist.version),
        )
    # check dependencies are valid
    # TODO performance: this means we iterate the dependencies at least twice,
    # we may want to cache parsed Requires-Dist
    try:
        list(dist.iter_dependencies(list(dist.iter_provided_extras())))
    except InvalidRequirement as e:
        raise MetadataInvalid(self._ireq, str(e))

def _prepare(self) -&gt; BaseDistribution:
    try:
        dist = self._prepare_distribution()
    except HashError as e:
        # Provide HashError the underlying ireq that caused it. This
        # provides context for the resulting error message to show the
        # offending line to the user.
        e.req = self._ireq
        raise
    except InstallationSubprocessError as exc:
        if isinstance(self._ireq.comes_from, InstallRequirement):
            request_chain = self._ireq.comes_from.from_path()
        else:
            request_chain = self._ireq.comes_from

        if request_chain is None:
            request_chain = &quot;directly requested&quot;

        raise FailedToPrepareCandidate(
            package_name=self._ireq.name or str(self._link),
            requirement_chain=request_chain,
            failed_step=exc.command_description,
        )

    self._check_metadata_consistency(dist)
    return dist

def iter_dependencies(self, with_requires: bool) -&gt; Iterable[Requirement | None]:
    # Emit the Requires-Python requirement first to fail fast on
    # unsupported candidates and avoid pointless downloads/preparation.
    yield self._factory.make_requires_python_requirement(self.dist.requires_python)
    requires = self.dist.iter_dependencies() if with_requires else ()
    for r in requires:
        yield from self._factory.make_requirements_from_spec(str(r), self._ireq)

def get_install_requirement(self) -&gt; InstallRequirement | None:
    return self._ireq
</pre></div>
</div>
<p>class LinkCandidate(_InstallRequirementBackedCandidate):
is_editable = False</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    link: Link,
    template: InstallRequirement,
    factory: Factory,
    name: NormalizedName | None = None,
    version: Version | None = None,
) -&gt; None:
    source_link = link
    cache_entry = factory.get_wheel_cache_entry(source_link, name)
    if cache_entry is not None:
        logger.debug(&quot;Using cached wheel link: %s&quot;, cache_entry.link)
        link = cache_entry.link
    ireq = make_install_req_from_link(link, template)
    assert ireq.link == link
    if ireq.link.is_wheel and not ireq.link.is_file:
        wheel = Wheel(ireq.link.filename)
        wheel_name = wheel.name
        assert name == wheel_name, f&quot;{name!r} != {wheel_name!r} for wheel&quot;
        # Version may not be present for PEP 508 direct URLs
        if version is not None:
            wheel_version = Version(wheel.version)
            assert (
                version == wheel_version
            ), f&quot;{version!r} != {wheel_version!r} for wheel {name}&quot;

    if cache_entry is not None:
        assert ireq.link.is_wheel
        assert ireq.link.is_file
        if cache_entry.persistent and template.link is template.original_link:
            ireq.cached_wheel_source_link = source_link
        if cache_entry.origin is not None:
            ireq.download_info = cache_entry.origin
        else:
            # Legacy cache entry that does not have origin.json.
            # download_info may miss the archive_info.hashes field.
            ireq.download_info = direct_url_from_link(
                source_link, link_is_in_wheel_cache=cache_entry.persistent
            )

    super().__init__(
        link=link,
        source_link=source_link,
        ireq=ireq,
        factory=factory,
        name=name,
        version=version,
    )

def _prepare_distribution(self) -&gt; BaseDistribution:
    preparer = self._factory.preparer
    return preparer.prepare_linked_requirement(self._ireq, parallel_builds=True)
</pre></div>
</div>
<p>class EditableCandidate(_InstallRequirementBackedCandidate):
is_editable = True</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    link: Link,
    template: InstallRequirement,
    factory: Factory,
    name: NormalizedName | None = None,
    version: Version | None = None,
) -&gt; None:
    super().__init__(
        link=link,
        source_link=link,
        ireq=make_install_req_from_editable(link, template),
        factory=factory,
        name=name,
        version=version,
    )

def _prepare_distribution(self) -&gt; BaseDistribution:
    return self._factory.preparer.prepare_editable_requirement(self._ireq)
</pre></div>
</div>
<p>class AlreadyInstalledCandidate(Candidate):
is_installed = True
source_link = None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    dist: BaseDistribution,
    template: InstallRequirement,
    factory: Factory,
) -&gt; None:
    self.dist = dist
    self._ireq = _make_install_req_from_dist(dist, template)
    self._factory = factory
    self._version = None

    # This is just logging some messages, so we can do it eagerly.
    # The returned dist would be exactly the same as self.dist because we
    # set satisfied_by in _make_install_req_from_dist.
    # TODO: Supply reason based on force_reinstall and upgrade_strategy.
    skip_reason = &quot;already satisfied&quot;
    factory.preparer.prepare_installed_requirement(self._ireq, skip_reason)

def __str__(self) -&gt; str:
    return str(self.dist)

def __repr__(self) -&gt; str:
    return f&quot;{self.__class__.__name__}({self.dist!r})&quot;

def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, AlreadyInstalledCandidate):
        return NotImplemented
    return self.name == other.name and self.version == other.version

def __hash__(self) -&gt; int:
    return hash((self.name, self.version))

@property
def project_name(self) -&gt; NormalizedName:
    return self.dist.canonical_name

@property
def name(self) -&gt; str:
    return self.project_name

@property
def version(self) -&gt; Version:
    if self._version is None:
        self._version = self.dist.version
    return self._version

@property
def is_editable(self) -&gt; bool:
    return self.dist.editable

def format_for_error(self) -&gt; str:
    return f&quot;{self.name} {self.version} (Installed)&quot;

def iter_dependencies(self, with_requires: bool) -&gt; Iterable[Requirement | None]:
    if not with_requires:
        return

    try:
        for r in self.dist.iter_dependencies():
            yield from self._factory.make_requirements_from_spec(str(r), self._ireq)
    except InvalidRequirement as exc:
        raise InvalidInstalledPackage(dist=self.dist, invalid_exc=exc) from None

def get_install_requirement(self) -&gt; InstallRequirement | None:
    return None
</pre></div>
</div>
<p>class ExtrasCandidate(Candidate):
“””A candidate that has ‘extras’, indicating additional dependencies.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Requirements can be for a project with dependencies, something like
foo[extra].  The extras don&#39;t affect the project/version being installed
directly, but indicate that we need additional dependencies. We model that
by having an artificial ExtrasCandidate that wraps the &quot;base&quot; candidate.

The ExtrasCandidate differs from the base in the following ways:

1. It has a unique name, of the form foo[extra]. This causes the resolver
   to treat it as a separate node in the dependency graph.
2. When we&#39;re getting the candidate&#39;s dependencies,
   a) We specify that we want the extra dependencies as well.
   b) We add a dependency on the base candidate.
      See below for why this is needed.
3. We return None for the underlying InstallRequirement, as the base
   candidate will provide it, and we don&#39;t want to end up with duplicates.

The dependency on the base candidate is needed so that the resolver can&#39;t
decide that it should recommend foo[extra1] version 1.0 and foo[extra2]
version 2.0. Having those candidates depend on foo=1.0 and foo=2.0
respectively forces the resolver to recognise that this is a conflict.
&quot;&quot;&quot;

def __init__(
    self,
    base: BaseCandidate,
    extras: frozenset[str],
    *,
    comes_from: InstallRequirement | None = None,
) -&gt; None:
    &quot;&quot;&quot;
    :param comes_from: the InstallRequirement that led to this candidate if it
        differs from the base&#39;s InstallRequirement. This will often be the
        case in the sense that this candidate&#39;s requirement has the extras
        while the base&#39;s does not. Unlike the InstallRequirement backed
        candidates, this requirement is used solely for reporting purposes,
        it does not do any leg work.
    &quot;&quot;&quot;
    self.base = base
    self.extras = frozenset(canonicalize_name(e) for e in extras)
    self._comes_from = comes_from if comes_from is not None else self.base._ireq

def __str__(self) -&gt; str:
    name, rest = str(self.base).split(&quot; &quot;, 1)
    return &quot;{}[{}] {}&quot;.format(name, &quot;,&quot;.join(self.extras), rest)

def __repr__(self) -&gt; str:
    return f&quot;{self.__class__.__name__}(base={self.base!r}, extras={self.extras!r})&quot;

def __hash__(self) -&gt; int:
    return hash((self.base, self.extras))

def __eq__(self, other: Any) -&gt; bool:
    if isinstance(other, self.__class__):
        return self.base == other.base and self.extras == other.extras
    return False

@property
def project_name(self) -&gt; NormalizedName:
    return self.base.project_name

@property
def name(self) -&gt; str:
    &quot;&quot;&quot;The normalised name of the project the candidate refers to&quot;&quot;&quot;
    return format_name(self.base.project_name, self.extras)

@property
def version(self) -&gt; Version:
    return self.base.version

def format_for_error(self) -&gt; str:
    return &quot;{} [{}]&quot;.format(
        self.base.format_for_error(), &quot;, &quot;.join(sorted(self.extras))
    )

@property
def is_installed(self) -&gt; bool:
    return self.base.is_installed

@property
def is_editable(self) -&gt; bool:
    return self.base.is_editable

@property
def source_link(self) -&gt; Link | None:
    return self.base.source_link

def iter_dependencies(self, with_requires: bool) -&gt; Iterable[Requirement | None]:
    factory = self.base._factory

    # Add a dependency on the exact base
    # (See note 2b in the class docstring)
    yield factory.make_requirement_from_candidate(self.base)
    if not with_requires:
        return

    # The user may have specified extras that the candidate doesn&#39;t
    # support. We ignore any unsupported extras here.
    valid_extras = self.extras.intersection(self.base.dist.iter_provided_extras())
    invalid_extras = self.extras.difference(self.base.dist.iter_provided_extras())
    for extra in sorted(invalid_extras):
        logger.warning(
            &quot;%s %s does not provide the extra &#39;%s&#39;&quot;,
            self.base.name,
            self.version,
            extra,
        )

    for r in self.base.dist.iter_dependencies(valid_extras):
        yield from factory.make_requirements_from_spec(
            str(r),
            self._comes_from,
            valid_extras,
        )

def get_install_requirement(self) -&gt; InstallRequirement | None:
    # We don&#39;t return anything here, because we always
    # depend on the base candidate, and we&#39;ll get the
    # install requirement from that.
    return None
</pre></div>
</div>
<p>class RequiresPythonCandidate(Candidate):
is_installed = False
source_link = None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, py_version_info: tuple[int, ...] | None) -&gt; None:
    if py_version_info is not None:
        version_info = normalize_version_info(py_version_info)
    else:
        version_info = sys.version_info[:3]
    self._version = Version(&quot;.&quot;.join(str(c) for c in version_info))

# We don&#39;t need to implement __eq__() and __ne__() since there is always
# only one RequiresPythonCandidate in a resolution, i.e. the host Python.
# The built-in object.__eq__() and object.__ne__() do exactly what we want.

def __str__(self) -&gt; str:
    return f&quot;Python {self._version}&quot;

def __repr__(self) -&gt; str:
    return f&quot;{self.__class__.__name__}({self._version!r})&quot;

@property
def project_name(self) -&gt; NormalizedName:
    return REQUIRES_PYTHON_IDENTIFIER

@property
def name(self) -&gt; str:
    return REQUIRES_PYTHON_IDENTIFIER

@property
def version(self) -&gt; Version:
    return self._version

def format_for_error(self) -&gt; str:
    return f&quot;Python {self.version}&quot;

def iter_dependencies(self, with_requires: bool) -&gt; Iterable[Requirement | None]:
    return ()

def get_install_requirement(self) -&gt; InstallRequirement | None:
    return None
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>