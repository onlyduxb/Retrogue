

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>-- coding: utf-8 -- &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">-<em>- coding: utf-8 -</em>-</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/distlib/scripts.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="coding-utf-8">
<h1>-<em>- coding: utf-8 -</em>-<a class="headerlink" href="#coding-utf-8" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="copyright-c-2013-2023-vinay-sajip">
<h1>Copyright (C) 2013-2023 Vinay Sajip.<a class="headerlink" href="#copyright-c-2013-2023-vinay-sajip" title="Link to this heading"></a></h1>
</section>
<section id="licensed-to-the-python-software-foundation-under-a-contributor-agreement">
<h1>Licensed to the Python Software Foundation under a contributor agreement.<a class="headerlink" href="#licensed-to-the-python-software-foundation-under-a-contributor-agreement" title="Link to this heading"></a></h1>
</section>
<section id="see-license-txt-and-contributors-txt">
<h1>See LICENSE.txt and CONTRIBUTORS.txt.<a class="headerlink" href="#see-license-txt-and-contributors-txt" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
<p>from io import BytesIO
import logging
import os
import re
import struct
import sys
import time
from zipfile import ZipInfo</p>
<p>from .compat import sysconfig, detect_encoding, ZipFile
from .resources import finder
from .util import (FileOperator, get_export_entry, convert_path, get_executable, get_platform, in_venv)</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>_DEFAULT_MANIFEST = ‘’’</p>
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 <assemblyIdentity version="1.0.0.0"
 processorArchitecture="X86"
 name="%s"
 type="win32"/>
 <!-- Identify the application security requirements. -->
 <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
 <security>
 <requestedPrivileges>
 <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
 </requestedPrivileges>
 </security>
 </trustInfo>
</assembly>'''.strip()
</section>
<section id="check-if-python-is-called-on-the-first-line-with-this-expression">
<h1>check if Python is called on the first line with this expression<a class="headerlink" href="#check-if-python-is-called-on-the-first-line-with-this-expression" title="Link to this heading"></a></h1>
<p>FIRST_LINE_RE = re.compile(b’^#!.<em>pythonw?[0-9.]</em>([ \t].<em>)?$’)
SCRIPT_TEMPLATE = r’’’# -</em>- coding: utf-8 -*-
import re
import sys
if <strong>name</strong> == ‘<strong>main</strong>’:
from %(module)s import %(import_name)s
sys.argv[0] = re.sub(r’(-script.pyw|.exe)?$’, ‘’, sys.argv[0])
sys.exit(%(func)s())
‘’’</p>
</section>
<section id="pre-fetch-the-contents-of-all-executable-wrapper-stubs">
<h1>Pre-fetch the contents of all executable wrapper stubs.<a class="headerlink" href="#pre-fetch-the-contents-of-all-executable-wrapper-stubs" title="Link to this heading"></a></h1>
</section>
<section id="this-is-to-address-https-github-com-pypa-pip-issues-12666">
<h1>This is to address https://github.com/pypa/pip/issues/12666.<a class="headerlink" href="#this-is-to-address-https-github-com-pypa-pip-issues-12666" title="Link to this heading"></a></h1>
</section>
<section id="when-updating-pip-we-rename-the-old-pip-in-place-before-installing-the">
<h1>When updating pip, we rename the old pip in place before installing the<a class="headerlink" href="#when-updating-pip-we-rename-the-old-pip-in-place-before-installing-the" title="Link to this heading"></a></h1>
</section>
<section id="new-version-if-we-try-to-fetch-a-wrapper-after-that-rename-the-finder">
<h1>new version. If we try to fetch a wrapper <em>after</em> that rename, the finder<a class="headerlink" href="#new-version-if-we-try-to-fetch-a-wrapper-after-that-rename-the-finder" title="Link to this heading"></a></h1>
</section>
<section id="machinery-will-be-confused-as-the-package-is-no-longer-available-at-the">
<h1>machinery will be confused as the package is no longer available at the<a class="headerlink" href="#machinery-will-be-confused-as-the-package-is-no-longer-available-at-the" title="Link to this heading"></a></h1>
</section>
<section id="location-where-it-was-imported-from-so-we-load-everything-into-memory-in">
<h1>location where it was imported from. So we load everything into memory in<a class="headerlink" href="#location-where-it-was-imported-from-so-we-load-everything-into-memory-in" title="Link to this heading"></a></h1>
</section>
<section id="advance">
<h1>advance.<a class="headerlink" href="#advance" title="Link to this heading"></a></h1>
<p>if os.name == ‘nt’ or (os.name == ‘java’ and os._name == ‘nt’):
# Issue 31: don’t hardcode an absolute package name, but
# determine it relative to the current package
DISTLIB_PACKAGE = <strong>name</strong>.rsplit(‘.’, 1)[0]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>WRAPPERS = {
    r.name: r.bytes
    for r in finder(DISTLIB_PACKAGE).iterator(&quot;&quot;)
    if r.name.endswith(&quot;.exe&quot;)
}
</pre></div>
</div>
<p>def enquote_executable(executable):
if ‘ ‘ in executable:
# make sure we quote only the executable in case of env
# for example /usr/bin/env “/dir with spaces/bin/jython”
# instead of “/usr/bin/env /dir with spaces/bin/jython”
# otherwise whole
if executable.startswith(‘/usr/bin/env ‘):
env, _executable = executable.split(’ ‘, 1)
if ‘ ‘ in _executable and not _executable.startswith(‘”’):
executable = ‘%s “%s”’ % (env, _executable)
else:
if not executable.startswith(‘”’):
executable = ‘”%s”’ % executable
return executable</p>
</section>
<section id="keep-the-old-name-around-for-now-as-there-is-at-least-one-project-using-it">
<h1>Keep the old name around (for now), as there is at least one project using it!<a class="headerlink" href="#keep-the-old-name-around-for-now-as-there-is-at-least-one-project-using-it" title="Link to this heading"></a></h1>
<p>_enquote_executable = enquote_executable</p>
<p>class ScriptMaker(object):
“””
A class to copy or create scripts from source scripts or callable
specifications.
“””
script_template = SCRIPT_TEMPLATE</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>executable = None  # for shebangs

def __init__(self, source_dir, target_dir, add_launchers=True, dry_run=False, fileop=None):
    self.source_dir = source_dir
    self.target_dir = target_dir
    self.add_launchers = add_launchers
    self.force = False
    self.clobber = False
    # It only makes sense to set mode bits on POSIX.
    self.set_mode = (os.name == &#39;posix&#39;) or (os.name == &#39;java&#39; and os._name == &#39;posix&#39;)
    self.variants = set((&#39;&#39;, &#39;X.Y&#39;))
    self._fileop = fileop or FileOperator(dry_run)

    self._is_nt = os.name == &#39;nt&#39; or (os.name == &#39;java&#39; and os._name == &#39;nt&#39;)
    self.version_info = sys.version_info

def _get_alternate_executable(self, executable, options):
    if options.get(&#39;gui&#39;, False) and self._is_nt:  # pragma: no cover
        dn, fn = os.path.split(executable)
        fn = fn.replace(&#39;python&#39;, &#39;pythonw&#39;)
        executable = os.path.join(dn, fn)
    return executable

if sys.platform.startswith(&#39;java&#39;):  # pragma: no cover

    def _is_shell(self, executable):
        &quot;&quot;&quot;
        Determine if the specified executable is a script
        (contains a #! line)
        &quot;&quot;&quot;
        try:
            with open(executable) as fp:
                return fp.read(2) == &#39;#!&#39;
        except (OSError, IOError):
            logger.warning(&#39;Failed to open %s&#39;, executable)
            return False

    def _fix_jython_executable(self, executable):
        if self._is_shell(executable):
            # Workaround for Jython is not needed on Linux systems.
            import java

            if java.lang.System.getProperty(&#39;os.name&#39;) == &#39;Linux&#39;:
                return executable
        elif executable.lower().endswith(&#39;jython.exe&#39;):
            # Use wrapper exe for Jython on Windows
            return executable
        return &#39;/usr/bin/env %s&#39; % executable

def _build_shebang(self, executable, post_interp):
    &quot;&quot;&quot;
    Build a shebang line. In the simple case (on Windows, or a shebang line
    which is not too long or contains spaces) use a simple formulation for
    the shebang. Otherwise, use /bin/sh as the executable, with a contrived
    shebang which allows the script to run either under Python or sh, using
    suitable quoting. Thanks to Harald Nordgren for his input.

    See also: http://www.in-ulm.de/~mascheck/various/shebang/#length
              https://hg.mozilla.org/mozilla-central/file/tip/mach
    &quot;&quot;&quot;
    if os.name != &#39;posix&#39;:
        simple_shebang = True
    elif getattr(sys, &quot;cross_compiling&quot;, False):
        # In a cross-compiling environment, the shebang will likely be a
        # script; this *must* be invoked with the &quot;safe&quot; version of the
        # shebang, or else using os.exec() to run the entry script will
        # fail, raising &quot;OSError 8 [Errno 8] Exec format error&quot;.
        simple_shebang = False
    else:
        # Add 3 for &#39;#!&#39; prefix and newline suffix.
        shebang_length = len(executable) + len(post_interp) + 3
        if sys.platform == &#39;darwin&#39;:
            max_shebang_length = 512
        else:
            max_shebang_length = 127
        simple_shebang = ((b&#39; &#39; not in executable) and (shebang_length &lt;= max_shebang_length))

    if simple_shebang:
        result = b&#39;#!&#39; + executable + post_interp + b&#39;\n&#39;
    else:
        result = b&#39;#!/bin/sh\n&#39;
        result += b&quot;&#39;&#39;&#39;exec&#39; &quot; + executable + post_interp + b&#39; &quot;$0&quot; &quot;$@&quot;\n&#39;
        result += b&quot;&#39; &#39;&#39;&#39;\n&quot;
    return result

def _get_shebang(self, encoding, post_interp=b&#39;&#39;, options=None):
    enquote = True
    if self.executable:
        executable = self.executable
        enquote = False  # assume this will be taken care of
    elif not sysconfig.is_python_build():
        executable = get_executable()
    elif in_venv():  # pragma: no cover
        executable = os.path.join(sysconfig.get_path(&#39;scripts&#39;), &#39;python%s&#39; % sysconfig.get_config_var(&#39;EXE&#39;))
    else:  # pragma: no cover
        if os.name == &#39;nt&#39;:
            # for Python builds from source on Windows, no Python executables with
            # a version suffix are created, so we use python.exe
            executable = os.path.join(sysconfig.get_config_var(&#39;BINDIR&#39;),
                                      &#39;python%s&#39; % (sysconfig.get_config_var(&#39;EXE&#39;)))
        else:
            executable = os.path.join(
                sysconfig.get_config_var(&#39;BINDIR&#39;),
                &#39;python%s%s&#39; % (sysconfig.get_config_var(&#39;VERSION&#39;), sysconfig.get_config_var(&#39;EXE&#39;)))
    if options:
        executable = self._get_alternate_executable(executable, options)

    if sys.platform.startswith(&#39;java&#39;):  # pragma: no cover
        executable = self._fix_jython_executable(executable)

    # Normalise case for Windows - COMMENTED OUT
    # executable = os.path.normcase(executable)
    # N.B. The normalising operation above has been commented out: See
    # issue #124. Although paths in Windows are generally case-insensitive,
    # they aren&#39;t always. For example, a path containing a ẞ (which is a
    # LATIN CAPITAL LETTER SHARP S - U+1E9E) is normcased to ß (which is a
    # LATIN SMALL LETTER SHARP S&#39; - U+00DF). The two are not considered by
    # Windows as equivalent in path names.

    # If the user didn&#39;t specify an executable, it may be necessary to
    # cater for executable paths with spaces (not uncommon on Windows)
    if enquote:
        executable = enquote_executable(executable)
    # Issue #51: don&#39;t use fsencode, since we later try to
    # check that the shebang is decodable using utf-8.
    executable = executable.encode(&#39;utf-8&#39;)
    # in case of IronPython, play safe and enable frames support
    if (sys.platform == &#39;cli&#39; and &#39;-X:Frames&#39; not in post_interp and
            &#39;-X:FullFrames&#39; not in post_interp):  # pragma: no cover
        post_interp += b&#39; -X:Frames&#39;
    shebang = self._build_shebang(executable, post_interp)
    # Python parser starts to read a script using UTF-8 until
    # it gets a #coding:xxx cookie. The shebang has to be the
    # first line of a file, the #coding:xxx cookie cannot be
    # written before. So the shebang has to be decodable from
    # UTF-8.
    try:
        shebang.decode(&#39;utf-8&#39;)
    except UnicodeDecodeError:  # pragma: no cover
        raise ValueError(&#39;The shebang (%r) is not decodable from utf-8&#39; % shebang)
    # If the script is encoded to a custom encoding (use a
    # #coding:xxx cookie), the shebang has to be decodable from
    # the script encoding too.
    if encoding != &#39;utf-8&#39;:
        try:
            shebang.decode(encoding)
        except UnicodeDecodeError:  # pragma: no cover
            raise ValueError(&#39;The shebang (%r) is not decodable &#39;
                             &#39;from the script encoding (%r)&#39; % (shebang, encoding))
    return shebang

def _get_script_text(self, entry):
    return self.script_template % dict(
        module=entry.prefix, import_name=entry.suffix.split(&#39;.&#39;)[0], func=entry.suffix)

manifest = _DEFAULT_MANIFEST

def get_manifest(self, exename):
    base = os.path.basename(exename)
    return self.manifest % base

def _write_script(self, names, shebang, script_bytes, filenames, ext):
    use_launcher = self.add_launchers and self._is_nt
    if not use_launcher:
        script_bytes = shebang + script_bytes
    else:  # pragma: no cover
        if ext == &#39;py&#39;:
            launcher = self._get_launcher(&#39;t&#39;)
        else:
            launcher = self._get_launcher(&#39;w&#39;)
        stream = BytesIO()
        with ZipFile(stream, &#39;w&#39;) as zf:
            source_date_epoch = os.environ.get(&#39;SOURCE_DATE_EPOCH&#39;)
            if source_date_epoch:
                date_time = time.gmtime(int(source_date_epoch))[:6]
                zinfo = ZipInfo(filename=&#39;__main__.py&#39;, date_time=date_time)
                zf.writestr(zinfo, script_bytes)
            else:
                zf.writestr(&#39;__main__.py&#39;, script_bytes)
        zip_data = stream.getvalue()
        script_bytes = launcher + shebang + zip_data
    for name in names:
        outname = os.path.join(self.target_dir, name)
        if use_launcher:  # pragma: no cover
            n, e = os.path.splitext(outname)
            if e.startswith(&#39;.py&#39;):
                outname = n
            outname = &#39;%s.exe&#39; % outname
            try:
                self._fileop.write_binary_file(outname, script_bytes)
            except Exception:
                # Failed writing an executable - it might be in use.
                logger.warning(&#39;Failed to write executable - trying to &#39;
                               &#39;use .deleteme logic&#39;)
                dfname = &#39;%s.deleteme&#39; % outname
                if os.path.exists(dfname):
                    os.remove(dfname)  # Not allowed to fail here
                os.rename(outname, dfname)  # nor here
                self._fileop.write_binary_file(outname, script_bytes)
                logger.debug(&#39;Able to replace executable using &#39;
                             &#39;.deleteme logic&#39;)
                try:
                    os.remove(dfname)
                except Exception:
                    pass  # still in use - ignore error
        else:
            if self._is_nt and not outname.endswith(&#39;.&#39; + ext):  # pragma: no cover
                outname = &#39;%s.%s&#39; % (outname, ext)
            if os.path.exists(outname) and not self.clobber:
                logger.warning(&#39;Skipping existing file %s&#39;, outname)
                continue
            self._fileop.write_binary_file(outname, script_bytes)
            if self.set_mode:
                self._fileop.set_executable_mode([outname])
        filenames.append(outname)

variant_separator = &#39;-&#39;

def get_script_filenames(self, name):
    result = set()
    if &#39;&#39; in self.variants:
        result.add(name)
    if &#39;X&#39; in self.variants:
        result.add(&#39;%s%s&#39; % (name, self.version_info[0]))
    if &#39;X.Y&#39; in self.variants:
        result.add(&#39;%s%s%s.%s&#39; % (name, self.variant_separator, self.version_info[0], self.version_info[1]))
    return result

def _make_script(self, entry, filenames, options=None):
    post_interp = b&#39;&#39;
    if options:
        args = options.get(&#39;interpreter_args&#39;, [])
        if args:
            args = &#39; %s&#39; % &#39; &#39;.join(args)
            post_interp = args.encode(&#39;utf-8&#39;)
    shebang = self._get_shebang(&#39;utf-8&#39;, post_interp, options=options)
    script = self._get_script_text(entry).encode(&#39;utf-8&#39;)
    scriptnames = self.get_script_filenames(entry.name)
    if options and options.get(&#39;gui&#39;, False):
        ext = &#39;pyw&#39;
    else:
        ext = &#39;py&#39;
    self._write_script(scriptnames, shebang, script, filenames, ext)

def _copy_script(self, script, filenames):
    adjust = False
    script = os.path.join(self.source_dir, convert_path(script))
    outname = os.path.join(self.target_dir, os.path.basename(script))
    if not self.force and not self._fileop.newer(script, outname):
        logger.debug(&#39;not copying %s (up-to-date)&#39;, script)
        return

    # Always open the file, but ignore failures in dry-run mode --
    # that way, we&#39;ll get accurate feedback if we can read the
    # script.
    try:
        f = open(script, &#39;rb&#39;)
    except IOError:  # pragma: no cover
        if not self.dry_run:
            raise
        f = None
    else:
        first_line = f.readline()
        if not first_line:  # pragma: no cover
            logger.warning(&#39;%s is an empty file (skipping)&#39;, script)
            return

        match = FIRST_LINE_RE.match(first_line.replace(b&#39;\r\n&#39;, b&#39;\n&#39;))
        if match:
            adjust = True
            post_interp = match.group(1) or b&#39;&#39;

    if not adjust:
        if f:
            f.close()
        self._fileop.copy_file(script, outname)
        if self.set_mode:
            self._fileop.set_executable_mode([outname])
        filenames.append(outname)
    else:
        logger.info(&#39;copying and adjusting %s -&gt; %s&#39;, script, self.target_dir)
        if not self._fileop.dry_run:
            encoding, lines = detect_encoding(f.readline)
            f.seek(0)
            shebang = self._get_shebang(encoding, post_interp)
            if b&#39;pythonw&#39; in first_line:  # pragma: no cover
                ext = &#39;pyw&#39;
            else:
                ext = &#39;py&#39;
            n = os.path.basename(outname)
            self._write_script([n], shebang, f.read(), filenames, ext)
        if f:
            f.close()

@property
def dry_run(self):
    return self._fileop.dry_run

@dry_run.setter
def dry_run(self, value):
    self._fileop.dry_run = value

if os.name == &#39;nt&#39; or (os.name == &#39;java&#39; and os._name == &#39;nt&#39;):  # pragma: no cover
    # Executable launcher support.
    # Launchers are from https://bitbucket.org/vinay.sajip/simple_launcher/

    def _get_launcher(self, kind):
        if struct.calcsize(&#39;P&#39;) == 8:  # 64-bit
            bits = &#39;64&#39;
        else:
            bits = &#39;32&#39;
        platform_suffix = &#39;-arm&#39; if get_platform() == &#39;win-arm64&#39; else &#39;&#39;
        name = &#39;%s%s%s.exe&#39; % (kind, bits, platform_suffix)
        if name not in WRAPPERS:
            msg = (&#39;Unable to find resource %s in package %s&#39; %
                   (name, DISTLIB_PACKAGE))
            raise ValueError(msg)
        return WRAPPERS[name]

# Public API follows

def make(self, specification, options=None):
    &quot;&quot;&quot;
    Make a script.

    :param specification: The specification, which is either a valid export
                          entry specification (to make a script from a
                          callable) or a filename (to make a script by
                          copying from a source location).
    :param options: A dictionary of options controlling script generation.
    :return: A list of all absolute pathnames written to.
    &quot;&quot;&quot;
    filenames = []
    entry = get_export_entry(specification)
    if entry is None:
        self._copy_script(specification, filenames)
    else:
        self._make_script(entry, filenames, options=options)
    return filenames

def make_multiple(self, specifications, options=None):
    &quot;&quot;&quot;
    Take a list of specifications and make scripts from them,
    :param specifications: A list of specifications.
    :return: A list of all absolute pathnames written to,
    &quot;&quot;&quot;
    filenames = []
    for specification in specifications:
        filenames.extend(self.make(specification, options))
    return filenames
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>