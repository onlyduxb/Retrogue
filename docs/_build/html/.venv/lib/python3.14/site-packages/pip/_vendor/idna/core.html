

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/idna/core.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>import bisect
import re
import unicodedata
from typing import Optional, Union</p>
<p>from . import idnadata
from .intranges import intranges_contain</p>
<p>_virama_combining_class = 9
_alabel_prefix = b”xn–”
_unicode_dots_re = re.compile(“[\u002e\u3002\uff0e\uff61]”)</p>
<p>class IDNAError(UnicodeError):
“””Base exception for all IDNA-encoding related problems”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pass
</pre></div>
</div>
<p>class IDNABidiError(IDNAError):
“””Exception when bidirectional requirements are not satisfied”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pass
</pre></div>
</div>
<p>class InvalidCodepoint(IDNAError):
“””Exception when a disallowed or unallocated codepoint is used”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pass
</pre></div>
</div>
<p>class InvalidCodepointContext(IDNAError):
“””Exception when the codepoint is not valid in the context it is used”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pass
</pre></div>
</div>
<p>def _combining_class(cp: int) -&gt; int:
v = unicodedata.combining(chr(cp))
if v == 0:
if not unicodedata.name(chr(cp)):
raise ValueError(“Unknown character in unicodedata”)
return v</p>
<p>def _is_script(cp: str, script: str) -&gt; bool:
return intranges_contain(ord(cp), idnadata.scripts[script])</p>
<p>def _punycode(s: str) -&gt; bytes:
return s.encode(“punycode”)</p>
<p>def _unot(s: int) -&gt; str:
return “U+{:04X}”.format(s)</p>
<p>def valid_label_length(label: Union[bytes, str]) -&gt; bool:
if len(label) &gt; 63:
return False
return True</p>
<p>def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -&gt; bool:
if len(label) &gt; (254 if trailing_dot else 253):
return False
return True</p>
<p>def check_bidi(label: str, check_ltr: bool = False) -&gt; bool:
# Bidi rules should only be applied if string contains RTL characters
bidi_label = False
for idx, cp in enumerate(label, 1):
direction = unicodedata.bidirectional(cp)
if direction == “”:
# String likely comes from a newer version of Unicode
raise IDNABidiError(“Unknown directionality in label {} at position {}”.format(repr(label), idx))
if direction in [“R”, “AL”, “AN”]:
bidi_label = True
if not bidi_label and not check_ltr:
return True</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Bidi rule 1
direction = unicodedata.bidirectional(label[0])
if direction in [&quot;R&quot;, &quot;AL&quot;]:
    rtl = True
elif direction == &quot;L&quot;:
    rtl = False
else:
    raise IDNABidiError(&quot;First codepoint in label {} must be directionality L, R or AL&quot;.format(repr(label)))

valid_ending = False
number_type: Optional[str] = None
for idx, cp in enumerate(label, 1):
    direction = unicodedata.bidirectional(cp)

    if rtl:
        # Bidi rule 2
        if direction not in [
            &quot;R&quot;,
            &quot;AL&quot;,
            &quot;AN&quot;,
            &quot;EN&quot;,
            &quot;ES&quot;,
            &quot;CS&quot;,
            &quot;ET&quot;,
            &quot;ON&quot;,
            &quot;BN&quot;,
            &quot;NSM&quot;,
        ]:
            raise IDNABidiError(&quot;Invalid direction for codepoint at position {} in a right-to-left label&quot;.format(idx))
        # Bidi rule 3
        if direction in [&quot;R&quot;, &quot;AL&quot;, &quot;EN&quot;, &quot;AN&quot;]:
            valid_ending = True
        elif direction != &quot;NSM&quot;:
            valid_ending = False
        # Bidi rule 4
        if direction in [&quot;AN&quot;, &quot;EN&quot;]:
            if not number_type:
                number_type = direction
            else:
                if number_type != direction:
                    raise IDNABidiError(&quot;Can not mix numeral types in a right-to-left label&quot;)
    else:
        # Bidi rule 5
        if direction not in [&quot;L&quot;, &quot;EN&quot;, &quot;ES&quot;, &quot;CS&quot;, &quot;ET&quot;, &quot;ON&quot;, &quot;BN&quot;, &quot;NSM&quot;]:
            raise IDNABidiError(&quot;Invalid direction for codepoint at position {} in a left-to-right label&quot;.format(idx))
        # Bidi rule 6
        if direction in [&quot;L&quot;, &quot;EN&quot;]:
            valid_ending = True
        elif direction != &quot;NSM&quot;:
            valid_ending = False

if not valid_ending:
    raise IDNABidiError(&quot;Label ends with illegal codepoint directionality&quot;)

return True
</pre></div>
</div>
<p>def check_initial_combiner(label: str) -&gt; bool:
if unicodedata.category(label[0])[0] == “M”:
raise IDNAError(“Label begins with an illegal combining character”)
return True</p>
<p>def check_hyphen_ok(label: str) -&gt; bool:
if label[2:4] == “–“:
raise IDNAError(“Label has disallowed hyphens in 3rd and 4th position”)
if label[0] == “-” or label[-1] == “-“:
raise IDNAError(“Label must not start or end with a hyphen”)
return True</p>
<p>def check_nfc(label: str) -&gt; None:
if unicodedata.normalize(“NFC”, label) != label:
raise IDNAError(“Label must be in Normalization Form C”)</p>
<p>def valid_contextj(label: str, pos: int) -&gt; bool:
cp_value = ord(label[pos])</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if cp_value == 0x200C:
    if pos &gt; 0:
        if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
            return True

    ok = False
    for i in range(pos - 1, -1, -1):
        joining_type = idnadata.joining_types.get(ord(label[i]))
        if joining_type == ord(&quot;T&quot;):
            continue
        elif joining_type in [ord(&quot;L&quot;), ord(&quot;D&quot;)]:
            ok = True
            break
        else:
            break

    if not ok:
        return False

    ok = False
    for i in range(pos + 1, len(label)):
        joining_type = idnadata.joining_types.get(ord(label[i]))
        if joining_type == ord(&quot;T&quot;):
            continue
        elif joining_type in [ord(&quot;R&quot;), ord(&quot;D&quot;)]:
            ok = True
            break
        else:
            break
    return ok

if cp_value == 0x200D:
    if pos &gt; 0:
        if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
            return True
    return False

else:
    return False
</pre></div>
</div>
<p>def valid_contexto(label: str, pos: int, exception: bool = False) -&gt; bool:
cp_value = ord(label[pos])</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if cp_value == 0x00B7:
    if 0 &lt; pos &lt; len(label) - 1:
        if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:
            return True
    return False

elif cp_value == 0x0375:
    if pos &lt; len(label) - 1 and len(label) &gt; 1:
        return _is_script(label[pos + 1], &quot;Greek&quot;)
    return False

elif cp_value == 0x05F3 or cp_value == 0x05F4:
    if pos &gt; 0:
        return _is_script(label[pos - 1], &quot;Hebrew&quot;)
    return False

elif cp_value == 0x30FB:
    for cp in label:
        if cp == &quot;\u30fb&quot;:
            continue
        if _is_script(cp, &quot;Hiragana&quot;) or _is_script(cp, &quot;Katakana&quot;) or _is_script(cp, &quot;Han&quot;):
            return True
    return False

elif 0x660 &lt;= cp_value &lt;= 0x669:
    for cp in label:
        if 0x6F0 &lt;= ord(cp) &lt;= 0x06F9:
            return False
    return True

elif 0x6F0 &lt;= cp_value &lt;= 0x6F9:
    for cp in label:
        if 0x660 &lt;= ord(cp) &lt;= 0x0669:
            return False
    return True

return False
</pre></div>
</div>
<p>def check_label(label: Union[str, bytes, bytearray]) -&gt; None:
if isinstance(label, (bytes, bytearray)):
label = label.decode(“utf-8”)
if len(label) == 0:
raise IDNAError(“Empty Label”)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>check_nfc(label)
check_hyphen_ok(label)
check_initial_combiner(label)

for pos, cp in enumerate(label):
    cp_value = ord(cp)
    if intranges_contain(cp_value, idnadata.codepoint_classes[&quot;PVALID&quot;]):
        continue
    elif intranges_contain(cp_value, idnadata.codepoint_classes[&quot;CONTEXTJ&quot;]):
        try:
            if not valid_contextj(label, pos):
                raise InvalidCodepointContext(
                    &quot;Joiner {} not allowed at position {} in {}&quot;.format(_unot(cp_value), pos + 1, repr(label))
                )
        except ValueError:
            raise IDNAError(
                &quot;Unknown codepoint adjacent to joiner {} at position {} in {}&quot;.format(
                    _unot(cp_value), pos + 1, repr(label)
                )
            )
    elif intranges_contain(cp_value, idnadata.codepoint_classes[&quot;CONTEXTO&quot;]):
        if not valid_contexto(label, pos):
            raise InvalidCodepointContext(
                &quot;Codepoint {} not allowed at position {} in {}&quot;.format(_unot(cp_value), pos + 1, repr(label))
            )
    else:
        raise InvalidCodepoint(
            &quot;Codepoint {} at position {} of {} not allowed&quot;.format(_unot(cp_value), pos + 1, repr(label))
        )

check_bidi(label)
</pre></div>
</div>
<p>def alabel(label: str) -&gt; bytes:
try:
label_bytes = label.encode(“ascii”)
ulabel(label_bytes)
if not valid_label_length(label_bytes):
raise IDNAError(“Label too long”)
return label_bytes
except UnicodeEncodeError:
pass</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>check_label(label)
label_bytes = _alabel_prefix + _punycode(label)

if not valid_label_length(label_bytes):
    raise IDNAError(&quot;Label too long&quot;)

return label_bytes
</pre></div>
</div>
<p>def ulabel(label: Union[str, bytes, bytearray]) -&gt; str:
if not isinstance(label, (bytes, bytearray)):
try:
label_bytes = label.encode(“ascii”)
except UnicodeEncodeError:
check_label(label)
return label
else:
label_bytes = label</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>label_bytes = label_bytes.lower()
if label_bytes.startswith(_alabel_prefix):
    label_bytes = label_bytes[len(_alabel_prefix) :]
    if not label_bytes:
        raise IDNAError(&quot;Malformed A-label, no Punycode eligible content found&quot;)
    if label_bytes.decode(&quot;ascii&quot;)[-1] == &quot;-&quot;:
        raise IDNAError(&quot;A-label must not end with a hyphen&quot;)
else:
    check_label(label_bytes)
    return label_bytes.decode(&quot;ascii&quot;)

try:
    label = label_bytes.decode(&quot;punycode&quot;)
except UnicodeError:
    raise IDNAError(&quot;Invalid A-label&quot;)
check_label(label)
return label
</pre></div>
</div>
<p>def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -&gt; str:
“””Re-map the characters in the string according to UTS46 processing.”””
from .uts46data import uts46data</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>output = &quot;&quot;

for pos, char in enumerate(domain):
    code_point = ord(char)
    try:
        uts46row = uts46data[code_point if code_point &lt; 256 else bisect.bisect_left(uts46data, (code_point, &quot;Z&quot;)) - 1]
        status = uts46row[1]
        replacement: Optional[str] = None
        if len(uts46row) == 3:
            replacement = uts46row[2]
        if (
            status == &quot;V&quot;
            or (status == &quot;D&quot; and not transitional)
            or (status == &quot;3&quot; and not std3_rules and replacement is None)
        ):
            output += char
        elif replacement is not None and (
            status == &quot;M&quot; or (status == &quot;3&quot; and not std3_rules) or (status == &quot;D&quot; and transitional)
        ):
            output += replacement
        elif status != &quot;I&quot;:
            raise IndexError()
    except IndexError:
        raise InvalidCodepoint(
            &quot;Codepoint {} not allowed at position {} in {}&quot;.format(_unot(code_point), pos + 1, repr(domain))
        )

return unicodedata.normalize(&quot;NFC&quot;, output)
</pre></div>
</div>
<p>def encode(
s: Union[str, bytes, bytearray],
strict: bool = False,
uts46: bool = False,
std3_rules: bool = False,
transitional: bool = False,
) -&gt; bytes:
if not isinstance(s, str):
try:
s = str(s, “ascii”)
except UnicodeDecodeError:
raise IDNAError(“should pass a unicode string to the function rather than a byte string.”)
if uts46:
s = uts46_remap(s, std3_rules, transitional)
trailing_dot = False
result = []
if strict:
labels = s.split(“.”)
else:
labels = _unicode_dots_re.split(s)
if not labels or labels == [“”]:
raise IDNAError(“Empty domain”)
if labels[-1] == “”:
del labels[-1]
trailing_dot = True
for label in labels:
s = alabel(label)
if s:
result.append(s)
else:
raise IDNAError(“Empty label”)
if trailing_dot:
result.append(b””)
s = b”.”.join(result)
if not valid_string_length(s, trailing_dot):
raise IDNAError(“Domain too long”)
return s</p>
<p>def decode(
s: Union[str, bytes, bytearray],
strict: bool = False,
uts46: bool = False,
std3_rules: bool = False,
) -&gt; str:
try:
if not isinstance(s, str):
s = str(s, “ascii”)
except UnicodeDecodeError:
raise IDNAError(“Invalid ASCII in A-label”)
if uts46:
s = uts46_remap(s, std3_rules, False)
trailing_dot = False
result = []
if not strict:
labels = _unicode_dots_re.split(s)
else:
labels = s.split(“.”)
if not labels or labels == [“”]:
raise IDNAError(“Empty domain”)
if not labels[-1]:
del labels[-1]
trailing_dot = True
for label in labels:
s = ulabel(label)
if s:
result.append(s)
else:
raise IDNAError(“Empty label”)
if trailing_dot:
result.append(“”)
return “.”.join(result)</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>