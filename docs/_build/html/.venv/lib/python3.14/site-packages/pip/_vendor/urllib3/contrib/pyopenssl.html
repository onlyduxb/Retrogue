

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SNI always works. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SNI always works.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/contrib/pyopenssl.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
TLS with SNI_-support for Python 2. Follow these instructions if you would
like to verify TLS certificates in Python 2. Note, the default libraries do
<em>not</em> do certificate checking; you need to do additional work to validate
certificates yourself.</p>
<p>This needs the following packages installed:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pyOpenSSL</span></code>_ (tested with 16.0.0)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cryptography</span></code>_ (minimum 1.3.4, from pyopenssl)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">idna</span></code>_ (minimum 2.0, from cryptography)</p></li>
</ul>
<p>However, pyopenssl depends on cryptography, which depends on idna, so while we
use all three directly here we end up having relatively few packages required.</p>
<p>You can install them with the following command:</p>
<p>.. code-block:: bash</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ python -m pip install pyopenssl cryptography idna
</pre></div>
</div>
<p>To activate certificate checking, call
:func:<code class="docutils literal notranslate"><span class="pre">~urllib3.contrib.pyopenssl.inject_into_urllib3</span></code> from your Python code
before you begin making HTTP requests. This can be done in a <code class="docutils literal notranslate"><span class="pre">sitecustomize</span></code>
module, or at any other time before your application begins using <code class="docutils literal notranslate"><span class="pre">urllib3</span></code>,
like this:</p>
<p>.. code-block:: python</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>try:
    import pip._vendor.urllib3.contrib.pyopenssl as pyopenssl
    pyopenssl.inject_into_urllib3()
except ImportError:
    pass
</pre></div>
</div>
<p>Now you can use :mod:<code class="docutils literal notranslate"><span class="pre">urllib3</span></code> as you normally would, and it will support SNI
when the required modules are installed.</p>
<p>Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see <code class="docutils literal notranslate"><span class="pre">CRIME</span> <span class="pre">attack</span></code>_).</p>
<p>.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. <em>crime attack: https://en.wikipedia.org/wiki/CRIME</em>(security_exploit)
.. _pyopenssl: https://www.pyopenssl.org
.. _cryptography: https://cryptography.io
.. _idna: https://github.com/kjd/idna
“””
from <strong>future</strong> import absolute_import</p>
<p>import OpenSSL.crypto
import OpenSSL.SSL
from cryptography import x509
from cryptography.hazmat.backends.openssl import backend as openssl_backend</p>
<p>try:
from cryptography.x509 import UnsupportedExtension
except ImportError:
# UnsupportedExtension is gone in cryptography &gt;= 2.1.0
class UnsupportedExtension(Exception):
pass</p>
<p>from io import BytesIO
from socket import error as SocketError
from socket import timeout</p>
<p>try:  # Platform-specific: Python 2
from socket import _fileobject
except ImportError:  # Platform-specific: Python 3
_fileobject = None
from ..packages.backports.makefile import backport_makefile</p>
<p>import logging
import ssl
import sys
import warnings</p>
<p>from .. import util
from ..packages import six
from ..util.ssl_ import PROTOCOL_TLS_CLIENT</p>
<p>warnings.warn(
“‘urllib3.contrib.pyopenssl’ module is deprecated and will be removed “
“in a future release of urllib3 2.x. Read more in this issue: “
“https://github.com/urllib3/urllib3/issues/2680”,
category=DeprecationWarning,
stacklevel=2,
)</p>
<p><strong>all</strong> = [“inject_into_urllib3”, “extract_from_urllib3”]</p>
<section id="sni-always-works">
<h1>SNI always works.<a class="headerlink" href="#sni-always-works" title="Link to this heading"></a></h1>
<p>HAS_SNI = True</p>
</section>
<section id="map-from-urllib3-to-pyopenssl-compatible-parameter-values">
<h1>Map from urllib3 to PyOpenSSL compatible parameter-values.<a class="headerlink" href="#map-from-urllib3-to-pyopenssl-compatible-parameter-values" title="Link to this heading"></a></h1>
<p>_openssl_versions = {
util.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,
PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,
ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
}</p>
<p>if hasattr(ssl, “PROTOCOL_SSLv3”) and hasattr(OpenSSL.SSL, “SSLv3_METHOD”):
_openssl_versions[ssl.PROTOCOL_SSLv3] = OpenSSL.SSL.SSLv3_METHOD</p>
<p>if hasattr(ssl, “PROTOCOL_TLSv1_1”) and hasattr(OpenSSL.SSL, “TLSv1_1_METHOD”):
_openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD</p>
<p>if hasattr(ssl, “PROTOCOL_TLSv1_2”) and hasattr(OpenSSL.SSL, “TLSv1_2_METHOD”):
_openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD</p>
<p>_stdlib_to_openssl_verify = {
ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER
+ OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
}
_openssl_to_stdlib_verify = dict((v, k) for k, v in _stdlib_to_openssl_verify.items())</p>
</section>
<section id="openssl-will-only-write-16k-at-a-time">
<h1>OpenSSL will only write 16K at a time<a class="headerlink" href="#openssl-will-only-write-16k-at-a-time" title="Link to this heading"></a></h1>
<p>SSL_WRITE_BLOCKSIZE = 16384</p>
<p>orig_util_HAS_SNI = util.HAS_SNI
orig_util_SSLContext = util.ssl_.SSLContext</p>
<p>log = logging.getLogger(<strong>name</strong>)</p>
<p>def inject_into_urllib3():
“Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>_validate_dependencies_met()

util.SSLContext = PyOpenSSLContext
util.ssl_.SSLContext = PyOpenSSLContext
util.HAS_SNI = HAS_SNI
util.ssl_.HAS_SNI = HAS_SNI
util.IS_PYOPENSSL = True
util.ssl_.IS_PYOPENSSL = True
</pre></div>
</div>
<p>def extract_from_urllib3():
“Undo monkey-patching by :func:<code class="docutils literal notranslate"><span class="pre">inject_into_urllib3</span></code>.”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>util.SSLContext = orig_util_SSLContext
util.ssl_.SSLContext = orig_util_SSLContext
util.HAS_SNI = orig_util_HAS_SNI
util.ssl_.HAS_SNI = orig_util_HAS_SNI
util.IS_PYOPENSSL = False
util.ssl_.IS_PYOPENSSL = False
</pre></div>
</div>
<p>def _validate_dependencies_met():
“””
Verifies that PyOpenSSL’s package-level dependencies have been met.
Throws <code class="docutils literal notranslate"><span class="pre">ImportError</span></code> if they are not met.
“””
# Method added in <code class="docutils literal notranslate"><span class="pre">cryptography==1.1</span></code>; not available in older versions
from cryptography.x509.extensions import Extensions</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if getattr(Extensions, &quot;get_extension_for_class&quot;, None) is None:
    raise ImportError(
        &quot;&#39;cryptography&#39; module missing required functionality.  &quot;
        &quot;Try upgrading to v1.3.4 or newer.&quot;
    )

# pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
# attribute is only present on those versions.
from OpenSSL.crypto import X509

x509 = X509()
if getattr(x509, &quot;_x509&quot;, None) is None:
    raise ImportError(
        &quot;&#39;pyOpenSSL&#39; module missing required functionality. &quot;
        &quot;Try upgrading to v0.14 or newer.&quot;
    )
</pre></div>
</div>
<p>def _dnsname_to_stdlib(name):
“””
Converts a dNSName SubjectAlternativeName field to the form used by the
standard library on the given Python version.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Cryptography produces a dNSName as a unicode string that was idna-decoded
from ASCII bytes. We need to idna-encode that string to get it back, and
then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).

If the name cannot be idna-encoded then we return None signalling that
the name given should be skipped.
&quot;&quot;&quot;

def idna_encode(name):
    &quot;&quot;&quot;
    Borrowed wholesale from the Python Cryptography Project. It turns out
    that we can&#39;t just safely call `idna.encode`: it can explode for
    wildcard names. This avoids that problem.
    &quot;&quot;&quot;
    from pip._vendor import idna

    try:
        for prefix in [u&quot;*.&quot;, u&quot;.&quot;]:
            if name.startswith(prefix):
                name = name[len(prefix) :]
                return prefix.encode(&quot;ascii&quot;) + idna.encode(name)
        return idna.encode(name)
    except idna.core.IDNAError:
        return None

# Don&#39;t send IPv6 addresses through the IDNA encoder.
if &quot;:&quot; in name:
    return name

name = idna_encode(name)
if name is None:
    return None
elif sys.version_info &gt;= (3, 0):
    name = name.decode(&quot;utf-8&quot;)
return name
</pre></div>
</div>
<p>def get_subj_alt_name(peer_cert):
“””
Given an PyOpenSSL certificate, provides all the subject alternative names.
“””
# Pass the cert to cryptography, which has much better APIs for this.
if hasattr(peer_cert, “to_cryptography”):
cert = peer_cert.to_cryptography()
else:
der = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, peer_cert)
cert = x509.load_der_x509_certificate(der, openssl_backend)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># We want to find the SAN extension. Ask Cryptography to locate it (it&#39;s
# faster than looping in Python)
try:
    ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value
except x509.ExtensionNotFound:
    # No such extension, return the empty list.
    return []
except (
    x509.DuplicateExtension,
    UnsupportedExtension,
    x509.UnsupportedGeneralNameType,
    UnicodeError,
) as e:
    # A problem has been found with the quality of the certificate. Assume
    # no SAN field is present.
    log.warning(
        &quot;A problem was encountered with the certificate that prevented &quot;
        &quot;urllib3 from finding the SubjectAlternativeName field. This can &quot;
        &quot;affect certificate validation. The error was %s&quot;,
        e,
    )
    return []

# We want to return dNSName and iPAddress fields. We need to cast the IPs
# back to strings because the match_hostname function wants them as
# strings.
# Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
# decoded. This is pretty frustrating, but that&#39;s what the standard library
# does with certificates, and so we need to attempt to do the same.
# We also want to skip over names which cannot be idna encoded.
names = [
    (&quot;DNS&quot;, name)
    for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))
    if name is not None
]
names.extend(
    (&quot;IP Address&quot;, str(name)) for name in ext.get_values_for_type(x509.IPAddress)
)

return names
</pre></div>
</div>
<p>class WrappedSocket(object):
“””API-compatibility wrapper for Python OpenSSL’s Connection-class.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
collector of pypy.
&quot;&quot;&quot;

def __init__(self, connection, socket, suppress_ragged_eofs=True):
    self.connection = connection
    self.socket = socket
    self.suppress_ragged_eofs = suppress_ragged_eofs
    self._makefile_refs = 0
    self._closed = False

def fileno(self):
    return self.socket.fileno()

# Copy-pasted from Python 3.5 source code
def _decref_socketios(self):
    if self._makefile_refs &gt; 0:
        self._makefile_refs -= 1
    if self._closed:
        self.close()

def recv(self, *args, **kwargs):
    try:
        data = self.connection.recv(*args, **kwargs)
    except OpenSSL.SSL.SysCallError as e:
        if self.suppress_ragged_eofs and e.args == (-1, &quot;Unexpected EOF&quot;):
            return b&quot;&quot;
        else:
            raise SocketError(str(e))
    except OpenSSL.SSL.ZeroReturnError:
        if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
            return b&quot;&quot;
        else:
            raise
    except OpenSSL.SSL.WantReadError:
        if not util.wait_for_read(self.socket, self.socket.gettimeout()):
            raise timeout(&quot;The read operation timed out&quot;)
        else:
            return self.recv(*args, **kwargs)

    # TLS 1.3 post-handshake authentication
    except OpenSSL.SSL.Error as e:
        raise ssl.SSLError(&quot;read error: %r&quot; % e)
    else:
        return data

def recv_into(self, *args, **kwargs):
    try:
        return self.connection.recv_into(*args, **kwargs)
    except OpenSSL.SSL.SysCallError as e:
        if self.suppress_ragged_eofs and e.args == (-1, &quot;Unexpected EOF&quot;):
            return 0
        else:
            raise SocketError(str(e))
    except OpenSSL.SSL.ZeroReturnError:
        if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
            return 0
        else:
            raise
    except OpenSSL.SSL.WantReadError:
        if not util.wait_for_read(self.socket, self.socket.gettimeout()):
            raise timeout(&quot;The read operation timed out&quot;)
        else:
            return self.recv_into(*args, **kwargs)

    # TLS 1.3 post-handshake authentication
    except OpenSSL.SSL.Error as e:
        raise ssl.SSLError(&quot;read error: %r&quot; % e)

def settimeout(self, timeout):
    return self.socket.settimeout(timeout)

def _send_until_done(self, data):
    while True:
        try:
            return self.connection.send(data)
        except OpenSSL.SSL.WantWriteError:
            if not util.wait_for_write(self.socket, self.socket.gettimeout()):
                raise timeout()
            continue
        except OpenSSL.SSL.SysCallError as e:
            raise SocketError(str(e))

def sendall(self, data):
    total_sent = 0
    while total_sent &lt; len(data):
        sent = self._send_until_done(
            data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE]
        )
        total_sent += sent

def shutdown(self):
    # FIXME rethrow compatible exceptions should we ever use this
    self.connection.shutdown()

def close(self):
    if self._makefile_refs &lt; 1:
        try:
            self._closed = True
            return self.connection.close()
        except OpenSSL.SSL.Error:
            return
    else:
        self._makefile_refs -= 1

def getpeercert(self, binary_form=False):
    x509 = self.connection.get_peer_certificate()

    if not x509:
        return x509

    if binary_form:
        return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, x509)

    return {
        &quot;subject&quot;: (((&quot;commonName&quot;, x509.get_subject().CN),),),
        &quot;subjectAltName&quot;: get_subj_alt_name(x509),
    }

def version(self):
    return self.connection.get_protocol_version_name()

def _reuse(self):
    self._makefile_refs += 1

def _drop(self):
    if self._makefile_refs &lt; 1:
        self.close()
    else:
        self._makefile_refs -= 1
</pre></div>
</div>
<p>if _fileobject:  # Platform-specific: Python 2</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def makefile(self, mode, bufsize=-1):
    self._makefile_refs += 1
    return _fileobject(self, mode, bufsize, close=True)
</pre></div>
</div>
<p>else:  # Platform-specific: Python 3
makefile = backport_makefile</p>
<p>WrappedSocket.makefile = makefile</p>
<p>class PyOpenSSLContext(object):
“””
I am a wrapper class for the PyOpenSSL <code class="docutils literal notranslate"><span class="pre">Context</span></code> object. I am responsible
for translating the interface of the standard library <code class="docutils literal notranslate"><span class="pre">SSLContext</span></code> object
to calls into PyOpenSSL.
“””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, protocol):
    self.protocol = _openssl_versions[protocol]
    self._ctx = OpenSSL.SSL.Context(self.protocol)
    self._options = 0
    self.check_hostname = False

@property
def options(self):
    return self._options

@options.setter
def options(self, value):
    self._options = value
    self._ctx.set_options(value)

@property
def verify_mode(self):
    return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]

@verify_mode.setter
def verify_mode(self, value):
    self._ctx.set_verify(_stdlib_to_openssl_verify[value], _verify_callback)

def set_default_verify_paths(self):
    self._ctx.set_default_verify_paths()

def set_ciphers(self, ciphers):
    if isinstance(ciphers, six.text_type):
        ciphers = ciphers.encode(&quot;utf-8&quot;)
    self._ctx.set_cipher_list(ciphers)

def load_verify_locations(self, cafile=None, capath=None, cadata=None):
    if cafile is not None:
        cafile = cafile.encode(&quot;utf-8&quot;)
    if capath is not None:
        capath = capath.encode(&quot;utf-8&quot;)
    try:
        self._ctx.load_verify_locations(cafile, capath)
        if cadata is not None:
            self._ctx.load_verify_locations(BytesIO(cadata))
    except OpenSSL.SSL.Error as e:
        raise ssl.SSLError(&quot;unable to load trusted certificates: %r&quot; % e)

def load_cert_chain(self, certfile, keyfile=None, password=None):
    self._ctx.use_certificate_chain_file(certfile)
    if password is not None:
        if not isinstance(password, six.binary_type):
            password = password.encode(&quot;utf-8&quot;)
        self._ctx.set_passwd_cb(lambda *_: password)
    self._ctx.use_privatekey_file(keyfile or certfile)

def set_alpn_protocols(self, protocols):
    protocols = [six.ensure_binary(p) for p in protocols]
    return self._ctx.set_alpn_protos(protocols)

def wrap_socket(
    self,
    sock,
    server_side=False,
    do_handshake_on_connect=True,
    suppress_ragged_eofs=True,
    server_hostname=None,
):
    cnx = OpenSSL.SSL.Connection(self._ctx, sock)

    if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
        server_hostname = server_hostname.encode(&quot;utf-8&quot;)

    if server_hostname is not None:
        cnx.set_tlsext_host_name(server_hostname)

    cnx.set_connect_state()

    while True:
        try:
            cnx.do_handshake()
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(sock, sock.gettimeout()):
                raise timeout(&quot;select timed out&quot;)
            continue
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError(&quot;bad handshake: %r&quot; % e)
        break

    return WrappedSocket(cnx, sock)
</pre></div>
</div>
<p>def _verify_callback(cnx, x509, err_no, err_depth, return_code):
return err_no == 0</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>