

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/network/lazy_wheel.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Lazy ZIP over HTTP”””</p>
<p>from <strong>future</strong> import annotations</p>
<p><strong>all</strong> = [“HTTPRangeRequestUnsupported”, “dist_from_wheel_url”]</p>
<p>from bisect import bisect_left, bisect_right
from collections.abc import Generator
from contextlib import contextmanager
from tempfile import NamedTemporaryFile
from typing import Any
from zipfile import BadZipFile, ZipFile</p>
<p>from pip._vendor.packaging.utils import NormalizedName
from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response</p>
<p>from pip._internal.metadata import BaseDistribution, MemoryWheel, get_wheel_distribution
from pip._internal.network.session import PipSession
from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks</p>
<p>class HTTPRangeRequestUnsupported(Exception):
pass</p>
<p>def dist_from_wheel_url(
name: NormalizedName, url: str, session: PipSession
) -&gt; BaseDistribution:
“””Return a distribution object from the given wheel URL.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This uses HTTP range requests to only fetch the portion of the wheel
containing metadata, just enough for the object to be constructed.
If such requests are not supported, HTTPRangeRequestUnsupported
is raised.
&quot;&quot;&quot;
with LazyZipOverHTTP(url, session) as zf:
    # For read-only ZIP files, ZipFile only needs methods read,
    # seek, seekable and tell, not the whole IO protocol.
    wheel = MemoryWheel(zf.name, zf)  # type: ignore
    # After context manager exit, wheel.name
    # is an invalid file by intention.
    return get_wheel_distribution(wheel, name)
</pre></div>
</div>
<p>class LazyZipOverHTTP:
“””File-like object mapped to a ZIP file over HTTP.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This uses HTTP range requests to lazily fetch the file&#39;s content,
which is supposed to be fed to ZipFile.  If such requests are not
supported by the server, raise HTTPRangeRequestUnsupported
during initialization.
&quot;&quot;&quot;

def __init__(
    self, url: str, session: PipSession, chunk_size: int = CONTENT_CHUNK_SIZE
) -&gt; None:
    head = session.head(url, headers=HEADERS)
    raise_for_status(head)
    assert head.status_code == 200
    self._session, self._url, self._chunk_size = session, url, chunk_size
    self._length = int(head.headers[&quot;Content-Length&quot;])
    self._file = NamedTemporaryFile()
    self.truncate(self._length)
    self._left: list[int] = []
    self._right: list[int] = []
    if &quot;bytes&quot; not in head.headers.get(&quot;Accept-Ranges&quot;, &quot;none&quot;):
        raise HTTPRangeRequestUnsupported(&quot;range request is not supported&quot;)
    self._check_zip()

@property
def mode(self) -&gt; str:
    &quot;&quot;&quot;Opening mode, which is always rb.&quot;&quot;&quot;
    return &quot;rb&quot;

@property
def name(self) -&gt; str:
    &quot;&quot;&quot;Path to the underlying file.&quot;&quot;&quot;
    return self._file.name

def seekable(self) -&gt; bool:
    &quot;&quot;&quot;Return whether random access is supported, which is True.&quot;&quot;&quot;
    return True

def close(self) -&gt; None:
    &quot;&quot;&quot;Close the file.&quot;&quot;&quot;
    self._file.close()

@property
def closed(self) -&gt; bool:
    &quot;&quot;&quot;Whether the file is closed.&quot;&quot;&quot;
    return self._file.closed

def read(self, size: int = -1) -&gt; bytes:
    &quot;&quot;&quot;Read up to size bytes from the object and return them.

    As a convenience, if size is unspecified or -1,
    all bytes until EOF are returned.  Fewer than
    size bytes may be returned if EOF is reached.
    &quot;&quot;&quot;
    download_size = max(size, self._chunk_size)
    start, length = self.tell(), self._length
    stop = length if size &lt; 0 else min(start + download_size, length)
    start = max(0, stop - download_size)
    self._download(start, stop - 1)
    return self._file.read(size)

def readable(self) -&gt; bool:
    &quot;&quot;&quot;Return whether the file is readable, which is True.&quot;&quot;&quot;
    return True

def seek(self, offset: int, whence: int = 0) -&gt; int:
    &quot;&quot;&quot;Change stream position and return the new absolute position.

    Seek to offset relative position indicated by whence:
    * 0: Start of stream (the default).  pos should be &gt;= 0;
    * 1: Current position - pos may be negative;
    * 2: End of stream - pos usually negative.
    &quot;&quot;&quot;
    return self._file.seek(offset, whence)

def tell(self) -&gt; int:
    &quot;&quot;&quot;Return the current position.&quot;&quot;&quot;
    return self._file.tell()

def truncate(self, size: int | None = None) -&gt; int:
    &quot;&quot;&quot;Resize the stream to the given size in bytes.

    If size is unspecified resize to the current position.
    The current stream position isn&#39;t changed.

    Return the new file size.
    &quot;&quot;&quot;
    return self._file.truncate(size)

def writable(self) -&gt; bool:
    &quot;&quot;&quot;Return False.&quot;&quot;&quot;
    return False

def __enter__(self) -&gt; LazyZipOverHTTP:
    self._file.__enter__()
    return self

def __exit__(self, *exc: Any) -&gt; None:
    self._file.__exit__(*exc)

@contextmanager
def _stay(self) -&gt; Generator[None, None, None]:
    &quot;&quot;&quot;Return a context manager keeping the position.

    At the end of the block, seek back to original position.
    &quot;&quot;&quot;
    pos = self.tell()
    try:
        yield
    finally:
        self.seek(pos)

def _check_zip(self) -&gt; None:
    &quot;&quot;&quot;Check and download until the file is a valid ZIP.&quot;&quot;&quot;
    end = self._length - 1
    for start in reversed(range(0, end, self._chunk_size)):
        self._download(start, end)
        with self._stay():
            try:
                # For read-only ZIP files, ZipFile only needs
                # methods read, seek, seekable and tell.
                ZipFile(self)
            except BadZipFile:
                pass
            else:
                break

def _stream_response(
    self, start: int, end: int, base_headers: dict[str, str] = HEADERS
) -&gt; Response:
    &quot;&quot;&quot;Return HTTP response to a range request from start to end.&quot;&quot;&quot;
    headers = base_headers.copy()
    headers[&quot;Range&quot;] = f&quot;bytes={start}-{end}&quot;
    # TODO: Get range requests to be correctly cached
    headers[&quot;Cache-Control&quot;] = &quot;no-cache&quot;
    return self._session.get(self._url, headers=headers, stream=True)

def _merge(
    self, start: int, end: int, left: int, right: int
) -&gt; Generator[tuple[int, int], None, None]:
    &quot;&quot;&quot;Return a generator of intervals to be fetched.

    Args:
        start (int): Start of needed interval
        end (int): End of needed interval
        left (int): Index of first overlapping downloaded data
        right (int): Index after last overlapping downloaded data
    &quot;&quot;&quot;
    lslice, rslice = self._left[left:right], self._right[left:right]
    i = start = min([start] + lslice[:1])
    end = max([end] + rslice[-1:])
    for j, k in zip(lslice, rslice):
        if j &gt; i:
            yield i, j - 1
        i = k + 1
    if i &lt;= end:
        yield i, end
    self._left[left:right], self._right[left:right] = [start], [end]

def _download(self, start: int, end: int) -&gt; None:
    &quot;&quot;&quot;Download bytes from start to end inclusively.&quot;&quot;&quot;
    with self._stay():
        left = bisect_left(self._right, start)
        right = bisect_right(self._left, end)
        for start, end in self._merge(start, end, left, right):
            response = self._stream_response(start, end)
            response.raise_for_status()
            self.seek(start)
            for chunk in response_chunks(response, self._chunk_size):
                self._file.write(chunk)
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>