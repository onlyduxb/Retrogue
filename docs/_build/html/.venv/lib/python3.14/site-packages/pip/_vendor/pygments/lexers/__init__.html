

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/pygments/lexers/__init__.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
pygments.lexers
~~~~~~~~~~~~~~~</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Pygments lexers.

:copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
:license: BSD, see LICENSE for details.
</pre></div>
</div>
<p>“””</p>
<p>import re
import sys
import types
import fnmatch
from os.path import basename</p>
<p>from pip._vendor.pygments.lexers._mapping import LEXERS
from pip._vendor.pygments.modeline import get_filetype_from_buffer
from pip._vendor.pygments.plugin import find_plugin_lexers
from pip._vendor.pygments.util import ClassNotFound, guess_decode</p>
<p>COMPAT = {
‘Python3Lexer’: ‘PythonLexer’,
‘Python3TracebackLexer’: ‘PythonTracebackLexer’,
‘LeanLexer’: ‘Lean3Lexer’,
}</p>
<p><strong>all</strong> = [‘get_lexer_by_name’, ‘get_lexer_for_filename’, ‘find_lexer_class’,
‘guess_lexer’, ‘load_lexer_from_file’] + list(LEXERS) + list(COMPAT)</p>
<p>_lexer_cache = {}
_pattern_cache = {}</p>
<p>def _fn_matches(fn, glob):
“””Return whether the supplied file name fn matches pattern filename.”””
if glob not in _pattern_cache:
pattern = _pattern_cache[glob] = re.compile(fnmatch.translate(glob))
return pattern.match(fn)
return _pattern_cache[glob].match(fn)</p>
<p>def _load_lexers(module_name):
“””Load a lexer (and all others in the module too).”””
mod = <strong>import</strong>(module_name, None, None, [’<strong>all</strong>’])
for lexer_name in mod.<strong>all</strong>:
cls = getattr(mod, lexer_name)
_lexer_cache[cls.name] = cls</p>
<p>def get_all_lexers(plugins=True):
“””Return a generator of tuples in the form <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">aliases,</span>&#160;&#160;&#160;&#160; <span class="pre">filenames,</span> <span class="pre">mimetypes)</span></code> of all know lexers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>If *plugins* is true (the default), plugin lexers supplied by entrypoints
are also returned.  Otherwise, only builtin ones are considered.
&quot;&quot;&quot;
for item in LEXERS.values():
    yield item[1:]
if plugins:
    for lexer in find_plugin_lexers():
        yield lexer.name, lexer.aliases, lexer.filenames, lexer.mimetypes
</pre></div>
</div>
<p>def find_lexer_class(name):
“””
Return the <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> subclass that with the <em>name</em> attribute as given by
the <em>name</em> argument.
“””
if name in _lexer_cache:
return _lexer_cache[name]
# lookup builtin lexers
for module_name, lname, aliases, _, _ in LEXERS.values():
if name == lname:
_load_lexers(module_name)
return _lexer_cache[name]
# continue with lexers from setuptools entrypoints
for cls in find_plugin_lexers():
if cls.name == name:
return cls</p>
<p>def find_lexer_class_by_name(_alias):
“””
Return the <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> subclass that has <code class="docutils literal notranslate"><span class="pre">alias</span></code> in its aliases list, without
instantiating it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Like `get_lexer_by_name`, but does not instantiate the class.

Will raise :exc:`pygments.util.ClassNotFound` if no lexer with that alias is
found.

.. versionadded:: 2.2
&quot;&quot;&quot;
if not _alias:
    raise ClassNotFound(f&#39;no lexer for alias {_alias!r} found&#39;)
# lookup builtin lexers
for module_name, name, aliases, _, _ in LEXERS.values():
    if _alias.lower() in aliases:
        if name not in _lexer_cache:
            _load_lexers(module_name)
        return _lexer_cache[name]
# continue with lexers from setuptools entrypoints
for cls in find_plugin_lexers():
    if _alias.lower() in cls.aliases:
        return cls
raise ClassNotFound(f&#39;no lexer for alias {_alias!r} found&#39;)
</pre></div>
</div>
<p>def get_lexer_by_name(_alias, **options):
“””
Return an instance of a <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> subclass that has <code class="docutils literal notranslate"><span class="pre">alias</span></code> in its
aliases list. The lexer is given the <code class="docutils literal notranslate"><span class="pre">options</span></code> at its
instantiation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Will raise :exc:`pygments.util.ClassNotFound` if no lexer with that alias is
found.
&quot;&quot;&quot;
if not _alias:
    raise ClassNotFound(f&#39;no lexer for alias {_alias!r} found&#39;)

# lookup builtin lexers
for module_name, name, aliases, _, _ in LEXERS.values():
    if _alias.lower() in aliases:
        if name not in _lexer_cache:
            _load_lexers(module_name)
        return _lexer_cache[name](**options)
# continue with lexers from setuptools entrypoints
for cls in find_plugin_lexers():
    if _alias.lower() in cls.aliases:
        return cls(**options)
raise ClassNotFound(f&#39;no lexer for alias {_alias!r} found&#39;)
</pre></div>
</div>
<p>def load_lexer_from_file(filename, lexername=”CustomLexer”, **options):
“””Load a lexer from a file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This method expects a file located relative to the current working
directory, which contains a Lexer class. By default, it expects the
Lexer to be name CustomLexer; you can specify your own class name
as the second argument to this function.

Users should be very careful with the input, because this method
is equivalent to running eval on the input file.

Raises ClassNotFound if there are any problems importing the Lexer.

.. versionadded:: 2.2
&quot;&quot;&quot;
try:
    # This empty dict will contain the namespace for the exec&#39;d file
    custom_namespace = {}
    with open(filename, &#39;rb&#39;) as f:
        exec(f.read(), custom_namespace)
    # Retrieve the class `lexername` from that namespace
    if lexername not in custom_namespace:
        raise ClassNotFound(f&#39;no valid {lexername} class found in {filename}&#39;)
    lexer_class = custom_namespace[lexername]
    # And finally instantiate it with the options
    return lexer_class(**options)
except OSError as err:
    raise ClassNotFound(f&#39;cannot read {filename}: {err}&#39;)
except ClassNotFound:
    raise
except Exception as err:
    raise ClassNotFound(f&#39;error when loading custom lexer: {err}&#39;)
</pre></div>
</div>
<p>def find_lexer_class_for_filename(_fn, code=None):
“””Get a lexer for a filename.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>If multiple lexers match the filename pattern, use ``analyse_text()`` to
figure out which one is more appropriate.

Returns None if not found.
&quot;&quot;&quot;
matches = []
fn = basename(_fn)
for modname, name, _, filenames, _ in LEXERS.values():
    for filename in filenames:
        if _fn_matches(fn, filename):
            if name not in _lexer_cache:
                _load_lexers(modname)
            matches.append((_lexer_cache[name], filename))
for cls in find_plugin_lexers():
    for filename in cls.filenames:
        if _fn_matches(fn, filename):
            matches.append((cls, filename))

if isinstance(code, bytes):
    # decode it, since all analyse_text functions expect unicode
    code = guess_decode(code)

def get_rating(info):
    cls, filename = info
    # explicit patterns get a bonus
    bonus = &#39;*&#39; not in filename and 0.5 or 0
    # The class _always_ defines analyse_text because it&#39;s included in
    # the Lexer class.  The default implementation returns None which
    # gets turned into 0.0.  Run scripts/detect_missing_analyse_text.py
    # to find lexers which need it overridden.
    if code:
        return cls.analyse_text(code) + bonus, cls.__name__
    return cls.priority + bonus, cls.__name__

if matches:
    matches.sort(key=get_rating)
    # print &quot;Possible lexers, after sort:&quot;, matches
    return matches[-1][0]
</pre></div>
</div>
<p>def get_lexer_for_filename(_fn, code=None, **options):
“””Get a lexer for a filename.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Return a `Lexer` subclass instance that has a filename pattern
matching `fn`. The lexer is given the `options` at its
instantiation.

Raise :exc:`pygments.util.ClassNotFound` if no lexer for that filename
is found.

If multiple lexers match the filename pattern, use their ``analyse_text()``
methods to figure out which one is more appropriate.
&quot;&quot;&quot;
res = find_lexer_class_for_filename(_fn, code)
if not res:
    raise ClassNotFound(f&#39;no lexer for filename {_fn!r} found&#39;)
return res(**options)
</pre></div>
</div>
<p>def get_lexer_for_mimetype(_mime, **options):
“””
Return a <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> subclass instance that has <code class="docutils literal notranslate"><span class="pre">mime</span></code> in its mimetype
list. The lexer is given the <code class="docutils literal notranslate"><span class="pre">options</span></code> at its instantiation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Will raise :exc:`pygments.util.ClassNotFound` if not lexer for that mimetype
is found.
&quot;&quot;&quot;
for modname, name, _, _, mimetypes in LEXERS.values():
    if _mime in mimetypes:
        if name not in _lexer_cache:
            _load_lexers(modname)
        return _lexer_cache[name](**options)
for cls in find_plugin_lexers():
    if _mime in cls.mimetypes:
        return cls(**options)
raise ClassNotFound(f&#39;no lexer for mimetype {_mime!r} found&#39;)
</pre></div>
</div>
<p>def _iter_lexerclasses(plugins=True):
“””Return an iterator over all lexer classes.”””
for key in sorted(LEXERS):
module_name, name = LEXERS[key][:2]
if name not in _lexer_cache:
_load_lexers(module_name)
yield _lexer_cache[name]
if plugins:
yield from find_plugin_lexers()</p>
<p>def guess_lexer_for_filename(_fn, _text, **options):
“””
As :func:<code class="docutils literal notranslate"><span class="pre">guess_lexer()</span></code>, but only lexers which have a pattern in <code class="docutils literal notranslate"><span class="pre">filenames</span></code>
or <code class="docutils literal notranslate"><span class="pre">alias_filenames</span></code> that matches <code class="docutils literal notranslate"><span class="pre">filename</span></code> are taken into consideration.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:exc:`pygments.util.ClassNotFound` is raised if no lexer thinks it can
handle the content.
&quot;&quot;&quot;
fn = basename(_fn)
primary = {}
matching_lexers = set()
for lexer in _iter_lexerclasses():
    for filename in lexer.filenames:
        if _fn_matches(fn, filename):
            matching_lexers.add(lexer)
            primary[lexer] = True
    for filename in lexer.alias_filenames:
        if _fn_matches(fn, filename):
            matching_lexers.add(lexer)
            primary[lexer] = False
if not matching_lexers:
    raise ClassNotFound(f&#39;no lexer for filename {fn!r} found&#39;)
if len(matching_lexers) == 1:
    return matching_lexers.pop()(**options)
result = []
for lexer in matching_lexers:
    rv = lexer.analyse_text(_text)
    if rv == 1.0:
        return lexer(**options)
    result.append((rv, lexer))

def type_sort(t):
    # sort by:
    # - analyse score
    # - is primary filename pattern?
    # - priority
    # - last resort: class name
    return (t[0], primary[t[1]], t[1].priority, t[1].__name__)
result.sort(key=type_sort)

return result[-1][1](**options)
</pre></div>
</div>
<p>def guess_lexer(_text, **options):
“””
Return a <code class="docutils literal notranslate"><span class="pre">Lexer</span></code> subclass instance that’s guessed from the text in
<code class="docutils literal notranslate"><span class="pre">text</span></code>. For that, the :meth:<code class="docutils literal notranslate"><span class="pre">.analyse_text()</span></code> method of every known lexer
class is called with the text as argument, and the lexer which returned the
highest value will be instantiated and returned.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:exc:`pygments.util.ClassNotFound` is raised if no lexer thinks it can
handle the content.
&quot;&quot;&quot;

if not isinstance(_text, str):
    inencoding = options.get(&#39;inencoding&#39;, options.get(&#39;encoding&#39;))
    if inencoding:
        _text = _text.decode(inencoding or &#39;utf8&#39;)
    else:
        _text, _ = guess_decode(_text)

# try to get a vim modeline first
ft = get_filetype_from_buffer(_text)

if ft is not None:
    try:
        return get_lexer_by_name(ft, **options)
    except ClassNotFound:
        pass

best_lexer = [0.0, None]
for lexer in _iter_lexerclasses():
    rv = lexer.analyse_text(_text)
    if rv == 1.0:
        return lexer(**options)
    if rv &gt; best_lexer[0]:
        best_lexer[:] = (rv, lexer)
if not best_lexer[0] or best_lexer[1] is None:
    raise ClassNotFound(&#39;no lexer matching the text found&#39;)
return best_lexer[1](**options)
</pre></div>
</div>
<p>class _automodule(types.ModuleType):
“””Automatically import lexers.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __getattr__(self, name):
    info = LEXERS.get(name)
    if info:
        _load_lexers(info[0])
        cls = _lexer_cache[info[1]]
        setattr(self, name, cls)
        return cls
    if name in COMPAT:
        return getattr(self, COMPAT[name])
    raise AttributeError(name)
</pre></div>
</div>
<p>oldmod = sys.modules[<strong>name</strong>]
newmod = _automodule(<strong>name</strong>)
newmod.<strong>dict</strong>.update(oldmod.<strong>dict</strong>)
sys.modules[<strong>name</strong>] = newmod
del newmod.newmod, newmod.oldmod, newmod.sys, newmod.types</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>