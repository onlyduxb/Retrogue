

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>os.PathLike not a generic type until Python 3.9, so sticking with str &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><code class="docutils literal notranslate"><span class="pre">os.PathLike</span></code> not a generic type until Python 3.9, so sticking with <code class="docutils literal notranslate"><span class="pre">str</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/_manylinux.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import collections
import contextlib
import functools
import os
import re
import sys
import warnings
from typing import Generator, Iterator, NamedTuple, Sequence</p>
<p>from ._elffile import EIClass, EIData, ELFFile, EMachine</p>
<p>EF_ARM_ABIMASK = 0xFF000000
EF_ARM_ABI_VER5 = 0x05000000
EF_ARM_ABI_FLOAT_HARD = 0x00000400</p>
<section id="os-pathlike-not-a-generic-type-until-python-3-9-so-sticking-with-str">
<h1><code class="docutils literal notranslate"><span class="pre">os.PathLike</span></code> not a generic type until Python 3.9, so sticking with <code class="docutils literal notranslate"><span class="pre">str</span></code><a class="headerlink" href="#os-pathlike-not-a-generic-type-until-python-3-9-so-sticking-with-str" title="Link to this heading"></a></h1>
</section>
<section id="as-the-type-for-path-until-then">
<h1>as the type for <code class="docutils literal notranslate"><span class="pre">path</span></code> until then.<a class="headerlink" href="#as-the-type-for-path-until-then" title="Link to this heading"></a></h1>
<p>&#64;contextlib.contextmanager
def _parse_elf(path: str) -&gt; Generator[ELFFile | None, None, None]:
try:
with open(path, “rb”) as f:
yield ELFFile(f)
except (OSError, TypeError, ValueError):
yield None</p>
<p>def _is_linux_armhf(executable: str) -&gt; bool:
# hard-float ABI can be detected from the ELF header of the running
# process
# https://static.docs.arm.com/ihi0044/g/aaelf32.pdf
with _parse_elf(executable) as f:
return (
f is not None
and f.capacity == EIClass.C32
and f.encoding == EIData.Lsb
and f.machine == EMachine.Arm
and f.flags &amp; EF_ARM_ABIMASK == EF_ARM_ABI_VER5
and f.flags &amp; EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD
)</p>
<p>def _is_linux_i686(executable: str) -&gt; bool:
with _parse_elf(executable) as f:
return (
f is not None
and f.capacity == EIClass.C32
and f.encoding == EIData.Lsb
and f.machine == EMachine.I386
)</p>
<p>def _have_compatible_abi(executable: str, archs: Sequence[str]) -&gt; bool:
if “armv7l” in archs:
return _is_linux_armhf(executable)
if “i686” in archs:
return _is_linux_i686(executable)
allowed_archs = {
“x86_64”,
“aarch64”,
“ppc64”,
“ppc64le”,
“s390x”,
“loongarch64”,
“riscv64”,
}
return any(arch in allowed_archs for arch in archs)</p>
</section>
<section id="if-glibc-ever-changes-its-major-version-we-need-to-know-what-the-last">
<h1>If glibc ever changes its major version, we need to know what the last<a class="headerlink" href="#if-glibc-ever-changes-its-major-version-we-need-to-know-what-the-last" title="Link to this heading"></a></h1>
</section>
<section id="minor-version-was-so-we-can-build-the-complete-list-of-all-versions">
<h1>minor version was, so we can build the complete list of all versions.<a class="headerlink" href="#minor-version-was-so-we-can-build-the-complete-list-of-all-versions" title="Link to this heading"></a></h1>
</section>
<section id="for-now-guess-what-the-highest-minor-version-might-be-assume-it-will">
<h1>For now, guess what the highest minor version might be, assume it will<a class="headerlink" href="#for-now-guess-what-the-highest-minor-version-might-be-assume-it-will" title="Link to this heading"></a></h1>
</section>
<section id="be-50-for-testing-once-this-actually-happens-update-the-dictionary">
<h1>be 50 for testing. Once this actually happens, update the dictionary<a class="headerlink" href="#be-50-for-testing-once-this-actually-happens-update-the-dictionary" title="Link to this heading"></a></h1>
</section>
<section id="with-the-actual-value">
<h1>with the actual value.<a class="headerlink" href="#with-the-actual-value" title="Link to this heading"></a></h1>
<p>_LAST_GLIBC_MINOR: dict[int, int] = collections.defaultdict(lambda: 50)</p>
<p>class _GLibCVersion(NamedTuple):
major: int
minor: int</p>
<p>def _glibc_version_string_confstr() -&gt; str | None:
“””
Primary implementation of glibc_version_string using os.confstr.
“””
# os.confstr is quite a bit faster than ctypes.DLL. It’s also less likely
# to be broken or missing. This strategy is used in the standard library
# platform module.
# https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183
try:
# Should be a string like “glibc 2.17”.
version_string: str | None = os.confstr(“CS_GNU_LIBC_VERSION”)
assert version_string is not None
_, version = version_string.rsplit()
except (AssertionError, AttributeError, OSError, ValueError):
# os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)…
return None
return version</p>
<p>def _glibc_version_string_ctypes() -&gt; str | None:
“””
Fallback implementation of glibc_version_string using ctypes.
“””
try:
import ctypes
except ImportError:
return None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen
# manpage says, &quot;If filename is NULL, then the returned handle is for the
# main program&quot;. This way we can let the linker do the work to figure out
# which libc our process is actually using.
#
# We must also handle the special case where the executable is not a
# dynamically linked executable. This can occur when using musl libc,
# for example. In this situation, dlopen() will error, leading to an
# OSError. Interestingly, at least in the case of musl, there is no
# errno set on the OSError. The single string argument used to construct
# OSError comes from libc itself and is therefore not portable to
# hard code here. In any case, failure to call dlopen() means we
# can proceed, so we bail on our attempt.
try:
    process_namespace = ctypes.CDLL(None)
except OSError:
    return None

try:
    gnu_get_libc_version = process_namespace.gnu_get_libc_version
except AttributeError:
    # Symbol doesn&#39;t exist -&gt; therefore, we are not linked to
    # glibc.
    return None

# Call gnu_get_libc_version, which returns a string like &quot;2.5&quot;
gnu_get_libc_version.restype = ctypes.c_char_p
version_str: str = gnu_get_libc_version()
# py2 / py3 compatibility:
if not isinstance(version_str, str):
    version_str = version_str.decode(&quot;ascii&quot;)

return version_str
</pre></div>
</div>
<p>def _glibc_version_string() -&gt; str | None:
“””Returns glibc version string, or None if not using glibc.”””
return _glibc_version_string_confstr() or _glibc_version_string_ctypes()</p>
<p>def _parse_glibc_version(version_str: str) -&gt; tuple[int, int]:
“””Parse glibc version.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>We use a regexp instead of str.split because we want to discard any
random junk that might come after the minor version -- this might happen
in patched/forked versions of glibc (e.g. Linaro&#39;s version of glibc
uses version strings like &quot;2.20-2014.11&quot;). See gh-3588.
&quot;&quot;&quot;
m = re.match(r&quot;(?P&lt;major&gt;[0-9]+)\.(?P&lt;minor&gt;[0-9]+)&quot;, version_str)
if not m:
    warnings.warn(
        f&quot;Expected glibc version with 2 components major.minor, got: {version_str}&quot;,
        RuntimeWarning,
        stacklevel=2,
    )
    return -1, -1
return int(m.group(&quot;major&quot;)), int(m.group(&quot;minor&quot;))
</pre></div>
</div>
<p>&#64;functools.lru_cache
def _get_glibc_version() -&gt; tuple[int, int]:
version_str = _glibc_version_string()
if version_str is None:
return (-1, -1)
return _parse_glibc_version(version_str)</p>
</section>
<section id="from-pep-513-pep-600">
<h1>From PEP 513, PEP 600<a class="headerlink" href="#from-pep-513-pep-600" title="Link to this heading"></a></h1>
<p>def _is_compatible(arch: str, version: _GLibCVersion) -&gt; bool:
sys_glibc = _get_glibc_version()
if sys_glibc &lt; version:
return False
# Check for presence of _manylinux module.
try:
import _manylinux
except ImportError:
return True
if hasattr(_manylinux, “manylinux_compatible”):
result = _manylinux.manylinux_compatible(version[0], version[1], arch)
if result is not None:
return bool(result)
return True
if version == _GLibCVersion(2, 5):
if hasattr(_manylinux, “manylinux1_compatible”):
return bool(_manylinux.manylinux1_compatible)
if version == _GLibCVersion(2, 12):
if hasattr(_manylinux, “manylinux2010_compatible”):
return bool(_manylinux.manylinux2010_compatible)
if version == _GLibCVersion(2, 17):
if hasattr(_manylinux, “manylinux2014_compatible”):
return bool(_manylinux.manylinux2014_compatible)
return True</p>
<p>_LEGACY_MANYLINUX_MAP = {
# CentOS 7 w/ glibc 2.17 (PEP 599)
(2, 17): “manylinux2014”,
# CentOS 6 w/ glibc 2.12 (PEP 571)
(2, 12): “manylinux2010”,
# CentOS 5 w/ glibc 2.5 (PEP 513)
(2, 5): “manylinux1”,
}</p>
<p>def platform_tags(archs: Sequence[str]) -&gt; Iterator[str]:
“””Generate manylinux tags compatible to the current platform.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param archs: Sequence of compatible architectures.
    The first one shall be the closest to the actual architecture and be the part of
    platform tag after the ``linux_`` prefix, e.g. ``x86_64``.
    The ``linux_`` prefix is assumed as a prerequisite for the current platform to
    be manylinux-compatible.

:returns: An iterator of compatible manylinux tags.
&quot;&quot;&quot;
if not _have_compatible_abi(sys.executable, archs):
    return
# Oldest glibc to be supported regardless of architecture is (2, 17).
too_old_glibc2 = _GLibCVersion(2, 16)
if set(archs) &amp; {&quot;x86_64&quot;, &quot;i686&quot;}:
    # On x86/i686 also oldest glibc to be supported is (2, 5).
    too_old_glibc2 = _GLibCVersion(2, 4)
current_glibc = _GLibCVersion(*_get_glibc_version())
glibc_max_list = [current_glibc]
# We can assume compatibility across glibc major versions.
# https://sourceware.org/bugzilla/show_bug.cgi?id=24636
#
# Build a list of maximum glibc versions so that we can
# output the canonical list of all glibc from current_glibc
# down to too_old_glibc2, including all intermediary versions.
for glibc_major in range(current_glibc.major - 1, 1, -1):
    glibc_minor = _LAST_GLIBC_MINOR[glibc_major]
    glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))
for arch in archs:
    for glibc_max in glibc_max_list:
        if glibc_max.major == too_old_glibc2.major:
            min_minor = too_old_glibc2.minor
        else:
            # For other glibc major versions oldest supported is (x, 0).
            min_minor = -1
        for glibc_minor in range(glibc_max.minor, min_minor, -1):
            glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)
            tag = &quot;manylinux_{}_{}&quot;.format(*glibc_version)
            if _is_compatible(arch, glibc_version):
                yield f&quot;{tag}_{arch}&quot;
            # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.
            if glibc_version in _LEGACY_MANYLINUX_MAP:
                legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]
                if _is_compatible(arch, glibc_version):
                    yield f&quot;{legacy_tag}_{arch}&quot;
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>