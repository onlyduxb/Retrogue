

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>-- coding: utf-8 -- &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">-<em>- coding: utf-8 -</em>-</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/distlib/compat.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="coding-utf-8">
<h1>-<em>- coding: utf-8 -</em>-<a class="headerlink" href="#coding-utf-8" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="copyright-c-2013-2017-vinay-sajip">
<h1>Copyright (C) 2013-2017 Vinay Sajip.<a class="headerlink" href="#copyright-c-2013-2017-vinay-sajip" title="Link to this heading"></a></h1>
</section>
<section id="licensed-to-the-python-software-foundation-under-a-contributor-agreement">
<h1>Licensed to the Python Software Foundation under a contributor agreement.<a class="headerlink" href="#licensed-to-the-python-software-foundation-under-a-contributor-agreement" title="Link to this heading"></a></h1>
</section>
<section id="see-license-txt-and-contributors-txt">
<h1>See LICENSE.txt and CONTRIBUTORS.txt.<a class="headerlink" href="#see-license-txt-and-contributors-txt" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import absolute_import</p>
<p>import os
import re
import shutil
import sys</p>
<p>try:
import ssl
except ImportError:  # pragma: no cover
ssl = None</p>
<p>if sys.version_info[0] &lt; 3:  # pragma: no cover
from StringIO import StringIO
string_types = basestring,
text_type = unicode
from types import FileType as file_type
import <strong>builtin</strong> as builtins
import ConfigParser as configparser
from urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit
from urllib import (urlretrieve, quote as _quote, unquote, url2pathname,
pathname2url, ContentTooShortError, splittype)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def quote(s):
    if isinstance(s, unicode):
        s = s.encode(&#39;utf-8&#39;)
    return _quote(s)

import urllib2
from urllib2 import (Request, urlopen, URLError, HTTPError,
                     HTTPBasicAuthHandler, HTTPPasswordMgr, HTTPHandler,
                     HTTPRedirectHandler, build_opener)
if ssl:
    from urllib2 import HTTPSHandler
import httplib
import xmlrpclib
import Queue as queue
from HTMLParser import HTMLParser
import htmlentitydefs
raw_input = raw_input
from itertools import ifilter as filter
from itertools import ifilterfalse as filterfalse

# Leaving this around for now, in case it needs resurrecting in some way
# _userprog = None
# def splituser(host):
# &quot;&quot;&quot;splituser(&#39;user[:passwd]@host[:port]&#39;) --&gt; &#39;user[:passwd]&#39;, &#39;host[:port]&#39;.&quot;&quot;&quot;
# global _userprog
# if _userprog is None:
# import re
# _userprog = re.compile(&#39;^(.*)@(.*)$&#39;)

# match = _userprog.match(host)
# if match: return match.group(1, 2)
# return None, host
</pre></div>
</div>
<p>else:  # pragma: no cover
from io import StringIO
string_types = str,
text_type = str
from io import TextIOWrapper as file_type
import builtins
import configparser
from urllib.parse import (urlparse, urlunparse, urljoin, quote, unquote,
urlsplit, urlunsplit, splittype)
from urllib.request import (urlopen, urlretrieve, Request, url2pathname,
pathname2url, HTTPBasicAuthHandler,
HTTPPasswordMgr, HTTPHandler,
HTTPRedirectHandler, build_opener)
if ssl:
from urllib.request import HTTPSHandler
from urllib.error import HTTPError, URLError, ContentTooShortError
import http.client as httplib
import urllib.request as urllib2
import xmlrpc.client as xmlrpclib
import queue
from html.parser import HTMLParser
import html.entities as htmlentitydefs
raw_input = input
from itertools import filterfalse
filter = filter</p>
<p>try:
from ssl import match_hostname, CertificateError
except ImportError:  # pragma: no cover</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class CertificateError(ValueError):
    pass

def _dnsname_match(dn, hostname, max_wildcards=1):
    &quot;&quot;&quot;Matching according to RFC 6125, section 6.4.3

    http://tools.ietf.org/html/rfc6125#section-6.4.3
    &quot;&quot;&quot;
    pats = []
    if not dn:
        return False

    parts = dn.split(&#39;.&#39;)
    leftmost, remainder = parts[0], parts[1:]

    wildcards = leftmost.count(&#39;*&#39;)
    if wildcards &gt; max_wildcards:
        # Issue #17980: avoid denials of service by refusing more
        # than one wildcard per fragment.  A survey of established
        # policy among SSL implementations showed it to be a
        # reasonable choice.
        raise CertificateError(
            &quot;too many wildcards in certificate DNS name: &quot; + repr(dn))

    # speed up common case w/o wildcards
    if not wildcards:
        return dn.lower() == hostname.lower()

    # RFC 6125, section 6.4.3, subitem 1.
    # The client SHOULD NOT attempt to match a presented identifier in which
    # the wildcard character comprises a label other than the left-most label.
    if leftmost == &#39;*&#39;:
        # When &#39;*&#39; is a fragment by itself, it matches a non-empty dotless
        # fragment.
        pats.append(&#39;[^.]+&#39;)
    elif leftmost.startswith(&#39;xn--&#39;) or hostname.startswith(&#39;xn--&#39;):
        # RFC 6125, section 6.4.3, subitem 3.
        # The client SHOULD NOT attempt to match a presented identifier
        # where the wildcard character is embedded within an A-label or
        # U-label of an internationalized domain name.
        pats.append(re.escape(leftmost))
    else:
        # Otherwise, &#39;*&#39; matches any dotless string, e.g. www*
        pats.append(re.escape(leftmost).replace(r&#39;\*&#39;, &#39;[^.]*&#39;))

    # add the remaining fragments, ignore any wildcards
    for frag in remainder:
        pats.append(re.escape(frag))

    pat = re.compile(r&#39;\A&#39; + r&#39;\.&#39;.join(pats) + r&#39;\Z&#39;, re.IGNORECASE)
    return pat.match(hostname)

def match_hostname(cert, hostname):
    &quot;&quot;&quot;Verify that *cert* (in decoded format as returned by
    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
    rules are followed, but IP addresses are not accepted for *hostname*.

    CertificateError is raised on failure. On success, the function
    returns nothing.
    &quot;&quot;&quot;
    if not cert:
        raise ValueError(&quot;empty or no certificate, match_hostname needs a &quot;
                         &quot;SSL socket or SSL context with either &quot;
                         &quot;CERT_OPTIONAL or CERT_REQUIRED&quot;)
    dnsnames = []
    san = cert.get(&#39;subjectAltName&#39;, ())
    for key, value in san:
        if key == &#39;DNS&#39;:
            if _dnsname_match(value, hostname):
                return
            dnsnames.append(value)
    if not dnsnames:
        # The subject is only checked when there is no dNSName entry
        # in subjectAltName
        for sub in cert.get(&#39;subject&#39;, ()):
            for key, value in sub:
                # XXX according to RFC 2818, the most specific Common Name
                # must be used.
                if key == &#39;commonName&#39;:
                    if _dnsname_match(value, hostname):
                        return
                    dnsnames.append(value)
    if len(dnsnames) &gt; 1:
        raise CertificateError(&quot;hostname %r &quot;
                               &quot;doesn&#39;t match either of %s&quot; %
                               (hostname, &#39;, &#39;.join(map(repr, dnsnames))))
    elif len(dnsnames) == 1:
        raise CertificateError(&quot;hostname %r &quot;
                               &quot;doesn&#39;t match %r&quot; %
                               (hostname, dnsnames[0]))
    else:
        raise CertificateError(&quot;no appropriate commonName or &quot;
                               &quot;subjectAltName fields were found&quot;)
</pre></div>
</div>
<p>try:
from types import SimpleNamespace as Container
except ImportError:  # pragma: no cover</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class Container(object):
    &quot;&quot;&quot;
    A generic container for when multiple values need to be returned
    &quot;&quot;&quot;

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
</pre></div>
</div>
<p>try:
from shutil import which
except ImportError:  # pragma: no cover
# Implementation from Python 3.3
def which(cmd, mode=os.F_OK | os.X_OK, path=None):
“””Given a command, mode, and a PATH string, return the path which
conforms to the given mode on the PATH, or None if there is no such
file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
    of os.environ.get(&quot;PATH&quot;), or can be overridden with a custom search
    path.

    &quot;&quot;&quot;

    # Check that a given file can be accessed with the correct mode.
    # Additionally check that `file` is not a directory, as on Windows
    # directories pass the os.access check.
    def _access_check(fn, mode):
        return (os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn))

    # If we&#39;re given a path with a directory part, look it up directly rather
    # than referring to PATH directories. This includes checking relative to the
    # current directory, e.g. ./script
    if os.path.dirname(cmd):
        if _access_check(cmd, mode):
            return cmd
        return None

    if path is None:
        path = os.environ.get(&quot;PATH&quot;, os.defpath)
    if not path:
        return None
    path = path.split(os.pathsep)

    if sys.platform == &quot;win32&quot;:
        # The current directory takes precedence on Windows.
        if os.curdir not in path:
            path.insert(0, os.curdir)

        # PATHEXT is necessary to check on Windows.
        pathext = os.environ.get(&quot;PATHEXT&quot;, &quot;&quot;).split(os.pathsep)
        # See if the given file matches any of the expected path extensions.
        # This will allow us to short circuit when given &quot;python.exe&quot;.
        # If it does match, only test that one, otherwise we have to try
        # others.
        if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
            files = [cmd]
        else:
            files = [cmd + ext for ext in pathext]
    else:
        # On other platforms you don&#39;t have things like PATHEXT to tell you
        # what file suffixes are executable, so just pass on cmd as-is.
        files = [cmd]

    seen = set()
    for dir in path:
        normdir = os.path.normcase(dir)
        if normdir not in seen:
            seen.add(normdir)
            for thefile in files:
                name = os.path.join(dir, thefile)
                if _access_check(name, mode):
                    return name
    return None
</pre></div>
</div>
</section>
<section id="zipfile-is-a-context-manager-in-2-7-but-not-in-2-6">
<h1>ZipFile is a context manager in 2.7, but not in 2.6<a class="headerlink" href="#zipfile-is-a-context-manager-in-2-7-but-not-in-2-6" title="Link to this heading"></a></h1>
<p>from zipfile import ZipFile as BaseZipFile</p>
<p>if hasattr(BaseZipFile, ‘<strong>enter</strong>’):  # pragma: no cover
ZipFile = BaseZipFile
else:  # pragma: no cover
from zipfile import ZipExtFile as BaseZipExtFile</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class ZipExtFile(BaseZipExtFile):

    def __init__(self, base):
        self.__dict__.update(base.__dict__)

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        self.close()
        # return None, so if an exception occurred, it will propagate

class ZipFile(BaseZipFile):

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        self.close()
        # return None, so if an exception occurred, it will propagate

    def open(self, *args, **kwargs):
        base = BaseZipFile.open(self, *args, **kwargs)
        return ZipExtFile(base)
</pre></div>
</div>
<p>try:
from platform import python_implementation
except ImportError:  # pragma: no cover</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def python_implementation():
    &quot;&quot;&quot;Return a string identifying the Python implementation.&quot;&quot;&quot;
    if &#39;PyPy&#39; in sys.version:
        return &#39;PyPy&#39;
    if os.name == &#39;java&#39;:
        return &#39;Jython&#39;
    if sys.version.startswith(&#39;IronPython&#39;):
        return &#39;IronPython&#39;
    return &#39;CPython&#39;
</pre></div>
</div>
<p>import sysconfig</p>
<p>try:
callable = callable
except NameError:  # pragma: no cover
from collections.abc import Callable</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def callable(obj):
    return isinstance(obj, Callable)
</pre></div>
</div>
<p>try:
fsencode = os.fsencode
fsdecode = os.fsdecode
except AttributeError:  # pragma: no cover
# Issue #99: on some systems (e.g. containerised),
# sys.getfilesystemencoding() returns None, and we need a real value,
# so fall back to utf-8. From the CPython 2.7 docs relating to Unix and
# sys.getfilesystemencoding(): the return value is “the user’s preference
# according to the result of nl_langinfo(CODESET), or None if the
# nl_langinfo(CODESET) failed.”
_fsencoding = sys.getfilesystemencoding() or ‘utf-8’
if _fsencoding == ‘mbcs’:
_fserrors = ‘strict’
else:
_fserrors = ‘surrogateescape’</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def fsencode(filename):
    if isinstance(filename, bytes):
        return filename
    elif isinstance(filename, text_type):
        return filename.encode(_fsencoding, _fserrors)
    else:
        raise TypeError(&quot;expect bytes or str, not %s&quot; %
                        type(filename).__name__)

def fsdecode(filename):
    if isinstance(filename, text_type):
        return filename
    elif isinstance(filename, bytes):
        return filename.decode(_fsencoding, _fserrors)
    else:
        raise TypeError(&quot;expect bytes or str, not %s&quot; %
                        type(filename).__name__)
</pre></div>
</div>
<p>try:
from tokenize import detect_encoding
except ImportError:  # pragma: no cover
from codecs import BOM_UTF8, lookup</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cookie_re = re.compile(r&quot;coding[:=]\s*([-\w.]+)&quot;)

def _get_normal_name(orig_enc):
    &quot;&quot;&quot;Imitates get_normal_name in tokenizer.c.&quot;&quot;&quot;
    # Only care about the first 12 characters.
    enc = orig_enc[:12].lower().replace(&quot;_&quot;, &quot;-&quot;)
    if enc == &quot;utf-8&quot; or enc.startswith(&quot;utf-8-&quot;):
        return &quot;utf-8&quot;
    if enc in (&quot;latin-1&quot;, &quot;iso-8859-1&quot;, &quot;iso-latin-1&quot;) or \
       enc.startswith((&quot;latin-1-&quot;, &quot;iso-8859-1-&quot;, &quot;iso-latin-1-&quot;)):
        return &quot;iso-8859-1&quot;
    return orig_enc

def detect_encoding(readline):
    &quot;&quot;&quot;
    The detect_encoding() function is used to detect the encoding that should
    be used to decode a Python source file.  It requires one argument, readline,
    in the same way as the tokenize() generator.

    It will call readline a maximum of twice, and return the encoding used
    (as a string) and a list of any lines (left as bytes) it has read in.

    It detects the encoding from the presence of a utf-8 bom or an encoding
    cookie as specified in pep-0263.  If both a bom and a cookie are present,
    but disagree, a SyntaxError will be raised.  If the encoding cookie is an
    invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
    &#39;utf-8-sig&#39; is returned.

    If no encoding is specified, then the default of &#39;utf-8&#39; will be returned.
    &quot;&quot;&quot;
    try:
        filename = readline.__self__.name
    except AttributeError:
        filename = None
    bom_found = False
    encoding = None
    default = &#39;utf-8&#39;

    def read_or_stop():
        try:
            return readline()
        except StopIteration:
            return b&#39;&#39;

    def find_cookie(line):
        try:
            # Decode as UTF-8. Either the line is an encoding declaration,
            # in which case it should be pure ASCII, or it must be UTF-8
            # per default encoding.
            line_string = line.decode(&#39;utf-8&#39;)
        except UnicodeDecodeError:
            msg = &quot;invalid or missing encoding declaration&quot;
            if filename is not None:
                msg = &#39;{} for {!r}&#39;.format(msg, filename)
            raise SyntaxError(msg)

        matches = cookie_re.findall(line_string)
        if not matches:
            return None
        encoding = _get_normal_name(matches[0])
        try:
            codec = lookup(encoding)
        except LookupError:
            # This behaviour mimics the Python interpreter
            if filename is None:
                msg = &quot;unknown encoding: &quot; + encoding
            else:
                msg = &quot;unknown encoding for {!r}: {}&quot;.format(
                    filename, encoding)
            raise SyntaxError(msg)

        if bom_found:
            if codec.name != &#39;utf-8&#39;:
                # This behaviour mimics the Python interpreter
                if filename is None:
                    msg = &#39;encoding problem: utf-8&#39;
                else:
                    msg = &#39;encoding problem for {!r}: utf-8&#39;.format(
                        filename)
                raise SyntaxError(msg)
            encoding += &#39;-sig&#39;
        return encoding

    first = read_or_stop()
    if first.startswith(BOM_UTF8):
        bom_found = True
        first = first[3:]
        default = &#39;utf-8-sig&#39;
    if not first:
        return default, []

    encoding = find_cookie(first)
    if encoding:
        return encoding, [first]

    second = read_or_stop()
    if not second:
        return default, [first]

    encoding = find_cookie(second)
    if encoding:
        return encoding, [first, second]

    return default, [first, second]
</pre></div>
</div>
</section>
<section id="for-converting-etc">
<h1>For converting &amp; &lt;-&gt; &amp; etc.<a class="headerlink" href="#for-converting-etc" title="Link to this heading"></a></h1>
<p>try:
from html import escape
except ImportError:
from cgi import escape
if sys.version_info[:2] &lt; (3, 4):
unescape = HTMLParser().unescape
else:
from html import unescape</p>
<p>try:
from collections import ChainMap
except ImportError:  # pragma: no cover
from collections import MutableMapping</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>try:
    from reprlib import recursive_repr as _recursive_repr
except ImportError:

    def _recursive_repr(fillvalue=&#39;...&#39;):
        &#39;&#39;&#39;
        Decorator to make a repr function return fillvalue for a recursive
        call
        &#39;&#39;&#39;

        def decorating_function(user_function):
            repr_running = set()

            def wrapper(self):
                key = id(self), get_ident()
                if key in repr_running:
                    return fillvalue
                repr_running.add(key)
                try:
                    result = user_function(self)
                finally:
                    repr_running.discard(key)
                return result

            # Can&#39;t use functools.wraps() here because of bootstrap issues
            wrapper.__module__ = getattr(user_function, &#39;__module__&#39;)
            wrapper.__doc__ = getattr(user_function, &#39;__doc__&#39;)
            wrapper.__name__ = getattr(user_function, &#39;__name__&#39;)
            wrapper.__annotations__ = getattr(user_function,
                                              &#39;__annotations__&#39;, {})
            return wrapper

        return decorating_function

class ChainMap(MutableMapping):
    &#39;&#39;&#39;
    A ChainMap groups multiple dicts (or other mappings) together
    to create a single, updateable view.

    The underlying mappings are stored in a list.  That list is public and can
    accessed or updated using the *maps* attribute.  There is no other state.

    Lookups search the underlying mappings successively until a key is found.
    In contrast, writes, updates, and deletions only operate on the first
    mapping.
    &#39;&#39;&#39;

    def __init__(self, *maps):
        &#39;&#39;&#39;Initialize a ChainMap by setting *maps* to the given mappings.
        If no mappings are provided, a single empty dictionary is used.

        &#39;&#39;&#39;
        self.maps = list(maps) or [{}]  # always at least one map

    def __missing__(self, key):
        raise KeyError(key)

    def __getitem__(self, key):
        for mapping in self.maps:
            try:
                return mapping[
                    key]  # can&#39;t use &#39;key in mapping&#39; with defaultdict
            except KeyError:
                pass
        return self.__missing__(
            key)  # support subclasses that define __missing__

    def get(self, key, default=None):
        return self[key] if key in self else default

    def __len__(self):
        return len(set().union(
            *self.maps))  # reuses stored hash values if possible

    def __iter__(self):
        return iter(set().union(*self.maps))

    def __contains__(self, key):
        return any(key in m for m in self.maps)

    def __bool__(self):
        return any(self.maps)

    @_recursive_repr()
    def __repr__(self):
        return &#39;{0.__class__.__name__}({1})&#39;.format(
            self, &#39;, &#39;.join(map(repr, self.maps)))

    @classmethod
    def fromkeys(cls, iterable, *args):
        &#39;Create a ChainMap with a single dict created from the iterable.&#39;
        return cls(dict.fromkeys(iterable, *args))

    def copy(self):
        &#39;New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]&#39;
        return self.__class__(self.maps[0].copy(), *self.maps[1:])

    __copy__ = copy

    def new_child(self):  # like Django&#39;s Context.push()
        &#39;New ChainMap with a new dict followed by all previous maps.&#39;
        return self.__class__({}, *self.maps)

    @property
    def parents(self):  # like Django&#39;s Context.pop()
        &#39;New ChainMap from maps[1:].&#39;
        return self.__class__(*self.maps[1:])

    def __setitem__(self, key, value):
        self.maps[0][key] = value

    def __delitem__(self, key):
        try:
            del self.maps[0][key]
        except KeyError:
            raise KeyError(
                &#39;Key not found in the first mapping: {!r}&#39;.format(key))

    def popitem(self):
        &#39;Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.&#39;
        try:
            return self.maps[0].popitem()
        except KeyError:
            raise KeyError(&#39;No keys found in the first mapping.&#39;)

    def pop(self, key, *args):
        &#39;Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].&#39;
        try:
            return self.maps[0].pop(key, *args)
        except KeyError:
            raise KeyError(
                &#39;Key not found in the first mapping: {!r}&#39;.format(key))

    def clear(self):
        &#39;Clear maps[0], leaving maps[1:] intact.&#39;
        self.maps[0].clear()
</pre></div>
</div>
<p>try:
from importlib.util import cache_from_source  # Python &gt;= 3.4
except ImportError:  # pragma: no cover</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def cache_from_source(path, debug_override=None):
    assert path.endswith(&#39;.py&#39;)
    if debug_override is None:
        debug_override = __debug__
    if debug_override:
        suffix = &#39;c&#39;
    else:
        suffix = &#39;o&#39;
    return path + suffix
</pre></div>
</div>
<p>try:
from collections import OrderedDict
except ImportError:  # pragma: no cover
# {{{ http://code.activestate.com/recipes/576693/ (r9)
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7’s test suite and incorporates all the latest updates.
try:
from thread import get_ident as _get_ident
except ImportError:
from dummy_thread import get_ident as _get_ident</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass

class OrderedDict(dict):
    &#39;Dictionary that remembers insertion order&#39;

    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        &#39;&#39;&#39;Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        &#39;&#39;&#39;
        if len(args) &gt; 1:
            raise TypeError(&#39;expected at most 1 arguments, got %d&#39; %
                            len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []  # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        &#39;od.__setitem__(i, y) &lt;==&gt; od[i]=y&#39;
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        &#39;od.__delitem__(y) &lt;==&gt; del od[y]&#39;
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        &#39;od.__iter__() &lt;==&gt; iter(od)&#39;
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        &#39;od.__reversed__() &lt;==&gt; reversed(od)&#39;
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        &#39;od.clear() -&gt; None.  Remove all items from od.&#39;
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        &#39;&#39;&#39;od.popitem() -&gt; (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        &#39;&#39;&#39;
        if not self:
            raise KeyError(&#39;dictionary is empty&#39;)
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        &#39;od.keys() -&gt; list of keys in od&#39;
        return list(self)

    def values(self):
        &#39;od.values() -&gt; list of values in od&#39;
        return [self[key] for key in self]

    def items(self):
        &#39;od.items() -&gt; list of (key, value) pairs in od&#39;
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        &#39;od.iterkeys() -&gt; an iterator over the keys in od&#39;
        return iter(self)

    def itervalues(self):
        &#39;od.itervalues -&gt; an iterator over the values in od&#39;
        for k in self:
            yield self[k]

    def iteritems(self):
        &#39;od.iteritems -&gt; an iterator over the (key, value) items in od&#39;
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        &#39;&#39;&#39;od.update(E, **F) -&gt; None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        &#39;&#39;&#39;
        if len(args) &gt; 2:
            raise TypeError(&#39;update() takes at most 2 positional &#39;
                            &#39;arguments (%d given)&#39; % (len(args), ))
        elif not args:
            raise TypeError(&#39;update() takes at least 1 argument (0 given)&#39;)
        self = args[0]
        # Make progressively weaker assumptions about &quot;other&quot;
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, &#39;keys&#39;):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    __update = update  # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        &#39;&#39;&#39;od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        &#39;&#39;&#39;
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        &#39;od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od&#39;
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running=None):
        &#39;od.__repr__() &lt;==&gt; repr(od)&#39;
        if not _repr_running:
            _repr_running = {}
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return &#39;...&#39;
        _repr_running[call_key] = 1
        try:
            if not self:
                return &#39;%s()&#39; % (self.__class__.__name__, )
            return &#39;%s(%r)&#39; % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        &#39;Return state information for pickling&#39;
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items, ), inst_dict)
        return self.__class__, (items, )

    def copy(self):
        &#39;od.copy() -&gt; a shallow copy of od&#39;
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        &#39;&#39;&#39;OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        &#39;&#39;&#39;
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        &#39;&#39;&#39;od.__eq__(y) &lt;==&gt; od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        &#39;&#39;&#39;
        if isinstance(other, OrderedDict):
            return len(self) == len(
                other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        &quot;od.viewkeys() -&gt; a set-like object providing a view on od&#39;s keys&quot;
        return KeysView(self)

    def viewvalues(self):
        &quot;od.viewvalues() -&gt; an object providing a view on od&#39;s values&quot;
        return ValuesView(self)

    def viewitems(self):
        &quot;od.viewitems() -&gt; a set-like object providing a view on od&#39;s items&quot;
        return ItemsView(self)
</pre></div>
</div>
<p>try:
from logging.config import BaseConfigurator, valid_ident
except ImportError:  # pragma: no cover
IDENTIFIER = re.compile(‘^[a-z_][a-z0-9_]*$’, re.I)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def valid_ident(s):
    m = IDENTIFIER.match(s)
    if not m:
        raise ValueError(&#39;Not a valid Python identifier: %r&#39; % s)
    return True

# The ConvertingXXX classes are wrappers around standard Python containers,
# and they serve to convert any suitable values in the container. The
# conversion converts base dicts, lists and tuples to their wrapped
# equivalents, whereas strings which match a conversion format are converted
# appropriately.
#
# Each wrapper should have a configurator attribute holding the actual
# configurator to use for conversion.

class ConvertingDict(dict):
    &quot;&quot;&quot;A converting dictionary wrapper.&quot;&quot;&quot;

    def __getitem__(self, key):
        value = dict.__getitem__(self, key)
        result = self.configurator.convert(value)
        # If the converted value is different, save for next time
        if value is not result:
            self[key] = result
            if type(result) in (ConvertingDict, ConvertingList,
                                ConvertingTuple):
                result.parent = self
                result.key = key
        return result

    def get(self, key, default=None):
        value = dict.get(self, key, default)
        result = self.configurator.convert(value)
        # If the converted value is different, save for next time
        if value is not result:
            self[key] = result
            if type(result) in (ConvertingDict, ConvertingList,
                                ConvertingTuple):
                result.parent = self
                result.key = key
        return result

def pop(self, key, default=None):
    value = dict.pop(self, key, default)
    result = self.configurator.convert(value)
    if value is not result:
        if type(result) in (ConvertingDict, ConvertingList,
                            ConvertingTuple):
            result.parent = self
            result.key = key
    return result

class ConvertingList(list):
    &quot;&quot;&quot;A converting list wrapper.&quot;&quot;&quot;

    def __getitem__(self, key):
        value = list.__getitem__(self, key)
        result = self.configurator.convert(value)
        # If the converted value is different, save for next time
        if value is not result:
            self[key] = result
            if type(result) in (ConvertingDict, ConvertingList,
                                ConvertingTuple):
                result.parent = self
                result.key = key
        return result

    def pop(self, idx=-1):
        value = list.pop(self, idx)
        result = self.configurator.convert(value)
        if value is not result:
            if type(result) in (ConvertingDict, ConvertingList,
                                ConvertingTuple):
                result.parent = self
        return result

class ConvertingTuple(tuple):
    &quot;&quot;&quot;A converting tuple wrapper.&quot;&quot;&quot;

    def __getitem__(self, key):
        value = tuple.__getitem__(self, key)
        result = self.configurator.convert(value)
        if value is not result:
            if type(result) in (ConvertingDict, ConvertingList,
                                ConvertingTuple):
                result.parent = self
                result.key = key
        return result

class BaseConfigurator(object):
    &quot;&quot;&quot;
    The configurator base class which defines some useful defaults.
    &quot;&quot;&quot;

    CONVERT_PATTERN = re.compile(r&#39;^(?P&lt;prefix&gt;[a-z]+)://(?P&lt;suffix&gt;.*)$&#39;)

    WORD_PATTERN = re.compile(r&#39;^\s*(\w+)\s*&#39;)
    DOT_PATTERN = re.compile(r&#39;^\.\s*(\w+)\s*&#39;)
    INDEX_PATTERN = re.compile(r&#39;^\[\s*(\w+)\s*\]\s*&#39;)
    DIGIT_PATTERN = re.compile(r&#39;^\d+$&#39;)

    value_converters = {
        &#39;ext&#39;: &#39;ext_convert&#39;,
        &#39;cfg&#39;: &#39;cfg_convert&#39;,
    }

    # We might want to use a different one, e.g. importlib
    importer = staticmethod(__import__)

    def __init__(self, config):
        self.config = ConvertingDict(config)
        self.config.configurator = self

    def resolve(self, s):
        &quot;&quot;&quot;
        Resolve strings to objects using standard import and attribute
        syntax.
        &quot;&quot;&quot;
        name = s.split(&#39;.&#39;)
        used = name.pop(0)
        try:
            found = self.importer(used)
            for frag in name:
                used += &#39;.&#39; + frag
                try:
                    found = getattr(found, frag)
                except AttributeError:
                    self.importer(used)
                    found = getattr(found, frag)
            return found
        except ImportError:
            e, tb = sys.exc_info()[1:]
            v = ValueError(&#39;Cannot resolve %r: %s&#39; % (s, e))
            v.__cause__, v.__traceback__ = e, tb
            raise v

    def ext_convert(self, value):
        &quot;&quot;&quot;Default converter for the ext:// protocol.&quot;&quot;&quot;
        return self.resolve(value)

    def cfg_convert(self, value):
        &quot;&quot;&quot;Default converter for the cfg:// protocol.&quot;&quot;&quot;
        rest = value
        m = self.WORD_PATTERN.match(rest)
        if m is None:
            raise ValueError(&quot;Unable to convert %r&quot; % value)
        else:
            rest = rest[m.end():]
            d = self.config[m.groups()[0]]
            while rest:
                m = self.DOT_PATTERN.match(rest)
                if m:
                    d = d[m.groups()[0]]
                else:
                    m = self.INDEX_PATTERN.match(rest)
                    if m:
                        idx = m.groups()[0]
                        if not self.DIGIT_PATTERN.match(idx):
                            d = d[idx]
                        else:
                            try:
                                n = int(
                                    idx
                                )  # try as number first (most likely)
                                d = d[n]
                            except TypeError:
                                d = d[idx]
                if m:
                    rest = rest[m.end():]
                else:
                    raise ValueError(&#39;Unable to convert &#39;
                                     &#39;%r at %r&#39; % (value, rest))
        # rest should be empty
        return d

    def convert(self, value):
        &quot;&quot;&quot;
        Convert values to an appropriate type. dicts, lists and tuples are
        replaced by their converting alternatives. Strings are checked to
        see if they have a conversion format and are converted if they do.
        &quot;&quot;&quot;
        if not isinstance(value, ConvertingDict) and isinstance(
                value, dict):
            value = ConvertingDict(value)
            value.configurator = self
        elif not isinstance(value, ConvertingList) and isinstance(
                value, list):
            value = ConvertingList(value)
            value.configurator = self
        elif not isinstance(value, ConvertingTuple) and isinstance(value, tuple):
            value = ConvertingTuple(value)
            value.configurator = self
        elif isinstance(value, string_types):
            m = self.CONVERT_PATTERN.match(value)
            if m:
                d = m.groupdict()
                prefix = d[&#39;prefix&#39;]
                converter = self.value_converters.get(prefix, None)
                if converter:
                    suffix = d[&#39;suffix&#39;]
                    converter = getattr(self, converter)
                    value = converter(suffix)
        return value

    def configure_custom(self, config):
        &quot;&quot;&quot;Configure an object with a user-supplied factory.&quot;&quot;&quot;
        c = config.pop(&#39;()&#39;)
        if not callable(c):
            c = self.resolve(c)
        props = config.pop(&#39;.&#39;, None)
        # Check for valid identifiers
        kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])
        result = c(**kwargs)
        if props:
            for name, value in props.items():
                setattr(result, name, value)
        return result

    def as_tuple(self, value):
        &quot;&quot;&quot;Utility function which converts lists to tuples.&quot;&quot;&quot;
        if isinstance(value, list):
            value = tuple(value)
        return value
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>