

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The RawMetadata class attempts to make as few assumptions about the underlying &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The RawMetadata class attempts to make as few assumptions about the underlying</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/metadata.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import email.feedparser
import email.header
import email.message
import email.parser
import email.policy
import pathlib
import sys
import typing
from typing import (
Any,
Callable,
Generic,
Literal,
TypedDict,
cast,
)</p>
<p>from . import licenses, requirements, specifiers, utils
from . import version as version_module
from .licenses import NormalizedLicenseExpression</p>
<p>T = typing.TypeVar(“T”)</p>
<p>if sys.version_info &gt;= (3, 11):  # pragma: no cover
ExceptionGroup = ExceptionGroup
else:  # pragma: no cover</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class ExceptionGroup(Exception):
    &quot;&quot;&quot;A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.

    If :external:exc:`ExceptionGroup` is already defined by Python itself,
    that version is used instead.
    &quot;&quot;&quot;

    message: str
    exceptions: list[Exception]

    def __init__(self, message: str, exceptions: list[Exception]) -&gt; None:
        self.message = message
        self.exceptions = exceptions

    def __repr__(self) -&gt; str:
        return f&quot;{self.__class__.__name__}({self.message!r}, {self.exceptions!r})&quot;
</pre></div>
</div>
<p>class InvalidMetadata(ValueError):
“””A metadata field contains invalid data.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>field: str
&quot;&quot;&quot;The name of the field that contains invalid data.&quot;&quot;&quot;

def __init__(self, field: str, message: str) -&gt; None:
    self.field = field
    super().__init__(message)
</pre></div>
</div>
<section id="the-rawmetadata-class-attempts-to-make-as-few-assumptions-about-the-underlying">
<h1>The RawMetadata class attempts to make as few assumptions about the underlying<a class="headerlink" href="#the-rawmetadata-class-attempts-to-make-as-few-assumptions-about-the-underlying" title="Link to this heading"></a></h1>
</section>
<section id="serialization-formats-as-possible-the-idea-is-that-as-long-as-a-serialization">
<h1>serialization formats as possible. The idea is that as long as a serialization<a class="headerlink" href="#serialization-formats-as-possible-the-idea-is-that-as-long-as-a-serialization" title="Link to this heading"></a></h1>
</section>
<section id="formats-offer-some-very-basic-primitives-in-some-way-then-we-can-support">
<h1>formats offer some very basic primitives in <em>some</em> way then we can support<a class="headerlink" href="#formats-offer-some-very-basic-primitives-in-some-way-then-we-can-support" title="Link to this heading"></a></h1>
</section>
<section id="serializing-to-and-from-that-format">
<h1>serializing to and from that format.<a class="headerlink" href="#serializing-to-and-from-that-format" title="Link to this heading"></a></h1>
<p>class RawMetadata(TypedDict, total=False):
“””A dictionary of raw core metadata.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Each field in core metadata maps to a key of this dictionary (when data is
provided). The key is lower-case and underscores are used instead of dashes
compared to the equivalent core metadata field. Any core metadata field that
can be specified multiple times or can hold multiple values in a single
field have a key with a plural name. See :class:`Metadata` whose attributes
match the keys of this dictionary.

Core metadata fields that can be specified multiple times are stored as a
list or dict depending on which is appropriate for the field. Any fields
which hold multiple values in a single field are stored as a list.

&quot;&quot;&quot;

# Metadata 1.0 - PEP 241
metadata_version: str
name: str
version: str
platforms: list[str]
summary: str
description: str
keywords: list[str]
home_page: str
author: str
author_email: str
license: str

# Metadata 1.1 - PEP 314
supported_platforms: list[str]
download_url: str
classifiers: list[str]
requires: list[str]
provides: list[str]
obsoletes: list[str]

# Metadata 1.2 - PEP 345
maintainer: str
maintainer_email: str
requires_dist: list[str]
provides_dist: list[str]
obsoletes_dist: list[str]
requires_python: str
requires_external: list[str]
project_urls: dict[str, str]

# Metadata 2.0
# PEP 426 attempted to completely revamp the metadata format
# but got stuck without ever being able to build consensus on
# it and ultimately ended up withdrawn.
#
# However, a number of tools had started emitting METADATA with
# `2.0` Metadata-Version, so for historical reasons, this version
# was skipped.

# Metadata 2.1 - PEP 566
description_content_type: str
provides_extra: list[str]

# Metadata 2.2 - PEP 643
dynamic: list[str]

# Metadata 2.3 - PEP 685
# No new fields were added in PEP 685, just some edge case were
# tightened up to provide better interoptability.

# Metadata 2.4 - PEP 639
license_expression: str
license_files: list[str]
</pre></div>
</div>
<p>_STRING_FIELDS = {
“author”,
“author_email”,
“description”,
“description_content_type”,
“download_url”,
“home_page”,
“license”,
“license_expression”,
“maintainer”,
“maintainer_email”,
“metadata_version”,
“name”,
“requires_python”,
“summary”,
“version”,
}</p>
<p>_LIST_FIELDS = {
“classifiers”,
“dynamic”,
“license_files”,
“obsoletes”,
“obsoletes_dist”,
“platforms”,
“provides”,
“provides_dist”,
“provides_extra”,
“requires”,
“requires_dist”,
“requires_external”,
“supported_platforms”,
}</p>
<p>_DICT_FIELDS = {
“project_urls”,
}</p>
<p>def _parse_keywords(data: str) -&gt; list[str]:
“””Split a string of comma-separated keywords into a list of keywords.”””
return [k.strip() for k in data.split(“,”)]</p>
<p>def _parse_project_urls(data: list[str]) -&gt; dict[str, str]:
“””Parse a list of label/URL string pairings separated by a comma.”””
urls = {}
for pair in data:
# Our logic is slightly tricky here as we want to try and do
# <em>something</em> reasonable with malformed data.
#
# The main thing that we have to worry about, is data that does
# not have a ‘,’ at all to split the label from the Value. There
# isn’t a singular right answer here, and we will fail validation
# later on (if the caller is validating) so it doesn’t <em>really</em>
# matter, but since the missing value has to be an empty str
# and our return value is dict[str, str], if we let the key
# be the missing value, then they’d have multiple ‘’ values that
# overwrite each other in a accumulating dict.
#
# The other potentional issue is that it’s possible to have the
# same label multiple times in the metadata, with no solid “right”
# answer with what to do in that case. As such, we’ll do the only
# thing we can, which is treat the field as unparseable and add it
# to our list of unparsed fields.
parts = [p.strip() for p in pair.split(“,”, 1)]
parts.extend([“”] * (max(0, 2 - len(parts))))  # Ensure 2 items</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    # TODO: The spec doesn&#39;t say anything about if the keys should be
    #       considered case sensitive or not... logically they should
    #       be case-preserving and case-insensitive, but doing that
    #       would open up more cases where we might have duplicate
    #       entries.
    label, url = parts
    if label in urls:
        # The label already exists in our set of urls, so this field
        # is unparseable, and we can just add the whole thing to our
        # unparseable data and stop processing it.
        raise KeyError(&quot;duplicate labels in project urls&quot;)
    urls[label] = url

return urls
</pre></div>
</div>
<p>def _get_payload(msg: email.message.Message, source: bytes | str) -&gt; str:
“””Get the body of the message.”””
# If our source is a str, then our caller has managed encodings for us,
# and we don’t need to deal with it.
if isinstance(source, str):
payload = msg.get_payload()
assert isinstance(payload, str)
return payload
# If our source is a bytes, then we’re managing the encoding and we need
# to deal with it.
else:
bpayload = msg.get_payload(decode=True)
assert isinstance(bpayload, bytes)
try:
return bpayload.decode(“utf8”, “strict”)
except UnicodeDecodeError as exc:
raise ValueError(“payload in an invalid encoding”) from exc</p>
</section>
<section id="the-various-parse-format-functions-here-are-intended-to-be-as-lenient-as">
<h1>The various parse_FORMAT functions here are intended to be as lenient as<a class="headerlink" href="#the-various-parse-format-functions-here-are-intended-to-be-as-lenient-as" title="Link to this heading"></a></h1>
</section>
<section id="possible-in-their-parsing-while-still-returning-a-correctly-typed">
<h1>possible in their parsing, while still returning a correctly typed<a class="headerlink" href="#possible-in-their-parsing-while-still-returning-a-correctly-typed" title="Link to this heading"></a></h1>
</section>
<section id="rawmetadata">
<h1>RawMetadata.<a class="headerlink" href="#rawmetadata" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="to-aid-in-this-we-also-generally-want-to-do-as-little-touching-of-the">
<h1>To aid in this, we also generally want to do as little touching of the<a class="headerlink" href="#to-aid-in-this-we-also-generally-want-to-do-as-little-touching-of-the" title="Link to this heading"></a></h1>
</section>
<section id="data-as-possible-except-where-there-are-possibly-some-historic-holdovers">
<h1>data as possible, except where there are possibly some historic holdovers<a class="headerlink" href="#data-as-possible-except-where-there-are-possibly-some-historic-holdovers" title="Link to this heading"></a></h1>
</section>
<section id="that-make-valid-data-awkward-to-work-with">
<h1>that make valid data awkward to work with.<a class="headerlink" href="#that-make-valid-data-awkward-to-work-with" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
</section>
<section id="while-this-is-a-lower-level-intermediate-format-than-our-metadata">
<h1>While this is a lower level, intermediate format than our <code class="docutils literal notranslate"><span class="pre">Metadata</span></code><a class="headerlink" href="#while-this-is-a-lower-level-intermediate-format-than-our-metadata" title="Link to this heading"></a></h1>
</section>
<section id="class-some-light-touch-ups-can-make-a-massive-difference-in-usability">
<h1>class, some light touch ups can make a massive difference in usability.<a class="headerlink" href="#class-some-light-touch-ups-can-make-a-massive-difference-in-usability" title="Link to this heading"></a></h1>
</section>
<section id="map-metadata-fields-to-rawmetadata">
<h1>Map METADATA fields to RawMetadata.<a class="headerlink" href="#map-metadata-fields-to-rawmetadata" title="Link to this heading"></a></h1>
<p>_EMAIL_TO_RAW_MAPPING = {
“author”: “author”,
“author-email”: “author_email”,
“classifier”: “classifiers”,
“description”: “description”,
“description-content-type”: “description_content_type”,
“download-url”: “download_url”,
“dynamic”: “dynamic”,
“home-page”: “home_page”,
“keywords”: “keywords”,
“license”: “license”,
“license-expression”: “license_expression”,
“license-file”: “license_files”,
“maintainer”: “maintainer”,
“maintainer-email”: “maintainer_email”,
“metadata-version”: “metadata_version”,
“name”: “name”,
“obsoletes”: “obsoletes”,
“obsoletes-dist”: “obsoletes_dist”,
“platform”: “platforms”,
“project-url”: “project_urls”,
“provides”: “provides”,
“provides-dist”: “provides_dist”,
“provides-extra”: “provides_extra”,
“requires”: “requires”,
“requires-dist”: “requires_dist”,
“requires-external”: “requires_external”,
“requires-python”: “requires_python”,
“summary”: “summary”,
“supported-platform”: “supported_platforms”,
“version”: “version”,
}
_RAW_TO_EMAIL_MAPPING = {raw: email for email, raw in _EMAIL_TO_RAW_MAPPING.items()}</p>
<p>def parse_email(data: bytes | str) -&gt; tuple[RawMetadata, dict[str, list[str]]]:
“””Parse a distribution’s metadata stored as email headers (e.g. from <code class="docutils literal notranslate"><span class="pre">METADATA</span></code>).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This function returns a two-item tuple of dicts. The first dict is of
recognized fields from the core metadata specification. Fields that can be
parsed and translated into Python&#39;s built-in types are converted
appropriately. All other fields are left as-is. Fields that are allowed to
appear multiple times are stored as lists.

The second dict contains all other fields from the metadata. This includes
any unrecognized fields. It also includes any fields which are expected to
be parsed into a built-in type but were not formatted appropriately. Finally,
any fields that are expected to appear only once but are repeated are
included in this dict.

&quot;&quot;&quot;
raw: dict[str, str | list[str] | dict[str, str]] = {}
unparsed: dict[str, list[str]] = {}

if isinstance(data, str):
    parsed = email.parser.Parser(policy=email.policy.compat32).parsestr(data)
else:
    parsed = email.parser.BytesParser(policy=email.policy.compat32).parsebytes(data)

# We have to wrap parsed.keys() in a set, because in the case of multiple
# values for a key (a list), the key will appear multiple times in the
# list of keys, but we&#39;re avoiding that by using get_all().
for name in frozenset(parsed.keys()):
    # Header names in RFC are case insensitive, so we&#39;ll normalize to all
    # lower case to make comparisons easier.
    name = name.lower()

    # We use get_all() here, even for fields that aren&#39;t multiple use,
    # because otherwise someone could have e.g. two Name fields, and we
    # would just silently ignore it rather than doing something about it.
    headers = parsed.get_all(name) or []

    # The way the email module works when parsing bytes is that it
    # unconditionally decodes the bytes as ascii using the surrogateescape
    # handler. When you pull that data back out (such as with get_all() ),
    # it looks to see if the str has any surrogate escapes, and if it does
    # it wraps it in a Header object instead of returning the string.
    #
    # As such, we&#39;ll look for those Header objects, and fix up the encoding.
    value = []
    # Flag if we have run into any issues processing the headers, thus
    # signalling that the data belongs in &#39;unparsed&#39;.
    valid_encoding = True
    for h in headers:
        # It&#39;s unclear if this can return more types than just a Header or
        # a str, so we&#39;ll just assert here to make sure.
        assert isinstance(h, (email.header.Header, str))

        # If it&#39;s a header object, we need to do our little dance to get
        # the real data out of it. In cases where there is invalid data
        # we&#39;re going to end up with mojibake, but there&#39;s no obvious, good
        # way around that without reimplementing parts of the Header object
        # ourselves.
        #
        # That should be fine since, if mojibacked happens, this key is
        # going into the unparsed dict anyways.
        if isinstance(h, email.header.Header):
            # The Header object stores it&#39;s data as chunks, and each chunk
            # can be independently encoded, so we&#39;ll need to check each
            # of them.
            chunks: list[tuple[bytes, str | None]] = []
            for bin, encoding in email.header.decode_header(h):
                try:
                    bin.decode(&quot;utf8&quot;, &quot;strict&quot;)
                except UnicodeDecodeError:
                    # Enable mojibake.
                    encoding = &quot;latin1&quot;
                    valid_encoding = False
                else:
                    encoding = &quot;utf8&quot;
                chunks.append((bin, encoding))

            # Turn our chunks back into a Header object, then let that
            # Header object do the right thing to turn them into a
            # string for us.
            value.append(str(email.header.make_header(chunks)))
        # This is already a string, so just add it.
        else:
            value.append(h)

    # We&#39;ve processed all of our values to get them into a list of str,
    # but we may have mojibake data, in which case this is an unparsed
    # field.
    if not valid_encoding:
        unparsed[name] = value
        continue

    raw_name = _EMAIL_TO_RAW_MAPPING.get(name)
    if raw_name is None:
        # This is a bit of a weird situation, we&#39;ve encountered a key that
        # we don&#39;t know what it means, so we don&#39;t know whether it&#39;s meant
        # to be a list or not.
        #
        # Since we can&#39;t really tell one way or another, we&#39;ll just leave it
        # as a list, even though it may be a single item list, because that&#39;s
        # what makes the most sense for email headers.
        unparsed[name] = value
        continue

    # If this is one of our string fields, then we&#39;ll check to see if our
    # value is a list of a single item. If it is then we&#39;ll assume that
    # it was emitted as a single string, and unwrap the str from inside
    # the list.
    #
    # If it&#39;s any other kind of data, then we haven&#39;t the faintest clue
    # what we should parse it as, and we have to just add it to our list
    # of unparsed stuff.
    if raw_name in _STRING_FIELDS and len(value) == 1:
        raw[raw_name] = value[0]
    # If this is one of our list of string fields, then we can just assign
    # the value, since email *only* has strings, and our get_all() call
    # above ensures that this is a list.
    elif raw_name in _LIST_FIELDS:
        raw[raw_name] = value
    # Special Case: Keywords
    # The keywords field is implemented in the metadata spec as a str,
    # but it conceptually is a list of strings, and is serialized using
    # &quot;, &quot;.join(keywords), so we&#39;ll do some light data massaging to turn
    # this into what it logically is.
    elif raw_name == &quot;keywords&quot; and len(value) == 1:
        raw[raw_name] = _parse_keywords(value[0])
    # Special Case: Project-URL
    # The project urls is implemented in the metadata spec as a list of
    # specially-formatted strings that represent a key and a value, which
    # is fundamentally a mapping, however the email format doesn&#39;t support
    # mappings in a sane way, so it was crammed into a list of strings
    # instead.
    #
    # We will do a little light data massaging to turn this into a map as
    # it logically should be.
    elif raw_name == &quot;project_urls&quot;:
        try:
            raw[raw_name] = _parse_project_urls(value)
        except KeyError:
            unparsed[name] = value
    # Nothing that we&#39;ve done has managed to parse this, so it&#39;ll just
    # throw it in our unparseable data and move on.
    else:
        unparsed[name] = value

# We need to support getting the Description from the message payload in
# addition to getting it from the the headers. This does mean, though, there
# is the possibility of it being set both ways, in which case we put both
# in &#39;unparsed&#39; since we don&#39;t know which is right.
try:
    payload = _get_payload(parsed, data)
except ValueError:
    unparsed.setdefault(&quot;description&quot;, []).append(
        parsed.get_payload(decode=isinstance(data, bytes))  # type: ignore[call-overload]
    )
else:
    if payload:
        # Check to see if we&#39;ve already got a description, if so then both
        # it, and this body move to unparseable.
        if &quot;description&quot; in raw:
            description_header = cast(str, raw.pop(&quot;description&quot;))
            unparsed.setdefault(&quot;description&quot;, []).extend(
                [description_header, payload]
            )
        elif &quot;description&quot; in unparsed:
            unparsed[&quot;description&quot;].append(payload)
        else:
            raw[&quot;description&quot;] = payload

# We need to cast our `raw` to a metadata, because a TypedDict only support
# literal key names, but we&#39;re computing our key names on purpose, but the
# way this function is implemented, our `TypedDict` can only have valid key
# names.
return cast(RawMetadata, raw), unparsed
</pre></div>
</div>
<p>_NOT_FOUND = object()</p>
</section>
<section id="keep-the-two-values-in-sync">
<h1>Keep the two values in sync.<a class="headerlink" href="#keep-the-two-values-in-sync" title="Link to this heading"></a></h1>
<p>_VALID_METADATA_VERSIONS = [“1.0”, “1.1”, “1.2”, “2.1”, “2.2”, “2.3”, “2.4”]
_MetadataVersion = Literal[“1.0”, “1.1”, “1.2”, “2.1”, “2.2”, “2.3”, “2.4”]</p>
<p>_REQUIRED_ATTRS = frozenset([“metadata_version”, “name”, “version”])</p>
<p>class _Validator(Generic[T]):
“””Validate a metadata field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>All _process_*() methods correspond to a core metadata field. The method is
called with the field&#39;s raw value. If the raw value is valid it is returned
in its &quot;enriched&quot; form (e.g. ``version.Version`` for the ``Version`` field).
If the raw value is invalid, :exc:`InvalidMetadata` is raised (with a cause
as appropriate).
&quot;&quot;&quot;

name: str
raw_name: str
added: _MetadataVersion

def __init__(
    self,
    *,
    added: _MetadataVersion = &quot;1.0&quot;,
) -&gt; None:
    self.added = added

def __set_name__(self, _owner: Metadata, name: str) -&gt; None:
    self.name = name
    self.raw_name = _RAW_TO_EMAIL_MAPPING[name]

def __get__(self, instance: Metadata, _owner: type[Metadata]) -&gt; T:
    # With Python 3.8, the caching can be replaced with functools.cached_property().
    # No need to check the cache as attribute lookup will resolve into the
    # instance&#39;s __dict__ before __get__ is called.
    cache = instance.__dict__
    value = instance._raw.get(self.name)

    # To make the _process_* methods easier, we&#39;ll check if the value is None
    # and if this field is NOT a required attribute, and if both of those
    # things are true, we&#39;ll skip the the converter. This will mean that the
    # converters never have to deal with the None union.
    if self.name in _REQUIRED_ATTRS or value is not None:
        try:
            converter: Callable[[Any], T] = getattr(self, f&quot;_process_{self.name}&quot;)
        except AttributeError:
            pass
        else:
            value = converter(value)

    cache[self.name] = value
    try:
        del instance._raw[self.name]  # type: ignore[misc]
    except KeyError:
        pass

    return cast(T, value)

def _invalid_metadata(
    self, msg: str, cause: Exception | None = None
) -&gt; InvalidMetadata:
    exc = InvalidMetadata(
        self.raw_name, msg.format_map({&quot;field&quot;: repr(self.raw_name)})
    )
    exc.__cause__ = cause
    return exc

def _process_metadata_version(self, value: str) -&gt; _MetadataVersion:
    # Implicitly makes Metadata-Version required.
    if value not in _VALID_METADATA_VERSIONS:
        raise self._invalid_metadata(f&quot;{value!r} is not a valid metadata version&quot;)
    return cast(_MetadataVersion, value)

def _process_name(self, value: str) -&gt; str:
    if not value:
        raise self._invalid_metadata(&quot;{field} is a required field&quot;)
    # Validate the name as a side-effect.
    try:
        utils.canonicalize_name(value, validate=True)
    except utils.InvalidName as exc:
        raise self._invalid_metadata(
            f&quot;{value!r} is invalid for {{field}}&quot;, cause=exc
        ) from exc
    else:
        return value

def _process_version(self, value: str) -&gt; version_module.Version:
    if not value:
        raise self._invalid_metadata(&quot;{field} is a required field&quot;)
    try:
        return version_module.parse(value)
    except version_module.InvalidVersion as exc:
        raise self._invalid_metadata(
            f&quot;{value!r} is invalid for {{field}}&quot;, cause=exc
        ) from exc

def _process_summary(self, value: str) -&gt; str:
    &quot;&quot;&quot;Check the field contains no newlines.&quot;&quot;&quot;
    if &quot;\n&quot; in value:
        raise self._invalid_metadata(&quot;{field} must be a single line&quot;)
    return value

def _process_description_content_type(self, value: str) -&gt; str:
    content_types = {&quot;text/plain&quot;, &quot;text/x-rst&quot;, &quot;text/markdown&quot;}
    message = email.message.EmailMessage()
    message[&quot;content-type&quot;] = value

    content_type, parameters = (
        # Defaults to `text/plain` if parsing failed.
        message.get_content_type().lower(),
        message[&quot;content-type&quot;].params,
    )
    # Check if content-type is valid or defaulted to `text/plain` and thus was
    # not parseable.
    if content_type not in content_types or content_type not in value.lower():
        raise self._invalid_metadata(
            f&quot;{{field}} must be one of {list(content_types)}, not {value!r}&quot;
        )

    charset = parameters.get(&quot;charset&quot;, &quot;UTF-8&quot;)
    if charset != &quot;UTF-8&quot;:
        raise self._invalid_metadata(
            f&quot;{{field}} can only specify the UTF-8 charset, not {list(charset)}&quot;
        )

    markdown_variants = {&quot;GFM&quot;, &quot;CommonMark&quot;}
    variant = parameters.get(&quot;variant&quot;, &quot;GFM&quot;)  # Use an acceptable default.
    if content_type == &quot;text/markdown&quot; and variant not in markdown_variants:
        raise self._invalid_metadata(
            f&quot;valid Markdown variants for {{field}} are {list(markdown_variants)}, &quot;
            f&quot;not {variant!r}&quot;,
        )
    return value

def _process_dynamic(self, value: list[str]) -&gt; list[str]:
    for dynamic_field in map(str.lower, value):
        if dynamic_field in {&quot;name&quot;, &quot;version&quot;, &quot;metadata-version&quot;}:
            raise self._invalid_metadata(
                f&quot;{dynamic_field!r} is not allowed as a dynamic field&quot;
            )
        elif dynamic_field not in _EMAIL_TO_RAW_MAPPING:
            raise self._invalid_metadata(
                f&quot;{dynamic_field!r} is not a valid dynamic field&quot;
            )
    return list(map(str.lower, value))

def _process_provides_extra(
    self,
    value: list[str],
) -&gt; list[utils.NormalizedName]:
    normalized_names = []
    try:
        for name in value:
            normalized_names.append(utils.canonicalize_name(name, validate=True))
    except utils.InvalidName as exc:
        raise self._invalid_metadata(
            f&quot;{name!r} is invalid for {{field}}&quot;, cause=exc
        ) from exc
    else:
        return normalized_names

def _process_requires_python(self, value: str) -&gt; specifiers.SpecifierSet:
    try:
        return specifiers.SpecifierSet(value)
    except specifiers.InvalidSpecifier as exc:
        raise self._invalid_metadata(
            f&quot;{value!r} is invalid for {{field}}&quot;, cause=exc
        ) from exc

def _process_requires_dist(
    self,
    value: list[str],
) -&gt; list[requirements.Requirement]:
    reqs = []
    try:
        for req in value:
            reqs.append(requirements.Requirement(req))
    except requirements.InvalidRequirement as exc:
        raise self._invalid_metadata(
            f&quot;{req!r} is invalid for {{field}}&quot;, cause=exc
        ) from exc
    else:
        return reqs

def _process_license_expression(
    self, value: str
) -&gt; NormalizedLicenseExpression | None:
    try:
        return licenses.canonicalize_license_expression(value)
    except ValueError as exc:
        raise self._invalid_metadata(
            f&quot;{value!r} is invalid for {{field}}&quot;, cause=exc
        ) from exc

def _process_license_files(self, value: list[str]) -&gt; list[str]:
    paths = []
    for path in value:
        if &quot;..&quot; in path:
            raise self._invalid_metadata(
                f&quot;{path!r} is invalid for {{field}}, &quot;
                &quot;parent directory indicators are not allowed&quot;
            )
        if &quot;*&quot; in path:
            raise self._invalid_metadata(
                f&quot;{path!r} is invalid for {{field}}, paths must be resolved&quot;
            )
        if (
            pathlib.PurePosixPath(path).is_absolute()
            or pathlib.PureWindowsPath(path).is_absolute()
        ):
            raise self._invalid_metadata(
                f&quot;{path!r} is invalid for {{field}}, paths must be relative&quot;
            )
        if pathlib.PureWindowsPath(path).as_posix() != path:
            raise self._invalid_metadata(
                f&quot;{path!r} is invalid for {{field}}, paths must use &#39;/&#39; delimiter&quot;
            )
        paths.append(path)
    return paths
</pre></div>
</div>
<p>class Metadata:
“””Representation of distribution metadata.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Compared to :class:`RawMetadata`, this class provides objects representing
metadata fields instead of only using built-in types. Any invalid metadata
will cause :exc:`InvalidMetadata` to be raised (with a
:py:attr:`~BaseException.__cause__` attribute as appropriate).
&quot;&quot;&quot;

_raw: RawMetadata

@classmethod
def from_raw(cls, data: RawMetadata, *, validate: bool = True) -&gt; Metadata:
    &quot;&quot;&quot;Create an instance from :class:`RawMetadata`.

    If *validate* is true, all metadata will be validated. All exceptions
    related to validation will be gathered and raised as an :class:`ExceptionGroup`.
    &quot;&quot;&quot;
    ins = cls()
    ins._raw = data.copy()  # Mutations occur due to caching enriched values.

    if validate:
        exceptions: list[Exception] = []
        try:
            metadata_version = ins.metadata_version
            metadata_age = _VALID_METADATA_VERSIONS.index(metadata_version)
        except InvalidMetadata as metadata_version_exc:
            exceptions.append(metadata_version_exc)
            metadata_version = None

        # Make sure to check for the fields that are present, the required
        # fields (so their absence can be reported).
        fields_to_check = frozenset(ins._raw) | _REQUIRED_ATTRS
        # Remove fields that have already been checked.
        fields_to_check -= {&quot;metadata_version&quot;}

        for key in fields_to_check:
            try:
                if metadata_version:
                    # Can&#39;t use getattr() as that triggers descriptor protocol which
                    # will fail due to no value for the instance argument.
                    try:
                        field_metadata_version = cls.__dict__[key].added
                    except KeyError:
                        exc = InvalidMetadata(key, f&quot;unrecognized field: {key!r}&quot;)
                        exceptions.append(exc)
                        continue
                    field_age = _VALID_METADATA_VERSIONS.index(
                        field_metadata_version
                    )
                    if field_age &gt; metadata_age:
                        field = _RAW_TO_EMAIL_MAPPING[key]
                        exc = InvalidMetadata(
                            field,
                            f&quot;{field} introduced in metadata version &quot;
                            f&quot;{field_metadata_version}, not {metadata_version}&quot;,
                        )
                        exceptions.append(exc)
                        continue
                getattr(ins, key)
            except InvalidMetadata as exc:
                exceptions.append(exc)

        if exceptions:
            raise ExceptionGroup(&quot;invalid metadata&quot;, exceptions)

    return ins

@classmethod
def from_email(cls, data: bytes | str, *, validate: bool = True) -&gt; Metadata:
    &quot;&quot;&quot;Parse metadata from email headers.

    If *validate* is true, the metadata will be validated. All exceptions
    related to validation will be gathered and raised as an :class:`ExceptionGroup`.
    &quot;&quot;&quot;
    raw, unparsed = parse_email(data)

    if validate:
        exceptions: list[Exception] = []
        for unparsed_key in unparsed:
            if unparsed_key in _EMAIL_TO_RAW_MAPPING:
                message = f&quot;{unparsed_key!r} has invalid data&quot;
            else:
                message = f&quot;unrecognized field: {unparsed_key!r}&quot;
            exceptions.append(InvalidMetadata(unparsed_key, message))

        if exceptions:
            raise ExceptionGroup(&quot;unparsed&quot;, exceptions)

    try:
        return cls.from_raw(raw, validate=validate)
    except ExceptionGroup as exc_group:
        raise ExceptionGroup(
            &quot;invalid or unparsed metadata&quot;, exc_group.exceptions
        ) from None

metadata_version: _Validator[_MetadataVersion] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-metadata-version`
(required; validated to be a valid metadata version)&quot;&quot;&quot;
# `name` is not normalized/typed to NormalizedName so as to provide access to
# the original/raw name.
name: _Validator[str] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-name`
(required; validated using :func:`~packaging.utils.canonicalize_name` and its
*validate* parameter)&quot;&quot;&quot;
version: _Validator[version_module.Version] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-version` (required)&quot;&quot;&quot;
dynamic: _Validator[list[str] | None] = _Validator(
    added=&quot;2.2&quot;,
)
&quot;&quot;&quot;:external:ref:`core-metadata-dynamic`
(validated against core metadata field names and lowercased)&quot;&quot;&quot;
platforms: _Validator[list[str] | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-platform`&quot;&quot;&quot;
supported_platforms: _Validator[list[str] | None] = _Validator(added=&quot;1.1&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-supported-platform`&quot;&quot;&quot;
summary: _Validator[str | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-summary` (validated to contain no newlines)&quot;&quot;&quot;
description: _Validator[str | None] = _Validator()  # TODO 2.1: can be in body
&quot;&quot;&quot;:external:ref:`core-metadata-description`&quot;&quot;&quot;
description_content_type: _Validator[str | None] = _Validator(added=&quot;2.1&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-description-content-type` (validated)&quot;&quot;&quot;
keywords: _Validator[list[str] | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-keywords`&quot;&quot;&quot;
home_page: _Validator[str | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-home-page`&quot;&quot;&quot;
download_url: _Validator[str | None] = _Validator(added=&quot;1.1&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-download-url`&quot;&quot;&quot;
author: _Validator[str | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-author`&quot;&quot;&quot;
author_email: _Validator[str | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-author-email`&quot;&quot;&quot;
maintainer: _Validator[str | None] = _Validator(added=&quot;1.2&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-maintainer`&quot;&quot;&quot;
maintainer_email: _Validator[str | None] = _Validator(added=&quot;1.2&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-maintainer-email`&quot;&quot;&quot;
license: _Validator[str | None] = _Validator()
&quot;&quot;&quot;:external:ref:`core-metadata-license`&quot;&quot;&quot;
license_expression: _Validator[NormalizedLicenseExpression | None] = _Validator(
    added=&quot;2.4&quot;
)
&quot;&quot;&quot;:external:ref:`core-metadata-license-expression`&quot;&quot;&quot;
license_files: _Validator[list[str] | None] = _Validator(added=&quot;2.4&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-license-file`&quot;&quot;&quot;
classifiers: _Validator[list[str] | None] = _Validator(added=&quot;1.1&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-classifier`&quot;&quot;&quot;
requires_dist: _Validator[list[requirements.Requirement] | None] = _Validator(
    added=&quot;1.2&quot;
)
&quot;&quot;&quot;:external:ref:`core-metadata-requires-dist`&quot;&quot;&quot;
requires_python: _Validator[specifiers.SpecifierSet | None] = _Validator(
    added=&quot;1.2&quot;
)
&quot;&quot;&quot;:external:ref:`core-metadata-requires-python`&quot;&quot;&quot;
# Because `Requires-External` allows for non-PEP 440 version specifiers, we
# don&#39;t do any processing on the values.
requires_external: _Validator[list[str] | None] = _Validator(added=&quot;1.2&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-requires-external`&quot;&quot;&quot;
project_urls: _Validator[dict[str, str] | None] = _Validator(added=&quot;1.2&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-project-url`&quot;&quot;&quot;
# PEP 685 lets us raise an error if an extra doesn&#39;t pass `Name` validation
# regardless of metadata version.
provides_extra: _Validator[list[utils.NormalizedName] | None] = _Validator(
    added=&quot;2.1&quot;,
)
&quot;&quot;&quot;:external:ref:`core-metadata-provides-extra`&quot;&quot;&quot;
provides_dist: _Validator[list[str] | None] = _Validator(added=&quot;1.2&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-provides-dist`&quot;&quot;&quot;
obsoletes_dist: _Validator[list[str] | None] = _Validator(added=&quot;1.2&quot;)
&quot;&quot;&quot;:external:ref:`core-metadata-obsoletes-dist`&quot;&quot;&quot;
requires: _Validator[list[str] | None] = _Validator(added=&quot;1.1&quot;)
&quot;&quot;&quot;``Requires`` (deprecated)&quot;&quot;&quot;
provides: _Validator[list[str] | None] = _Validator(added=&quot;1.1&quot;)
&quot;&quot;&quot;``Provides`` (deprecated)&quot;&quot;&quot;
obsoletes: _Validator[list[str] | None] = _Validator(added=&quot;1.1&quot;)
&quot;&quot;&quot;``Obsoletes`` (deprecated)&quot;&quot;&quot;
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>