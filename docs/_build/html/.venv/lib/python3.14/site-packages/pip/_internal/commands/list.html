

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/commands/list.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import json
import logging
from collections.abc import Generator, Sequence
from email.parser import Parser
from optparse import Values
from typing import TYPE_CHECKING, cast</p>
<p>from pip._vendor.packaging.utils import canonicalize_name
from pip._vendor.packaging.version import InvalidVersion, Version</p>
<p>from pip._internal.cli import cmdoptions
from pip._internal.cli.index_command import IndexGroupCommand
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError
from pip._internal.metadata import BaseDistribution, get_environment
from pip._internal.models.selection_prefs import SelectionPreferences
from pip._internal.utils.compat import stdlib_pkgs
from pip._internal.utils.misc import tabulate, write_output</p>
<p>if TYPE_CHECKING:
from pip._internal.index.package_finder import PackageFinder
from pip._internal.network.session import PipSession</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>class _DistWithLatestInfo(BaseDistribution):
    &quot;&quot;&quot;Give the distribution object a couple of extra fields.

    These will be populated during ``get_outdated()``. This is dirty but
    makes the rest of the code much cleaner.
    &quot;&quot;&quot;

    latest_version: Version
    latest_filetype: str

_ProcessedDists = Sequence[_DistWithLatestInfo]
</pre></div>
</div>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>class ListCommand(IndexGroupCommand):
“””
List installed packages, including editables.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Packages are listed in a case-insensitive sorted order.
&quot;&quot;&quot;

ignore_require_venv = True
usage = &quot;&quot;&quot;
  %prog [options]&quot;&quot;&quot;

def add_options(self) -&gt; None:
    self.cmd_opts.add_option(
        &quot;-o&quot;,
        &quot;--outdated&quot;,
        action=&quot;store_true&quot;,
        default=False,
        help=&quot;List outdated packages&quot;,
    )
    self.cmd_opts.add_option(
        &quot;-u&quot;,
        &quot;--uptodate&quot;,
        action=&quot;store_true&quot;,
        default=False,
        help=&quot;List uptodate packages&quot;,
    )
    self.cmd_opts.add_option(
        &quot;-e&quot;,
        &quot;--editable&quot;,
        action=&quot;store_true&quot;,
        default=False,
        help=&quot;List editable projects.&quot;,
    )
    self.cmd_opts.add_option(
        &quot;-l&quot;,
        &quot;--local&quot;,
        action=&quot;store_true&quot;,
        default=False,
        help=(
            &quot;If in a virtualenv that has global access, do not list &quot;
            &quot;globally-installed packages.&quot;
        ),
    )
    self.cmd_opts.add_option(
        &quot;--user&quot;,
        dest=&quot;user&quot;,
        action=&quot;store_true&quot;,
        default=False,
        help=&quot;Only output packages installed in user-site.&quot;,
    )
    self.cmd_opts.add_option(cmdoptions.list_path())
    self.cmd_opts.add_option(
        &quot;--pre&quot;,
        action=&quot;store_true&quot;,
        default=False,
        help=(
            &quot;Include pre-release and development versions. By default, &quot;
            &quot;pip only finds stable versions.&quot;
        ),
    )

    self.cmd_opts.add_option(
        &quot;--format&quot;,
        action=&quot;store&quot;,
        dest=&quot;list_format&quot;,
        default=&quot;columns&quot;,
        choices=(&quot;columns&quot;, &quot;freeze&quot;, &quot;json&quot;),
        help=(
            &quot;Select the output format among: columns (default), freeze, or json. &quot;
            &quot;The &#39;freeze&#39; format cannot be used with the --outdated option.&quot;
        ),
    )

    self.cmd_opts.add_option(
        &quot;--not-required&quot;,
        action=&quot;store_true&quot;,
        dest=&quot;not_required&quot;,
        help=&quot;List packages that are not dependencies of installed packages.&quot;,
    )

    self.cmd_opts.add_option(
        &quot;--exclude-editable&quot;,
        action=&quot;store_false&quot;,
        dest=&quot;include_editable&quot;,
        help=&quot;Exclude editable package from output.&quot;,
    )
    self.cmd_opts.add_option(
        &quot;--include-editable&quot;,
        action=&quot;store_true&quot;,
        dest=&quot;include_editable&quot;,
        help=&quot;Include editable package in output.&quot;,
        default=True,
    )
    self.cmd_opts.add_option(cmdoptions.list_exclude())
    index_opts = cmdoptions.make_option_group(cmdoptions.index_group, self.parser)

    self.parser.insert_option_group(0, index_opts)
    self.parser.insert_option_group(0, self.cmd_opts)

def handle_pip_version_check(self, options: Values) -&gt; None:
    if options.outdated or options.uptodate:
        super().handle_pip_version_check(options)

def _build_package_finder(
    self, options: Values, session: PipSession
) -&gt; PackageFinder:
    &quot;&quot;&quot;
    Create a package finder appropriate to this list command.
    &quot;&quot;&quot;
    # Lazy import the heavy index modules as most list invocations won&#39;t need &#39;em.
    from pip._internal.index.collector import LinkCollector
    from pip._internal.index.package_finder import PackageFinder

    link_collector = LinkCollector.create(session, options=options)

    # Pass allow_yanked=False to ignore yanked versions.
    selection_prefs = SelectionPreferences(
        allow_yanked=False,
        allow_all_prereleases=options.pre,
    )

    return PackageFinder.create(
        link_collector=link_collector,
        selection_prefs=selection_prefs,
    )

def run(self, options: Values, args: list[str]) -&gt; int:
    if options.outdated and options.uptodate:
        raise CommandError(&quot;Options --outdated and --uptodate cannot be combined.&quot;)

    if options.outdated and options.list_format == &quot;freeze&quot;:
        raise CommandError(
            &quot;List format &#39;freeze&#39; cannot be used with the --outdated option.&quot;
        )

    cmdoptions.check_list_path_option(options)

    skip = set(stdlib_pkgs)
    if options.excludes:
        skip.update(canonicalize_name(n) for n in options.excludes)

    packages: _ProcessedDists = [
        cast(&quot;_DistWithLatestInfo&quot;, d)
        for d in get_environment(options.path).iter_installed_distributions(
            local_only=options.local,
            user_only=options.user,
            editables_only=options.editable,
            include_editables=options.include_editable,
            skip=skip,
        )
    ]

    # get_not_required must be called firstly in order to find and
    # filter out all dependencies correctly. Otherwise a package
    # can&#39;t be identified as requirement because some parent packages
    # could be filtered out before.
    if options.not_required:
        packages = self.get_not_required(packages, options)

    if options.outdated:
        packages = self.get_outdated(packages, options)
    elif options.uptodate:
        packages = self.get_uptodate(packages, options)

    self.output_package_listing(packages, options)
    return SUCCESS

def get_outdated(
    self, packages: _ProcessedDists, options: Values
) -&gt; _ProcessedDists:
    return [
        dist
        for dist in self.iter_packages_latest_infos(packages, options)
        if dist.latest_version &gt; dist.version
    ]

def get_uptodate(
    self, packages: _ProcessedDists, options: Values
) -&gt; _ProcessedDists:
    return [
        dist
        for dist in self.iter_packages_latest_infos(packages, options)
        if dist.latest_version == dist.version
    ]

def get_not_required(
    self, packages: _ProcessedDists, options: Values
) -&gt; _ProcessedDists:
    dep_keys = {
        canonicalize_name(dep.name)
        for dist in packages
        for dep in (dist.iter_dependencies() or ())
    }

    # Create a set to remove duplicate packages, and cast it to a list
    # to keep the return type consistent with get_outdated and
    # get_uptodate
    return list({pkg for pkg in packages if pkg.canonical_name not in dep_keys})

def iter_packages_latest_infos(
    self, packages: _ProcessedDists, options: Values
) -&gt; Generator[_DistWithLatestInfo, None, None]:
    with self._build_session(options) as session:
        finder = self._build_package_finder(options, session)

        def latest_info(
            dist: _DistWithLatestInfo,
        ) -&gt; _DistWithLatestInfo | None:
            all_candidates = finder.find_all_candidates(dist.canonical_name)
            if not options.pre:
                # Remove prereleases
                all_candidates = [
                    candidate
                    for candidate in all_candidates
                    if not candidate.version.is_prerelease
                ]

            evaluator = finder.make_candidate_evaluator(
                project_name=dist.canonical_name,
            )
            best_candidate = evaluator.sort_best_candidate(all_candidates)
            if best_candidate is None:
                return None

            remote_version = best_candidate.version
            if best_candidate.link.is_wheel:
                typ = &quot;wheel&quot;
            else:
                typ = &quot;sdist&quot;
            dist.latest_version = remote_version
            dist.latest_filetype = typ
            return dist

        for dist in map(latest_info, packages):
            if dist is not None:
                yield dist

def output_package_listing(
    self, packages: _ProcessedDists, options: Values
) -&gt; None:
    packages = sorted(
        packages,
        key=lambda dist: dist.canonical_name,
    )
    if options.list_format == &quot;columns&quot; and packages:
        data, header = format_for_columns(packages, options)
        self.output_package_listing_columns(data, header)
    elif options.list_format == &quot;freeze&quot;:
        for dist in packages:
            try:
                req_string = f&quot;{dist.raw_name}=={dist.version}&quot;
            except InvalidVersion:
                req_string = f&quot;{dist.raw_name}==={dist.raw_version}&quot;
            if options.verbose &gt;= 1:
                write_output(&quot;%s (%s)&quot;, req_string, dist.location)
            else:
                write_output(req_string)
    elif options.list_format == &quot;json&quot;:
        write_output(format_for_json(packages, options))

def output_package_listing_columns(
    self, data: list[list[str]], header: list[str]
) -&gt; None:
    # insert the header first: we need to know the size of column names
    if len(data) &gt; 0:
        data.insert(0, header)

    pkg_strings, sizes = tabulate(data)

    # Create and add a separator.
    if len(data) &gt; 0:
        pkg_strings.insert(1, &quot; &quot;.join(&quot;-&quot; * x for x in sizes))

    for val in pkg_strings:
        write_output(val)
</pre></div>
</div>
<p>def format_for_columns(
pkgs: _ProcessedDists, options: Values
) -&gt; tuple[list[list[str]], list[str]]:
“””
Convert the package data into something usable
by output_package_listing_columns.
“””
header = [“Package”, “Version”]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>running_outdated = options.outdated
if running_outdated:
    header.extend([&quot;Latest&quot;, &quot;Type&quot;])

def wheel_build_tag(dist: BaseDistribution) -&gt; str | None:
    try:
        wheel_file = dist.read_text(&quot;WHEEL&quot;)
    except FileNotFoundError:
        return None
    return Parser().parsestr(wheel_file).get(&quot;Build&quot;)

build_tags = [wheel_build_tag(p) for p in pkgs]
has_build_tags = any(build_tags)
if has_build_tags:
    header.append(&quot;Build&quot;)

if options.verbose &gt;= 1:
    header.append(&quot;Location&quot;)
if options.verbose &gt;= 1:
    header.append(&quot;Installer&quot;)

has_editables = any(x.editable for x in pkgs)
if has_editables:
    header.append(&quot;Editable project location&quot;)

data = []
for i, proj in enumerate(pkgs):
    # if we&#39;re working on the &#39;outdated&#39; list, separate out the
    # latest_version and type
    row = [proj.raw_name, proj.raw_version]

    if running_outdated:
        row.append(str(proj.latest_version))
        row.append(proj.latest_filetype)

    if has_build_tags:
        row.append(build_tags[i] or &quot;&quot;)

    if has_editables:
        row.append(proj.editable_project_location or &quot;&quot;)

    if options.verbose &gt;= 1:
        row.append(proj.location or &quot;&quot;)
    if options.verbose &gt;= 1:
        row.append(proj.installer)

    data.append(row)

return data, header
</pre></div>
</div>
<p>def format_for_json(packages: _ProcessedDists, options: Values) -&gt; str:
data = []
for dist in packages:
try:
version = str(dist.version)
except InvalidVersion:
version = dist.raw_version
info = {
“name”: dist.raw_name,
“version”: version,
}
if options.verbose &gt;= 1:
info[“location”] = dist.location or “”
info[“installer”] = dist.installer
if options.outdated:
info[“latest_version”] = str(dist.latest_version)
info[“latest_filetype”] = dist.latest_filetype
editable_project_location = dist.editable_project_location
if editable_project_location:
info[“editable_project_location”] = editable_project_location
data.append(info)
return json.dumps(data)</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>