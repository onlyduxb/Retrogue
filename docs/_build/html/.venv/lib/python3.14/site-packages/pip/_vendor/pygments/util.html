

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/pygments/util.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””
pygments.util
~~~~~~~~~~~~~</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Utility functions.

:copyright: Copyright 2006-2025 by the Pygments team, see AUTHORS.
:license: BSD, see LICENSE for details.
</pre></div>
</div>
<p>“””</p>
<p>import re
from io import TextIOWrapper</p>
<p>split_path_re = re.compile(r’[/\ ]’)
doctype_lookup_re = re.compile(r’’’
&lt;!DOCTYPE\s+(
[a-zA-Z_][a-zA-Z0-9]*
(?: \s+      # optional in HTML5
[a-zA-Z_][a-zA-Z0-9]<em>\s+
“<a href="#id5"><span class="problematic" id="id1">[^&quot;]</span></a></em>”)?
)
<a href="#id6"><span class="problematic" id="id2">[^&gt;]</span></a><em>&gt;
‘’’, re.DOTALL | re.MULTILINE | re.VERBOSE)
tag_re = re.compile(r’&lt;(.+?)(\s.</em>?)?&gt;.<em>?&lt;/.+?&gt;’,
re.IGNORECASE | re.DOTALL | re.MULTILINE)
xml_decl_re = re.compile(r’\s</em>&lt;?xml<a href="#id7"><span class="problematic" id="id3">[^&gt;]</span></a>*?&gt;’, re.I)</p>
<p>class ClassNotFound(ValueError):
“””Raised if one of the lookup functions didn’t find a matching class.”””</p>
<p>class OptionError(Exception):
“””
This exception will be raised by all option processing functions if
the type or value of the argument is not correct.
“””</p>
<p>def get_choice_opt(options, optname, allowed, default=None, normcase=False):
“””
If the key <code class="docutils literal notranslate"><span class="pre">optname</span></code> from the dictionary is not in the sequence
<code class="docutils literal notranslate"><span class="pre">allowed</span></code>, raise an error, otherwise return it.
“””
string = options.get(optname, default)
if normcase:
string = string.lower()
if string not in allowed:
raise OptionError(‘Value for option {} must be one of {}’.format(optname, ‘, ‘.join(map(str, allowed))))
return string</p>
<p>def get_bool_opt(options, optname, default=None):
“””
Intuitively, this is <code class="docutils literal notranslate"><span class="pre">options.get(optname,</span> <span class="pre">default)</span></code>, but restricted to
Boolean value. The Booleans can be represented as string, in order to accept
Boolean value from the command line arguments. If the key <code class="docutils literal notranslate"><span class="pre">optname</span></code> is
present in the dictionary <code class="docutils literal notranslate"><span class="pre">options</span></code> and is not associated with a Boolean,
raise an <code class="docutils literal notranslate"><span class="pre">OptionError</span></code>. If it is absent, <code class="docutils literal notranslate"><span class="pre">default</span></code> is returned instead.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The valid string values for ``True`` are ``1``, ``yes``, ``true`` and
``on``, the ones for ``False`` are ``0``, ``no``, ``false`` and ``off``
(matched case-insensitively).
&quot;&quot;&quot;
string = options.get(optname, default)
if isinstance(string, bool):
    return string
elif isinstance(string, int):
    return bool(string)
elif not isinstance(string, str):
    raise OptionError(f&#39;Invalid type {string!r} for option {optname}; use &#39;
                      &#39;1/0, yes/no, true/false, on/off&#39;)
elif string.lower() in (&#39;1&#39;, &#39;yes&#39;, &#39;true&#39;, &#39;on&#39;):
    return True
elif string.lower() in (&#39;0&#39;, &#39;no&#39;, &#39;false&#39;, &#39;off&#39;):
    return False
else:
    raise OptionError(f&#39;Invalid value {string!r} for option {optname}; use &#39;
                      &#39;1/0, yes/no, true/false, on/off&#39;)
</pre></div>
</div>
<p>def get_int_opt(options, optname, default=None):
“””As :func:<code class="docutils literal notranslate"><span class="pre">get_bool_opt</span></code>, but interpret the value as an integer.”””
string = options.get(optname, default)
try:
return int(string)
except TypeError:
raise OptionError(f’Invalid type {string!r} for option {optname}; you ‘
‘must give an integer value’)
except ValueError:
raise OptionError(f’Invalid value {string!r} for option {optname}; you ‘
‘must give an integer value’)</p>
<p>def get_list_opt(options, optname, default=None):
“””
If the key <code class="docutils literal notranslate"><span class="pre">optname</span></code> from the dictionary <code class="docutils literal notranslate"><span class="pre">options</span></code> is a string,
split it at whitespace and return it. If it is already a list
or a tuple, it is returned as a list.
“””
val = options.get(optname, default)
if isinstance(val, str):
return val.split()
elif isinstance(val, (list, tuple)):
return list(val)
else:
raise OptionError(f’Invalid type {val!r} for option {optname}; you ‘
‘must give a list value’)</p>
<p>def docstring_headline(obj):
if not obj.<strong>doc</strong>:
return ‘’
res = []
for line in obj.<strong>doc</strong>.strip().splitlines():
if line.strip():
res.append(” “ + line.strip())
else:
break
return ‘’.join(res).lstrip()</p>
<p>def make_analysator(f):
“””Return a static text analyser function that returns float values.”””
def text_analyse(text):
try:
rv = f(text)
except Exception:
return 0.0
if not rv:
return 0.0
try:
return min(1.0, max(0.0, float(rv)))
except (ValueError, TypeError):
return 0.0
text_analyse.<strong>doc</strong> = f.<strong>doc</strong>
return staticmethod(text_analyse)</p>
<p>def shebang_matches(text, regex):
r”””Check if the given regular expression matches the last part of the
shebang if one exists.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    &gt;&gt;&gt; from pygments.util import shebang_matches
    &gt;&gt;&gt; shebang_matches(&#39;#!/usr/bin/env python&#39;, r&#39;python(2\.\d)?&#39;)
    True
    &gt;&gt;&gt; shebang_matches(&#39;#!/usr/bin/python2.4&#39;, r&#39;python(2\.\d)?&#39;)
    True
    &gt;&gt;&gt; shebang_matches(&#39;#!/usr/bin/python-ruby&#39;, r&#39;python(2\.\d)?&#39;)
    False
    &gt;&gt;&gt; shebang_matches(&#39;#!/usr/bin/python/ruby&#39;, r&#39;python(2\.\d)?&#39;)
    False
    &gt;&gt;&gt; shebang_matches(&#39;#!/usr/bin/startsomethingwith python&#39;,
    ...                 r&#39;python(2\.\d)?&#39;)
    True

It also checks for common windows executable file extensions::

    &gt;&gt;&gt; shebang_matches(&#39;#!C:\\Python2.4\\Python.exe&#39;, r&#39;python(2\.\d)?&#39;)
    True

Parameters (``&#39;-f&#39;`` or ``&#39;--foo&#39;`` are ignored so ``&#39;perl&#39;`` does
the same as ``&#39;perl -e&#39;``)

Note that this method automatically searches the whole string (eg:
the regular expression is wrapped in ``&#39;^$&#39;``)
&quot;&quot;&quot;
index = text.find(&#39;\n&#39;)
if index &gt;= 0:
    first_line = text[:index].lower()
else:
    first_line = text.lower()
if first_line.startswith(&#39;#!&#39;):
    try:
        found = [x for x in split_path_re.split(first_line[2:].strip())
                 if x and not x.startswith(&#39;-&#39;)][-1]
    except IndexError:
        return False
    regex = re.compile(rf&#39;^{regex}(\.(exe|cmd|bat|bin))?$&#39;, re.IGNORECASE)
    if regex.search(found) is not None:
        return True
return False
</pre></div>
</div>
<p>def doctype_matches(text, regex):
“””Check if the doctype matches a regular expression (if present).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Note that this method only checks the first part of a DOCTYPE.
eg: &#39;html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&#39;
&quot;&quot;&quot;
m = doctype_lookup_re.search(text)
if m is None:
    return False
doctype = m.group(1)
return re.compile(regex, re.I).match(doctype.strip()) is not None
</pre></div>
</div>
<p>def html_doctype_matches(text):
“””Check if the file looks like it has a html doctype.”””
return doctype_matches(text, r’html’)</p>
<p>_looks_like_xml_cache = {}</p>
<p>def looks_like_xml(text):
“””Check if a doctype exists or if we have some tags.”””
if xml_decl_re.match(text):
return True
key = hash(text)
try:
return _looks_like_xml_cache[key]
except KeyError:
m = doctype_lookup_re.search(text)
if m is not None:
return True
rv = tag_re.search(text[:1000]) is not None
_looks_like_xml_cache[key] = rv
return rv</p>
<p>def surrogatepair(c):
“””Given a unicode character code with length greater than 16 bits,
return the two 16 bit surrogate pair.
“””
# From example D28 of:
# http://www.unicode.org/book/ch03.pdf
return (0xd7c0 + (c &gt;&gt; 10), (0xdc00 + (c &amp; 0x3ff)))</p>
<p>def format_lines(var_name, seq, raw=False, indent_level=0):
“””Formats a sequence of strings for output.”””
lines = []
base_indent = ‘ ‘ * indent_level * 4
inner_indent = ‘ ‘ * (indent_level + 1) * 4
lines.append(base_indent + var_name + ‘ = (‘)
if raw:
# These should be preformatted reprs of, say, tuples.
for i in seq:
lines.append(inner_indent + i + ‘,’)
else:
for i in seq:
# Force use of single quotes
r = repr(i + ‘”’)
lines.append(inner_indent + r[:-2] + r[-1] + ‘,’)
lines.append(base_indent + ‘)’)
return ‘\n’.join(lines)</p>
<p>def duplicates_removed(it, already_seen=()):
“””
Returns a list with duplicates removed from the iterable <code class="docutils literal notranslate"><span class="pre">it</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Order is preserved.
&quot;&quot;&quot;
lst = []
seen = set()
for i in it:
    if i in seen or i in already_seen:
        continue
    lst.append(i)
    seen.add(i)
return lst
</pre></div>
</div>
<p>class Future:
“””Generic class to defer some work.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Handled specially in RegexLexerMeta, to support regex string construction at
first use.
&quot;&quot;&quot;
def get(self):
    raise NotImplementedError
</pre></div>
</div>
<p>def guess_decode(text):
“””Decode <em>text</em> with guessed encoding.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>First try UTF-8; this should fail for non-UTF-8 encodings.
Then try the preferred locale encoding.
Fall back to latin-1, which always works.
&quot;&quot;&quot;
try:
    text = text.decode(&#39;utf-8&#39;)
    return text, &#39;utf-8&#39;
except UnicodeDecodeError:
    try:
        import locale
        prefencoding = locale.getpreferredencoding()
        text = text.decode()
        return text, prefencoding
    except (UnicodeDecodeError, LookupError):
        text = text.decode(&#39;latin1&#39;)
        return text, &#39;latin1&#39;
</pre></div>
</div>
<p>def guess_decode_from_terminal(text, term):
“””Decode <em>text</em> coming from terminal <em>term</em>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>First try the terminal encoding, if given.
Then try UTF-8.  Then try the preferred locale encoding.
Fall back to latin-1, which always works.
&quot;&quot;&quot;
if getattr(term, &#39;encoding&#39;, None):
    try:
        text = text.decode(term.encoding)
    except UnicodeDecodeError:
        pass
    else:
        return text, term.encoding
return guess_decode(text)
</pre></div>
</div>
<p>def terminal_encoding(term):
“””Return our best guess of encoding for the given <em>term</em>.”””
if getattr(term, ‘encoding’, None):
return term.encoding
import locale
return locale.getpreferredencoding()</p>
<p>class UnclosingTextIOWrapper(TextIOWrapper):
# Don’t close underlying buffer on destruction.
def close(self):
self.flush()</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>