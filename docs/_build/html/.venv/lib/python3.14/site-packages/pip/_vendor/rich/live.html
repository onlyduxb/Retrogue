

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/rich/live.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import sys
from threading import Event, RLock, Thread
from types import TracebackType
from typing import IO, TYPE_CHECKING, Any, Callable, List, Optional, TextIO, Type, cast</p>
<p>from . import get_console
from .console import Console, ConsoleRenderable, Group, RenderableType, RenderHook
from .control import Control
from .file_proxy import FileProxy
from .jupyter import JupyterMixin
from .live_render import LiveRender, VerticalOverflowMethod
from .screen import Screen
from .text import Text</p>
<p>if TYPE_CHECKING:
# Can be replaced with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">typing</span> <span class="pre">import</span> <span class="pre">Self</span></code> in Python 3.11+
from typing_extensions import Self  # pragma: no cover</p>
<p>class _RefreshThread(Thread):
“””A thread that calls refresh() at regular intervals.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, live: &quot;Live&quot;, refresh_per_second: float) -&gt; None:
    self.live = live
    self.refresh_per_second = refresh_per_second
    self.done = Event()
    super().__init__(daemon=True)

def stop(self) -&gt; None:
    self.done.set()

def run(self) -&gt; None:
    while not self.done.wait(1 / self.refresh_per_second):
        with self.live._lock:
            if not self.done.is_set():
                self.live.refresh()
</pre></div>
</div>
<p>class Live(JupyterMixin, RenderHook):
“””Renders an auto-updating live display of any given renderable.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Args:
    renderable (RenderableType, optional): The renderable to live display. Defaults to displaying nothing.
    console (Console, optional): Optional Console instance. Defaults to an internal Console instance writing to stdout.
    screen (bool, optional): Enable alternate screen mode. Defaults to False.
    auto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()` or `update()` with refresh flag. Defaults to True
    refresh_per_second (float, optional): Number of times per second to refresh the live display. Defaults to 4.
    transient (bool, optional): Clear the renderable on exit (has no effect when screen=True). Defaults to False.
    redirect_stdout (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.
    redirect_stderr (bool, optional): Enable redirection of stderr. Defaults to True.
    vertical_overflow (VerticalOverflowMethod, optional): How to handle renderable when it is too tall for the console. Defaults to &quot;ellipsis&quot;.
    get_renderable (Callable[[], RenderableType], optional): Optional callable to get renderable. Defaults to None.
&quot;&quot;&quot;

def __init__(
    self,
    renderable: Optional[RenderableType] = None,
    *,
    console: Optional[Console] = None,
    screen: bool = False,
    auto_refresh: bool = True,
    refresh_per_second: float = 4,
    transient: bool = False,
    redirect_stdout: bool = True,
    redirect_stderr: bool = True,
    vertical_overflow: VerticalOverflowMethod = &quot;ellipsis&quot;,
    get_renderable: Optional[Callable[[], RenderableType]] = None,
) -&gt; None:
    assert refresh_per_second &gt; 0, &quot;refresh_per_second must be &gt; 0&quot;
    self._renderable = renderable
    self.console = console if console is not None else get_console()
    self._screen = screen
    self._alt_screen = False

    self._redirect_stdout = redirect_stdout
    self._redirect_stderr = redirect_stderr
    self._restore_stdout: Optional[IO[str]] = None
    self._restore_stderr: Optional[IO[str]] = None

    self._lock = RLock()
    self.ipy_widget: Optional[Any] = None
    self.auto_refresh = auto_refresh
    self._started: bool = False
    self.transient = True if screen else transient

    self._refresh_thread: Optional[_RefreshThread] = None
    self.refresh_per_second = refresh_per_second

    self.vertical_overflow = vertical_overflow
    self._get_renderable = get_renderable
    self._live_render = LiveRender(
        self.get_renderable(), vertical_overflow=vertical_overflow
    )
    self._nested = False

@property
def is_started(self) -&gt; bool:
    &quot;&quot;&quot;Check if live display has been started.&quot;&quot;&quot;
    return self._started

def get_renderable(self) -&gt; RenderableType:
    renderable = (
        self._get_renderable()
        if self._get_renderable is not None
        else self._renderable
    )
    return renderable or &quot;&quot;

def start(self, refresh: bool = False) -&gt; None:
    &quot;&quot;&quot;Start live rendering display.

    Args:
        refresh (bool, optional): Also refresh. Defaults to False.
    &quot;&quot;&quot;
    with self._lock:
        if self._started:
            return
        self._started = True

        if not self.console.set_live(self):
            self._nested = True
            return

        if self._screen:
            self._alt_screen = self.console.set_alt_screen(True)
        self.console.show_cursor(False)
        self._enable_redirect_io()
        self.console.push_render_hook(self)
        if refresh:
            try:
                self.refresh()
            except Exception:
                # If refresh fails, we want to stop the redirection of sys.stderr,
                # so the error stacktrace is properly displayed in the terminal.
                # (or, if the code that calls Rich captures the exception and wants to display something,
                # let this be displayed in the terminal).
                self.stop()
                raise
        if self.auto_refresh:
            self._refresh_thread = _RefreshThread(self, self.refresh_per_second)
            self._refresh_thread.start()

def stop(self) -&gt; None:
    &quot;&quot;&quot;Stop live rendering display.&quot;&quot;&quot;
    with self._lock:
        if not self._started:
            return
        self._started = False
        self.console.clear_live()
        if self._nested:
            if not self.transient:
                self.console.print(self.renderable)
            return

        if self.auto_refresh and self._refresh_thread is not None:
            self._refresh_thread.stop()
            self._refresh_thread = None
        # allow it to fully render on the last even if overflow
        self.vertical_overflow = &quot;visible&quot;
        with self.console:
            try:
                if not self._alt_screen and not self.console.is_jupyter:
                    self.refresh()
            finally:
                self._disable_redirect_io()
                self.console.pop_render_hook()
                if not self._alt_screen and self.console.is_terminal:
                    self.console.line()
                self.console.show_cursor(True)
                if self._alt_screen:
                    self.console.set_alt_screen(False)
                if self.transient and not self._alt_screen:
                    self.console.control(self._live_render.restore_cursor())
                if self.ipy_widget is not None and self.transient:
                    self.ipy_widget.close()  # pragma: no cover

def __enter__(self) -&gt; Self:
    self.start(refresh=self._renderable is not None)
    return self

def __exit__(
    self,
    exc_type: Optional[Type[BaseException]],
    exc_val: Optional[BaseException],
    exc_tb: Optional[TracebackType],
) -&gt; None:
    self.stop()

def _enable_redirect_io(self) -&gt; None:
    &quot;&quot;&quot;Enable redirecting of stdout / stderr.&quot;&quot;&quot;
    if self.console.is_terminal or self.console.is_jupyter:
        if self._redirect_stdout and not isinstance(sys.stdout, FileProxy):
            self._restore_stdout = sys.stdout
            sys.stdout = cast(&quot;TextIO&quot;, FileProxy(self.console, sys.stdout))
        if self._redirect_stderr and not isinstance(sys.stderr, FileProxy):
            self._restore_stderr = sys.stderr
            sys.stderr = cast(&quot;TextIO&quot;, FileProxy(self.console, sys.stderr))

def _disable_redirect_io(self) -&gt; None:
    &quot;&quot;&quot;Disable redirecting of stdout / stderr.&quot;&quot;&quot;
    if self._restore_stdout:
        sys.stdout = cast(&quot;TextIO&quot;, self._restore_stdout)
        self._restore_stdout = None
    if self._restore_stderr:
        sys.stderr = cast(&quot;TextIO&quot;, self._restore_stderr)
        self._restore_stderr = None

@property
def renderable(self) -&gt; RenderableType:
    &quot;&quot;&quot;Get the renderable that is being displayed

    Returns:
        RenderableType: Displayed renderable.
    &quot;&quot;&quot;
    live_stack = self.console._live_stack
    renderable: RenderableType
    if live_stack and self is live_stack[0]:
        # The first Live instance will render everything in the Live stack
        renderable = Group(*[live.get_renderable() for live in live_stack])
    else:
        renderable = self.get_renderable()
    return Screen(renderable) if self._alt_screen else renderable

def update(self, renderable: RenderableType, *, refresh: bool = False) -&gt; None:
    &quot;&quot;&quot;Update the renderable that is being displayed

    Args:
        renderable (RenderableType): New renderable to use.
        refresh (bool, optional): Refresh the display. Defaults to False.
    &quot;&quot;&quot;
    if isinstance(renderable, str):
        renderable = self.console.render_str(renderable)
    with self._lock:
        self._renderable = renderable
        if refresh:
            self.refresh()

def refresh(self) -&gt; None:
    &quot;&quot;&quot;Update the display of the Live Render.&quot;&quot;&quot;
    with self._lock:
        self._live_render.set_renderable(self.renderable)
        if self._nested:
            if self.console._live_stack:
                self.console._live_stack[0].refresh()
            return

        if self.console.is_jupyter:  # pragma: no cover
            try:
                from IPython.display import display
                from ipywidgets import Output
            except ImportError:
                import warnings

                warnings.warn(&#39;install &quot;ipywidgets&quot; for Jupyter support&#39;)
            else:
                if self.ipy_widget is None:
                    self.ipy_widget = Output()
                    display(self.ipy_widget)

                with self.ipy_widget:
                    self.ipy_widget.clear_output(wait=True)
                    self.console.print(self._live_render.renderable)
        elif self.console.is_terminal and not self.console.is_dumb_terminal:
            with self.console:
                self.console.print(Control())
        elif (
            not self._started and not self.transient
        ):  # if it is finished allow files or dumb-terminals to see final result
            with self.console:
                self.console.print(Control())

def process_renderables(
    self, renderables: List[ConsoleRenderable]
) -&gt; List[ConsoleRenderable]:
    &quot;&quot;&quot;Process renderables to restore cursor and display progress.&quot;&quot;&quot;
    self._live_render.vertical_overflow = self.vertical_overflow
    if self.console.is_interactive:
        # lock needs acquiring as user can modify live_render renderable at any time unlike in Progress.
        with self._lock:
            reset = (
                Control.home()
                if self._alt_screen
                else self._live_render.position_cursor()
            )
            renderables = [reset, *renderables, self._live_render]
    elif (
        not self._started and not self.transient
    ):  # if it is finished render the final output for files or dumb_terminals
        renderables = [*renderables, self._live_render]

    return renderables
</pre></div>
</div>
<p>if <strong>name</strong> == “<strong>main</strong>”:  # pragma: no cover
import random
import time
from itertools import cycle
from typing import Dict, List, Tuple</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from .align import Align
from .console import Console
from .live import Live as Live
from .panel import Panel
from .rule import Rule
from .syntax import Syntax
from .table import Table

console = Console()

syntax = Syntax(
    &#39;&#39;&#39;def loop_last(values: Iterable[T]) -&gt; Iterable[Tuple[bool, T]]:
&quot;&quot;&quot;Iterate and generate a tuple with a flag for last value.&quot;&quot;&quot;
iter_values = iter(values)
try:
    previous_value = next(iter_values)
except StopIteration:
    return
for value in iter_values:
    yield False, previous_value
    previous_value = value
yield True, previous_value&#39;&#39;&#39;,
    &quot;python&quot;,
    line_numbers=True,
)

table = Table(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)
table.add_row(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)

progress_renderables = [
    &quot;You can make the terminal shorter and taller to see the live table hide&quot;
    &quot;Text may be printed while the progress bars are rendering.&quot;,
    Panel(&quot;In fact, [i]any[/i] renderable will work&quot;),
    &quot;Such as [magenta]tables[/]...&quot;,
    table,
    &quot;Pretty printed structures...&quot;,
    {&quot;type&quot;: &quot;example&quot;, &quot;text&quot;: &quot;Pretty printed&quot;},
    &quot;Syntax...&quot;,
    syntax,
    Rule(&quot;Give it a try!&quot;),
]

examples = cycle(progress_renderables)

exchanges = [
    &quot;SGD&quot;,
    &quot;MYR&quot;,
    &quot;EUR&quot;,
    &quot;USD&quot;,
    &quot;AUD&quot;,
    &quot;JPY&quot;,
    &quot;CNH&quot;,
    &quot;HKD&quot;,
    &quot;CAD&quot;,
    &quot;INR&quot;,
    &quot;DKK&quot;,
    &quot;GBP&quot;,
    &quot;RUB&quot;,
    &quot;NZD&quot;,
    &quot;MXN&quot;,
    &quot;IDR&quot;,
    &quot;TWD&quot;,
    &quot;THB&quot;,
    &quot;VND&quot;,
]
with Live(console=console) as live_table:
    exchange_rate_dict: Dict[Tuple[str, str], float] = {}

    for index in range(100):
        select_exchange = exchanges[index % len(exchanges)]

        for exchange in exchanges:
            if exchange == select_exchange:
                continue
            time.sleep(0.4)
            if random.randint(0, 10) &lt; 1:
                console.log(next(examples))
            exchange_rate_dict[(select_exchange, exchange)] = 200 / (
                (random.random() * 320) + 1
            )
            if len(exchange_rate_dict) &gt; len(exchanges) - 1:
                exchange_rate_dict.pop(list(exchange_rate_dict.keys())[0])
            table = Table(title=&quot;Exchange Rates&quot;)

            table.add_column(&quot;Source Currency&quot;)
            table.add_column(&quot;Destination Currency&quot;)
            table.add_column(&quot;Exchange Rate&quot;)

            for (source, dest), exchange_rate in exchange_rate_dict.items():
                table.add_row(
                    source,
                    dest,
                    Text(
                        f&quot;{exchange_rate:.4f}&quot;,
                        style=&quot;red&quot; if exchange_rate &lt; 1.0 else &quot;green&quot;,
                    ),
                )

            live_table.update(Align.center(table))
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>