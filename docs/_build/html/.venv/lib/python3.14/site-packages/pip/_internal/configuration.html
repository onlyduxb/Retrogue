

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The kinds of configurations there are. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The kinds of configurations there are.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/configuration.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Configuration management setup</p>
<p>Some terminology:</p>
<ul class="simple">
<li><p>name
As written in config files.</p></li>
<li><p>value
Value associated with a name</p></li>
<li><p>key
Name combined with it’s section (section.name)</p></li>
<li><p>variant
A single word describing where the configuration key-value pair came from
“””</p></li>
</ul>
<p>from <strong>future</strong> import annotations</p>
<p>import configparser
import locale
import os
import sys
from collections.abc import Iterable
from typing import Any, NewType</p>
<p>from pip._internal.exceptions import (
ConfigurationError,
ConfigurationFileCouldNotBeLoaded,
)
from pip._internal.utils import appdirs
from pip._internal.utils.compat import WINDOWS
from pip._internal.utils.logging import getLogger
from pip._internal.utils.misc import ensure_dir, enum</p>
<p>RawConfigParser = configparser.RawConfigParser  # Shorthand
Kind = NewType(“Kind”, str)</p>
<p>CONFIG_BASENAME = “pip.ini” if WINDOWS else “pip.conf”
ENV_NAMES_IGNORED = “version”, “help”</p>
<section id="the-kinds-of-configurations-there-are">
<h1>The kinds of configurations there are.<a class="headerlink" href="#the-kinds-of-configurations-there-are" title="Link to this heading"></a></h1>
<p>kinds = enum(
USER=”user”,  # User Specific
GLOBAL=”global”,  # System Wide
SITE=”site”,  # [Virtual] Environment Specific
ENV=”env”,  # from PIP_CONFIG_FILE
ENV_VAR=”env-var”,  # from Environment Variables
)
OVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
VALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE</p>
<p>logger = getLogger(<strong>name</strong>)</p>
</section>
<section id="note-maybe-use-the-optionx-attribute-to-normalize-keynames">
<h1>NOTE: Maybe use the optionx attribute to normalize keynames.<a class="headerlink" href="#note-maybe-use-the-optionx-attribute-to-normalize-keynames" title="Link to this heading"></a></h1>
<p>def <em>normalize_name(name: str) -&gt; str:
“””Make a name consistent regardless of source (environment or file)”””
name = name.lower().replace(”</em>”, “-“)
name = name.removeprefix(”–”)  # only prefer long opts
return name</p>
<p>def _disassemble_key(name: str) -&gt; list[str]:
if “.” not in name:
error_message = (
“Key does not contain dot separated section and key. “
f”Perhaps you wanted to use ‘global.{name}’ instead?”
)
raise ConfigurationError(error_message)
return name.split(“.”, 1)</p>
<p>def get_configuration_files() -&gt; dict[Kind, list[str]]:
global_config_files = [
os.path.join(path, CONFIG_BASENAME) for path in appdirs.site_config_dirs(“pip”)
]</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>site_config_file = os.path.join(sys.prefix, CONFIG_BASENAME)
legacy_config_file = os.path.join(
    os.path.expanduser(&quot;~&quot;),
    &quot;pip&quot; if WINDOWS else &quot;.pip&quot;,
    CONFIG_BASENAME,
)
new_config_file = os.path.join(appdirs.user_config_dir(&quot;pip&quot;), CONFIG_BASENAME)
return {
    kinds.GLOBAL: global_config_files,
    kinds.SITE: [site_config_file],
    kinds.USER: [legacy_config_file, new_config_file],
}
</pre></div>
</div>
<p>class Configuration:
“””Handles management of configuration.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Provides an interface to accessing and managing configuration files.

This class converts provides an API that takes &quot;section.key-name&quot; style
keys and stores the value associated with it as &quot;key-name&quot; under the
section &quot;section&quot;.

This allows for a clean interface wherein the both the section and the
key-name are preserved in an easy to manage form in the configuration files
and the data stored is also nice.
&quot;&quot;&quot;

def __init__(self, isolated: bool, load_only: Kind | None = None) -&gt; None:
    super().__init__()

    if load_only is not None and load_only not in VALID_LOAD_ONLY:
        raise ConfigurationError(
            &quot;Got invalid value for load_only - should be one of {}&quot;.format(
                &quot;, &quot;.join(map(repr, VALID_LOAD_ONLY))
            )
        )
    self.isolated = isolated
    self.load_only = load_only

    # Because we keep track of where we got the data from
    self._parsers: dict[Kind, list[tuple[str, RawConfigParser]]] = {
        variant: [] for variant in OVERRIDE_ORDER
    }
    self._config: dict[Kind, dict[str, dict[str, Any]]] = {
        variant: {} for variant in OVERRIDE_ORDER
    }
    self._modified_parsers: list[tuple[str, RawConfigParser]] = []

def load(self) -&gt; None:
    &quot;&quot;&quot;Loads configuration from configuration files and environment&quot;&quot;&quot;
    self._load_config_files()
    if not self.isolated:
        self._load_environment_vars()

def get_file_to_edit(self) -&gt; str | None:
    &quot;&quot;&quot;Returns the file with highest priority in configuration&quot;&quot;&quot;
    assert self.load_only is not None, &quot;Need to be specified a file to be editing&quot;

    try:
        return self._get_parser_to_modify()[0]
    except IndexError:
        return None

def items(self) -&gt; Iterable[tuple[str, Any]]:
    &quot;&quot;&quot;Returns key-value pairs like dict.items() representing the loaded
    configuration
    &quot;&quot;&quot;
    return self._dictionary.items()

def get_value(self, key: str) -&gt; Any:
    &quot;&quot;&quot;Get a value from the configuration.&quot;&quot;&quot;
    orig_key = key
    key = _normalize_name(key)
    try:
        clean_config: dict[str, Any] = {}
        for file_values in self._dictionary.values():
            clean_config.update(file_values)
        return clean_config[key]
    except KeyError:
        # disassembling triggers a more useful error message than simply
        # &quot;No such key&quot; in the case that the key isn&#39;t in the form command.option
        _disassemble_key(key)
        raise ConfigurationError(f&quot;No such key - {orig_key}&quot;)

def set_value(self, key: str, value: Any) -&gt; None:
    &quot;&quot;&quot;Modify a value in the configuration.&quot;&quot;&quot;
    key = _normalize_name(key)
    self._ensure_have_load_only()

    assert self.load_only
    fname, parser = self._get_parser_to_modify()

    if parser is not None:
        section, name = _disassemble_key(key)

        # Modify the parser and the configuration
        if not parser.has_section(section):
            parser.add_section(section)
        parser.set(section, name, value)

    self._config[self.load_only].setdefault(fname, {})
    self._config[self.load_only][fname][key] = value
    self._mark_as_modified(fname, parser)

def unset_value(self, key: str) -&gt; None:
    &quot;&quot;&quot;Unset a value in the configuration.&quot;&quot;&quot;
    orig_key = key
    key = _normalize_name(key)
    self._ensure_have_load_only()

    assert self.load_only
    fname, parser = self._get_parser_to_modify()

    if (
        key not in self._config[self.load_only][fname]
        and key not in self._config[self.load_only]
    ):
        raise ConfigurationError(f&quot;No such key - {orig_key}&quot;)

    if parser is not None:
        section, name = _disassemble_key(key)
        if not (
            parser.has_section(section) and parser.remove_option(section, name)
        ):
            # The option was not removed.
            raise ConfigurationError(
                &quot;Fatal Internal error [id=1]. Please report as a bug.&quot;
            )

        # The section may be empty after the option was removed.
        if not parser.items(section):
            parser.remove_section(section)
        self._mark_as_modified(fname, parser)
    try:
        del self._config[self.load_only][fname][key]
    except KeyError:
        del self._config[self.load_only][key]

def save(self) -&gt; None:
    &quot;&quot;&quot;Save the current in-memory state.&quot;&quot;&quot;
    self._ensure_have_load_only()

    for fname, parser in self._modified_parsers:
        logger.info(&quot;Writing to %s&quot;, fname)

        # Ensure directory exists.
        ensure_dir(os.path.dirname(fname))

        # Ensure directory&#39;s permission(need to be writeable)
        try:
            with open(fname, &quot;w&quot;) as f:
                parser.write(f)
        except OSError as error:
            raise ConfigurationError(
                f&quot;An error occurred while writing to the configuration file &quot;
                f&quot;{fname}: {error}&quot;
            )

#
# Private routines
#

def _ensure_have_load_only(self) -&gt; None:
    if self.load_only is None:
        raise ConfigurationError(&quot;Needed a specific file to be modifying.&quot;)
    logger.debug(&quot;Will be working with %s variant only&quot;, self.load_only)

@property
def _dictionary(self) -&gt; dict[str, dict[str, Any]]:
    &quot;&quot;&quot;A dictionary representing the loaded configuration.&quot;&quot;&quot;
    # NOTE: Dictionaries are not populated if not loaded. So, conditionals
    #       are not needed here.
    retval = {}

    for variant in OVERRIDE_ORDER:
        retval.update(self._config[variant])

    return retval

def _load_config_files(self) -&gt; None:
    &quot;&quot;&quot;Loads configuration from configuration files&quot;&quot;&quot;
    config_files = dict(self.iter_config_files())
    if config_files[kinds.ENV][0:1] == [os.devnull]:
        logger.debug(
            &quot;Skipping loading configuration files due to &quot;
            &quot;environment&#39;s PIP_CONFIG_FILE being os.devnull&quot;
        )
        return

    for variant, files in config_files.items():
        for fname in files:
            # If there&#39;s specific variant set in `load_only`, load only
            # that variant, not the others.
            if self.load_only is not None and variant != self.load_only:
                logger.debug(&quot;Skipping file &#39;%s&#39; (variant: %s)&quot;, fname, variant)
                continue

            parser = self._load_file(variant, fname)

            # Keeping track of the parsers used
            self._parsers[variant].append((fname, parser))

def _load_file(self, variant: Kind, fname: str) -&gt; RawConfigParser:
    logger.verbose(&quot;For variant &#39;%s&#39;, will try loading &#39;%s&#39;&quot;, variant, fname)
    parser = self._construct_parser(fname)

    for section in parser.sections():
        items = parser.items(section)
        self._config[variant].setdefault(fname, {})
        self._config[variant][fname].update(self._normalized_keys(section, items))

    return parser

def _construct_parser(self, fname: str) -&gt; RawConfigParser:
    parser = configparser.RawConfigParser()
    # If there is no such file, don&#39;t bother reading it but create the
    # parser anyway, to hold the data.
    # Doing this is useful when modifying and saving files, where we don&#39;t
    # need to construct a parser.
    if os.path.exists(fname):
        locale_encoding = locale.getpreferredencoding(False)
        try:
            parser.read(fname, encoding=locale_encoding)
        except UnicodeDecodeError:
            # See https://github.com/pypa/pip/issues/4963
            raise ConfigurationFileCouldNotBeLoaded(
                reason=f&quot;contains invalid {locale_encoding} characters&quot;,
                fname=fname,
            )
        except configparser.Error as error:
            # See https://github.com/pypa/pip/issues/4893
            raise ConfigurationFileCouldNotBeLoaded(error=error)
    return parser

def _load_environment_vars(self) -&gt; None:
    &quot;&quot;&quot;Loads configuration from environment variables&quot;&quot;&quot;
    self._config[kinds.ENV_VAR].setdefault(&quot;:env:&quot;, {})
    self._config[kinds.ENV_VAR][&quot;:env:&quot;].update(
        self._normalized_keys(&quot;:env:&quot;, self.get_environ_vars())
    )

def _normalized_keys(
    self, section: str, items: Iterable[tuple[str, Any]]
) -&gt; dict[str, Any]:
    &quot;&quot;&quot;Normalizes items to construct a dictionary with normalized keys.

    This routine is where the names become keys and are made the same
    regardless of source - configuration files or environment.
    &quot;&quot;&quot;
    normalized = {}
    for name, val in items:
        key = section + &quot;.&quot; + _normalize_name(name)
        normalized[key] = val
    return normalized

def get_environ_vars(self) -&gt; Iterable[tuple[str, str]]:
    &quot;&quot;&quot;Returns a generator with all environmental vars with prefix PIP_&quot;&quot;&quot;
    for key, val in os.environ.items():
        if key.startswith(&quot;PIP_&quot;):
            name = key[4:].lower()
            if name not in ENV_NAMES_IGNORED:
                yield name, val

# XXX: This is patched in the tests.
def iter_config_files(self) -&gt; Iterable[tuple[Kind, list[str]]]:
    &quot;&quot;&quot;Yields variant and configuration files associated with it.

    This should be treated like items of a dictionary. The order
    here doesn&#39;t affect what gets overridden. That is controlled
    by OVERRIDE_ORDER. However this does control the order they are
    displayed to the user. It&#39;s probably most ergonomic to display
    things in the same order as OVERRIDE_ORDER
    &quot;&quot;&quot;
    # SMELL: Move the conditions out of this function

    env_config_file = os.environ.get(&quot;PIP_CONFIG_FILE&quot;, None)
    config_files = get_configuration_files()

    yield kinds.GLOBAL, config_files[kinds.GLOBAL]

    # per-user config is not loaded when env_config_file exists
    should_load_user_config = not self.isolated and not (
        env_config_file and os.path.exists(env_config_file)
    )
    if should_load_user_config:
        # The legacy config file is overridden by the new config file
        yield kinds.USER, config_files[kinds.USER]

    # virtualenv config
    yield kinds.SITE, config_files[kinds.SITE]

    if env_config_file is not None:
        yield kinds.ENV, [env_config_file]
    else:
        yield kinds.ENV, []

def get_values_in_config(self, variant: Kind) -&gt; dict[str, Any]:
    &quot;&quot;&quot;Get values present in a config file&quot;&quot;&quot;
    return self._config[variant]

def _get_parser_to_modify(self) -&gt; tuple[str, RawConfigParser]:
    # Determine which parser to modify
    assert self.load_only
    parsers = self._parsers[self.load_only]
    if not parsers:
        # This should not happen if everything works correctly.
        raise ConfigurationError(
            &quot;Fatal Internal error [id=2]. Please report as a bug.&quot;
        )

    # Use the highest priority parser.
    return parsers[-1]

# XXX: This is patched in the tests.
def _mark_as_modified(self, fname: str, parser: RawConfigParser) -&gt; None:
    file_parser_tuple = (fname, parser)
    if file_parser_tuple not in self._modified_parsers:
        self._modified_parsers.append(file_parser_tuple)

def __repr__(self) -&gt; str:
    return f&quot;{self.__class__.__name__}({self._dictionary!r})&quot;
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>