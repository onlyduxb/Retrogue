

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>All known keyword arguments that could be provided to the pool manager, its &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">All known keyword arguments that could be provided to the pool manager, its</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/poolmanager.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import absolute_import</p>
<p>import collections
import functools
import logging</p>
<p>from ._collections import HTTPHeaderDict, RecentlyUsedContainer
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme
from .exceptions import (
LocationValueError,
MaxRetryError,
ProxySchemeUnknown,
ProxySchemeUnsupported,
URLSchemeUnknown,
)
from .packages import six
from .packages.six.moves.urllib.parse import urljoin
from .request import RequestMethods
from .util.proxy import connection_requires_http_tunnel
from .util.retry import Retry
from .util.url import parse_url</p>
<p><strong>all</strong> = [“PoolManager”, “ProxyManager”, “proxy_from_url”]</p>
<p>log = logging.getLogger(<strong>name</strong>)</p>
<p>SSL_KEYWORDS = (
“key_file”,
“cert_file”,
“cert_reqs”,
“ca_certs”,
“ssl_version”,
“ca_cert_dir”,
“ssl_context”,
“key_password”,
“server_hostname”,
)</p>
<section id="all-known-keyword-arguments-that-could-be-provided-to-the-pool-manager-its">
<h1>All known keyword arguments that could be provided to the pool manager, its<a class="headerlink" href="#all-known-keyword-arguments-that-could-be-provided-to-the-pool-manager-its" title="Link to this heading"></a></h1>
</section>
<section id="pools-or-the-underlying-connections-this-is-used-to-construct-a-pool-key">
<h1>pools, or the underlying connections. This is used to construct a pool key.<a class="headerlink" href="#pools-or-the-underlying-connections-this-is-used-to-construct-a-pool-key" title="Link to this heading"></a></h1>
<p><em>key_fields = (
“key_scheme”,  # str
“key_host”,  # str
“key_port”,  # int
“key_timeout”,  # int or float or Timeout
“key_retries”,  # int or Retry
“key_strict”,  # bool
“key_block”,  # bool
“key_source_address”,  # str
“key_key_file”,  # str
“key_key_password”,  # str
“key_cert_file”,  # str
“key_cert_reqs”,  # str
“key_ca_certs”,  # str
“key_ssl_version”,  # str
“key_ca_cert_dir”,  # str
“key_ssl_context”,  # instance of ssl.SSLContext or urllib3.util.ssl</em>.SSLContext
“key_maxsize”,  # int
“key_headers”,  # dict
“key__proxy”,  # parsed proxy url
“key__proxy_headers”,  # dict
“key__proxy_config”,  # class
“key_socket_options”,  # list of (level (int), optname (int), value (int or str)) tuples
“key__socks_options”,  # dict
“key_assert_hostname”,  # bool or string
“key_assert_fingerprint”,  # str
“key_server_hostname”,  # str
)</p>
<p>#: The namedtuple class used to construct keys for the connection pool.
#: All custom key schemes should include the fields in this key at a minimum.
PoolKey = collections.namedtuple(“PoolKey”, _key_fields)</p>
<p>_proxy_config_fields = (“ssl_context”, “use_forwarding_for_https”)
ProxyConfig = collections.namedtuple(“ProxyConfig”, _proxy_config_fields)</p>
<p>def _default_key_normalizer(key_class, request_context):
“””
Create a pool key out of a request context dictionary.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>According to RFC 3986, both the scheme and host are case-insensitive.
Therefore, this function normalizes both before constructing the pool
key for an HTTPS request. If you wish to change this behaviour, provide
alternate callables to ``key_fn_by_scheme``.

:param key_class:
    The class to use when constructing the key. This should be a namedtuple
    with the ``scheme`` and ``host`` keys at a minimum.
:type  key_class: namedtuple
:param request_context:
    A dictionary-like object that contain the context for a request.
:type  request_context: dict

:return: A namedtuple that can be used as a connection pool key.
:rtype:  PoolKey
&quot;&quot;&quot;
# Since we mutate the dictionary, make a copy first
context = request_context.copy()
context[&quot;scheme&quot;] = context[&quot;scheme&quot;].lower()
context[&quot;host&quot;] = context[&quot;host&quot;].lower()

# These are both dictionaries and need to be transformed into frozensets
for key in (&quot;headers&quot;, &quot;_proxy_headers&quot;, &quot;_socks_options&quot;):
    if key in context and context[key] is not None:
        context[key] = frozenset(context[key].items())

# The socket_options key may be a list and needs to be transformed into a
# tuple.
socket_opts = context.get(&quot;socket_options&quot;)
if socket_opts is not None:
    context[&quot;socket_options&quot;] = tuple(socket_opts)

# Map the kwargs to the names in the namedtuple - this is necessary since
# namedtuples can&#39;t have fields starting with &#39;_&#39;.
for key in list(context.keys()):
    context[&quot;key_&quot; + key] = context.pop(key)

# Default to ``None`` for keys missing from the context
for field in key_class._fields:
    if field not in context:
        context[field] = None

return key_class(**context)
</pre></div>
</div>
<p>#: A dictionary that maps a scheme to a callable that creates a pool key.
#: This can be used to alter the way pool keys are constructed, if desired.
#: Each PoolManager makes a copy of this dictionary so they can be configured
#: globally here, or individually on the instance.
key_fn_by_scheme = {
“http”: functools.partial(_default_key_normalizer, PoolKey),
“https”: functools.partial(_default_key_normalizer, PoolKey),
}</p>
<p>pool_classes_by_scheme = {“http”: HTTPConnectionPool, “https”: HTTPSConnectionPool}</p>
<p>class PoolManager(RequestMethods):
“””
Allows for arbitrary requests while transparently keeping track of
necessary connection pools for you.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param num_pools:
    Number of connection pools to cache before discarding the least
    recently used pool.

:param headers:
    Headers to include with all requests, unless other headers are given
    explicitly.

:param \\**connection_pool_kw:
    Additional parameters are used to create fresh
    :class:`urllib3.connectionpool.ConnectionPool` instances.

Example::

    &gt;&gt;&gt; manager = PoolManager(num_pools=2)
    &gt;&gt;&gt; r = manager.request(&#39;GET&#39;, &#39;http://google.com/&#39;)
    &gt;&gt;&gt; r = manager.request(&#39;GET&#39;, &#39;http://google.com/mail&#39;)
    &gt;&gt;&gt; r = manager.request(&#39;GET&#39;, &#39;http://yahoo.com/&#39;)
    &gt;&gt;&gt; len(manager.pools)
    2

&quot;&quot;&quot;

proxy = None
proxy_config = None

def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
    RequestMethods.__init__(self, headers)
    self.connection_pool_kw = connection_pool_kw
    self.pools = RecentlyUsedContainer(num_pools)

    # Locally set the pool classes and keys so other PoolManagers can
    # override them.
    self.pool_classes_by_scheme = pool_classes_by_scheme
    self.key_fn_by_scheme = key_fn_by_scheme.copy()

def __enter__(self):
    return self

def __exit__(self, exc_type, exc_val, exc_tb):
    self.clear()
    # Return False to re-raise any potential exceptions
    return False

def _new_pool(self, scheme, host, port, request_context=None):
    &quot;&quot;&quot;
    Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and
    any additional pool keyword arguments.

    If ``request_context`` is provided, it is provided as keyword arguments
    to the pool class used. This method is used to actually create the
    connection pools handed out by :meth:`connection_from_url` and
    companion methods. It is intended to be overridden for customization.
    &quot;&quot;&quot;
    pool_cls = self.pool_classes_by_scheme[scheme]
    if request_context is None:
        request_context = self.connection_pool_kw.copy()

    # Although the context has everything necessary to create the pool,
    # this function has historically only used the scheme, host, and port
    # in the positional args. When an API change is acceptable these can
    # be removed.
    for key in (&quot;scheme&quot;, &quot;host&quot;, &quot;port&quot;):
        request_context.pop(key, None)

    if scheme == &quot;http&quot;:
        for kw in SSL_KEYWORDS:
            request_context.pop(kw, None)

    return pool_cls(host, port, **request_context)

def clear(self):
    &quot;&quot;&quot;
    Empty our store of pools and direct them all to close.

    This will not affect in-flight connections, but they will not be
    re-used after completion.
    &quot;&quot;&quot;
    self.pools.clear()

def connection_from_host(self, host, port=None, scheme=&quot;http&quot;, pool_kwargs=None):
    &quot;&quot;&quot;
    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.

    If ``port`` isn&#39;t given, it will be derived from the ``scheme`` using
    ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is
    provided, it is merged with the instance&#39;s ``connection_pool_kw``
    variable and used to create the new connection pool, if one is
    needed.
    &quot;&quot;&quot;

    if not host:
        raise LocationValueError(&quot;No host specified.&quot;)

    request_context = self._merge_pool_kwargs(pool_kwargs)
    request_context[&quot;scheme&quot;] = scheme or &quot;http&quot;
    if not port:
        port = port_by_scheme.get(request_context[&quot;scheme&quot;].lower(), 80)
    request_context[&quot;port&quot;] = port
    request_context[&quot;host&quot;] = host

    return self.connection_from_context(request_context)

def connection_from_context(self, request_context):
    &quot;&quot;&quot;
    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.

    ``request_context`` must at least contain the ``scheme`` key and its
    value must be a key in ``key_fn_by_scheme`` instance variable.
    &quot;&quot;&quot;
    scheme = request_context[&quot;scheme&quot;].lower()
    pool_key_constructor = self.key_fn_by_scheme.get(scheme)
    if not pool_key_constructor:
        raise URLSchemeUnknown(scheme)
    pool_key = pool_key_constructor(request_context)

    return self.connection_from_pool_key(pool_key, request_context=request_context)

def connection_from_pool_key(self, pool_key, request_context=None):
    &quot;&quot;&quot;
    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.

    ``pool_key`` should be a namedtuple that only contains immutable
    objects. At a minimum it must have the ``scheme``, ``host``, and
    ``port`` fields.
    &quot;&quot;&quot;
    with self.pools.lock:
        # If the scheme, host, or port doesn&#39;t match existing open
        # connections, open a new ConnectionPool.
        pool = self.pools.get(pool_key)
        if pool:
            return pool

        # Make a fresh ConnectionPool of the desired type
        scheme = request_context[&quot;scheme&quot;]
        host = request_context[&quot;host&quot;]
        port = request_context[&quot;port&quot;]
        pool = self._new_pool(scheme, host, port, request_context=request_context)
        self.pools[pool_key] = pool

    return pool

def connection_from_url(self, url, pool_kwargs=None):
    &quot;&quot;&quot;
    Similar to :func:`urllib3.connectionpool.connection_from_url`.

    If ``pool_kwargs`` is not provided and a new pool needs to be
    constructed, ``self.connection_pool_kw`` is used to initialize
    the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``
    is provided, it is used instead. Note that if a new pool does not
    need to be created for the request, the provided ``pool_kwargs`` are
    not used.
    &quot;&quot;&quot;
    u = parse_url(url)
    return self.connection_from_host(
        u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs
    )

def _merge_pool_kwargs(self, override):
    &quot;&quot;&quot;
    Merge a dictionary of override values for self.connection_pool_kw.

    This does not modify self.connection_pool_kw and returns a new dict.
    Any keys in the override dictionary with a value of ``None`` are
    removed from the merged dictionary.
    &quot;&quot;&quot;
    base_pool_kwargs = self.connection_pool_kw.copy()
    if override:
        for key, value in override.items():
            if value is None:
                try:
                    del base_pool_kwargs[key]
                except KeyError:
                    pass
            else:
                base_pool_kwargs[key] = value
    return base_pool_kwargs

def _proxy_requires_url_absolute_form(self, parsed_url):
    &quot;&quot;&quot;
    Indicates if the proxy requires the complete destination URL in the
    request.  Normally this is only needed when not using an HTTP CONNECT
    tunnel.
    &quot;&quot;&quot;
    if self.proxy is None:
        return False

    return not connection_requires_http_tunnel(
        self.proxy, self.proxy_config, parsed_url.scheme
    )

def _validate_proxy_scheme_url_selection(self, url_scheme):
    &quot;&quot;&quot;
    Validates that were not attempting to do TLS in TLS connections on
    Python2 or with unsupported SSL implementations.
    &quot;&quot;&quot;
    if self.proxy is None or url_scheme != &quot;https&quot;:
        return

    if self.proxy.scheme != &quot;https&quot;:
        return

    if six.PY2 and not self.proxy_config.use_forwarding_for_https:
        raise ProxySchemeUnsupported(
            &quot;Contacting HTTPS destinations through HTTPS proxies &quot;
            &quot;&#39;via CONNECT tunnels&#39; is not supported in Python 2&quot;
        )

def urlopen(self, method, url, redirect=True, **kw):
    &quot;&quot;&quot;
    Same as :meth:`urllib3.HTTPConnectionPool.urlopen`
    with custom cross-host redirect logic and only sends the request-uri
    portion of the ``url``.

    The given ``url`` parameter must be absolute, such that an appropriate
    :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
    &quot;&quot;&quot;
    u = parse_url(url)
    self._validate_proxy_scheme_url_selection(u.scheme)

    conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)

    kw[&quot;assert_same_host&quot;] = False
    kw[&quot;redirect&quot;] = False

    if &quot;headers&quot; not in kw:
        kw[&quot;headers&quot;] = self.headers.copy()

    if self._proxy_requires_url_absolute_form(u):
        response = conn.urlopen(method, url, **kw)
    else:
        response = conn.urlopen(method, u.request_uri, **kw)

    redirect_location = redirect and response.get_redirect_location()
    if not redirect_location:
        return response

    # Support relative URLs for redirecting.
    redirect_location = urljoin(url, redirect_location)

    if response.status == 303:
        # Change the method according to RFC 9110, Section 15.4.4.
        method = &quot;GET&quot;
        # And lose the body not to transfer anything sensitive.
        kw[&quot;body&quot;] = None
        kw[&quot;headers&quot;] = HTTPHeaderDict(kw[&quot;headers&quot;])._prepare_for_method_change()

    retries = kw.get(&quot;retries&quot;)
    if not isinstance(retries, Retry):
        retries = Retry.from_int(retries, redirect=redirect)

    # Strip headers marked as unsafe to forward to the redirected location.
    # Check remove_headers_on_redirect to avoid a potential network call within
    # conn.is_same_host() which may use socket.gethostbyname() in the future.
    if retries.remove_headers_on_redirect and not conn.is_same_host(
        redirect_location
    ):
        headers = list(six.iterkeys(kw[&quot;headers&quot;]))
        for header in headers:
            if header.lower() in retries.remove_headers_on_redirect:
                kw[&quot;headers&quot;].pop(header, None)

    try:
        retries = retries.increment(method, url, response=response, _pool=conn)
    except MaxRetryError:
        if retries.raise_on_redirect:
            response.drain_conn()
            raise
        return response

    kw[&quot;retries&quot;] = retries
    kw[&quot;redirect&quot;] = redirect

    log.info(&quot;Redirecting %s -&gt; %s&quot;, url, redirect_location)

    response.drain_conn()
    return self.urlopen(method, redirect_location, **kw)
</pre></div>
</div>
<p>class ProxyManager(PoolManager):
“””
Behaves just like :class:<code class="docutils literal notranslate"><span class="pre">PoolManager</span></code>, but sends all requests through
the defined proxy, using the CONNECT method for HTTPS URLs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param proxy_url:
    The URL of the proxy to be used.

:param proxy_headers:
    A dictionary containing headers that will be sent to the proxy. In case
    of HTTP they are being sent with each request, while in the
    HTTPS/CONNECT case they are sent only once. Could be used for proxy
    authentication.

:param proxy_ssl_context:
    The proxy SSL context is used to establish the TLS connection to the
    proxy when using HTTPS proxies.

:param use_forwarding_for_https:
    (Defaults to False) If set to True will forward requests to the HTTPS
    proxy to be made on behalf of the client instead of creating a TLS
    tunnel via the CONNECT method. **Enabling this flag means that request
    and response headers and content will be visible from the HTTPS proxy**
    whereas tunneling keeps request and response headers and content
    private.  IP address, target hostname, SNI, and port are always visible
    to an HTTPS proxy even when this flag is disabled.

Example:
    &gt;&gt;&gt; proxy = urllib3.ProxyManager(&#39;http://localhost:3128/&#39;)
    &gt;&gt;&gt; r1 = proxy.request(&#39;GET&#39;, &#39;http://google.com/&#39;)
    &gt;&gt;&gt; r2 = proxy.request(&#39;GET&#39;, &#39;http://httpbin.org/&#39;)
    &gt;&gt;&gt; len(proxy.pools)
    1
    &gt;&gt;&gt; r3 = proxy.request(&#39;GET&#39;, &#39;https://httpbin.org/&#39;)
    &gt;&gt;&gt; r4 = proxy.request(&#39;GET&#39;, &#39;https://twitter.com/&#39;)
    &gt;&gt;&gt; len(proxy.pools)
    3

&quot;&quot;&quot;

def __init__(
    self,
    proxy_url,
    num_pools=10,
    headers=None,
    proxy_headers=None,
    proxy_ssl_context=None,
    use_forwarding_for_https=False,
    **connection_pool_kw
):

    if isinstance(proxy_url, HTTPConnectionPool):
        proxy_url = &quot;%s://%s:%i&quot; % (
            proxy_url.scheme,
            proxy_url.host,
            proxy_url.port,
        )
    proxy = parse_url(proxy_url)

    if proxy.scheme not in (&quot;http&quot;, &quot;https&quot;):
        raise ProxySchemeUnknown(proxy.scheme)

    if not proxy.port:
        port = port_by_scheme.get(proxy.scheme, 80)
        proxy = proxy._replace(port=port)

    self.proxy = proxy
    self.proxy_headers = proxy_headers or {}
    self.proxy_ssl_context = proxy_ssl_context
    self.proxy_config = ProxyConfig(proxy_ssl_context, use_forwarding_for_https)

    connection_pool_kw[&quot;_proxy&quot;] = self.proxy
    connection_pool_kw[&quot;_proxy_headers&quot;] = self.proxy_headers
    connection_pool_kw[&quot;_proxy_config&quot;] = self.proxy_config

    super(ProxyManager, self).__init__(num_pools, headers, **connection_pool_kw)

def connection_from_host(self, host, port=None, scheme=&quot;http&quot;, pool_kwargs=None):
    if scheme == &quot;https&quot;:
        return super(ProxyManager, self).connection_from_host(
            host, port, scheme, pool_kwargs=pool_kwargs
        )

    return super(ProxyManager, self).connection_from_host(
        self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs
    )

def _set_proxy_headers(self, url, headers=None):
    &quot;&quot;&quot;
    Sets headers needed by proxies: specifically, the Accept and Host
    headers. Only sets headers not provided by the user.
    &quot;&quot;&quot;
    headers_ = {&quot;Accept&quot;: &quot;*/*&quot;}

    netloc = parse_url(url).netloc
    if netloc:
        headers_[&quot;Host&quot;] = netloc

    if headers:
        headers_.update(headers)
    return headers_

def urlopen(self, method, url, redirect=True, **kw):
    &quot;Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.&quot;
    u = parse_url(url)
    if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):
        # For connections using HTTP CONNECT, httplib sets the necessary
        # headers on the CONNECT to the proxy. If we&#39;re not using CONNECT,
        # we&#39;ll definitely need to set &#39;Host&#39; at the very least.
        headers = kw.get(&quot;headers&quot;, self.headers)
        kw[&quot;headers&quot;] = self._set_proxy_headers(url, headers)

    return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)
</pre></div>
</div>
<p>def proxy_from_url(url, **kw):
return ProxyManager(proxy_url=url, **kw)</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>