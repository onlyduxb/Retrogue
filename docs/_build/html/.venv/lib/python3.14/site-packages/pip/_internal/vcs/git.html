

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SCP (Secure copy protocol) shorthand. e.g. ‘git@example.com:foo/bar.git’ &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SCP (Secure copy protocol) shorthand. e.g. ‘git&#64;example.com:foo/bar.git’</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/vcs/git.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import logging
import os.path
import pathlib
import re
import urllib.parse
import urllib.request
from dataclasses import replace
from typing import Any</p>
<p>from pip._internal.exceptions import BadCommand, InstallationError
from pip._internal.utils.misc import HiddenText, display_path, hide_url
from pip._internal.utils.subprocess import make_command
from pip._internal.vcs.versioncontrol import (
AuthInfo,
RemoteNotFoundError,
RemoteNotValidError,
RevOptions,
VersionControl,
find_path_to_project_root_from_repo_root,
vcs,
)</p>
<p>urlsplit = urllib.parse.urlsplit
urlunsplit = urllib.parse.urlunsplit</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>GIT_VERSION_REGEX = re.compile(
r”^git version “  # Prefix.
r”(\d+)”  # Major.
r”.(\d+)”  # Dot, minor.
r”(?:.(\d+))?”  # Optional dot, patch.
r”.*$”  # Suffix, including any pre- and post-release segments we don’t care about.
)</p>
<p>HASH_REGEX = re.compile(“^[a-fA-F0-9]{40}$”)</p>
<section id="scp-secure-copy-protocol-shorthand-e-g-git-example-com-foo-bar-git">
<h1>SCP (Secure copy protocol) shorthand. e.g. ‘git&#64;example.com:foo/bar.git’<a class="headerlink" href="#scp-secure-copy-protocol-shorthand-e-g-git-example-com-foo-bar-git" title="Link to this heading"></a></h1>
<p>SCP_REGEX = re.compile(
r”””^
# Optional user, e.g. ‘git&#64;’
(\w+&#64;)?
# Server, e.g. ‘github.com’.
(<a href="#id4"><span class="problematic" id="id1">[^/:]</span></a>+):
# The server-side path. e.g. ‘user/project.git’. Must start with an
# alphanumeric character so as not to be confusable with a Windows paths
# like ‘C:/foo/bar’ or ‘C:\foo\bar’.
(\w<a href="#id5"><span class="problematic" id="id2">[^:]</span></a>*)
$”””,
re.VERBOSE,
)</p>
<p>def looks_like_hash(sha: str) -&gt; bool:
return bool(HASH_REGEX.match(sha))</p>
<p>class Git(VersionControl):
name = “git”
dirname = “.git”
repo_name = “clone”
schemes = (
“git+http”,
“git+https”,
“git+ssh”,
“git+git”,
“git+file”,
)
# Prevent the user’s environment variables from interfering with pip:
# https://github.com/pypa/pip/issues/1130
unset_environ = (“GIT_DIR”, “GIT_WORK_TREE”)
default_arg_rev = “HEAD”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@staticmethod
def get_base_rev_args(rev: str) -&gt; list[str]:
    return [rev]

@classmethod
def run_command(cls, *args: Any, **kwargs: Any) -&gt; str:
    if os.environ.get(&quot;PIP_NO_INPUT&quot;):
        extra_environ = kwargs.get(&quot;extra_environ&quot;, {})
        extra_environ[&quot;GIT_TERMINAL_PROMPT&quot;] = &quot;0&quot;
        extra_environ[&quot;GIT_SSH_COMMAND&quot;] = &quot;ssh -oBatchMode=yes&quot;
        kwargs[&quot;extra_environ&quot;] = extra_environ
    return super().run_command(*args, **kwargs)

def is_immutable_rev_checkout(self, url: str, dest: str) -&gt; bool:
    _, rev_options = self.get_url_rev_options(hide_url(url))
    if not rev_options.rev:
        return False
    if not self.is_commit_id_equal(dest, rev_options.rev):
        # the current commit is different from rev,
        # which means rev was something else than a commit hash
        return False
    # return False in the rare case rev is both a commit hash
    # and a tag or a branch; we don&#39;t want to cache in that case
    # because that branch/tag could point to something else in the future
    is_tag_or_branch = bool(self.get_revision_sha(dest, rev_options.rev)[0])
    return not is_tag_or_branch

def get_git_version(self) -&gt; tuple[int, ...]:
    version = self.run_command(
        [&quot;version&quot;],
        command_desc=&quot;git version&quot;,
        show_stdout=False,
        stdout_only=True,
    )
    match = GIT_VERSION_REGEX.match(version)
    if not match:
        logger.warning(&quot;Can&#39;t parse git version: %s&quot;, version)
        return ()
    return (int(match.group(1)), int(match.group(2)))

@classmethod
def get_current_branch(cls, location: str) -&gt; str | None:
    &quot;&quot;&quot;
    Return the current branch, or None if HEAD isn&#39;t at a branch
    (e.g. detached HEAD).
    &quot;&quot;&quot;
    # git-symbolic-ref exits with empty stdout if &quot;HEAD&quot; is a detached
    # HEAD rather than a symbolic ref.  In addition, the -q causes the
    # command to exit with status code 1 instead of 128 in this case
    # and to suppress the message to stderr.
    args = [&quot;symbolic-ref&quot;, &quot;-q&quot;, &quot;HEAD&quot;]
    output = cls.run_command(
        args,
        extra_ok_returncodes=(1,),
        show_stdout=False,
        stdout_only=True,
        cwd=location,
    )
    ref = output.strip()

    if ref.startswith(&quot;refs/heads/&quot;):
        return ref[len(&quot;refs/heads/&quot;) :]

    return None

@classmethod
def get_revision_sha(cls, dest: str, rev: str) -&gt; tuple[str | None, bool]:
    &quot;&quot;&quot;
    Return (sha_or_none, is_branch), where sha_or_none is a commit hash
    if the revision names a remote branch or tag, otherwise None.

    Args:
      dest: the repository directory.
      rev: the revision name.
    &quot;&quot;&quot;
    # Pass rev to pre-filter the list.
    output = cls.run_command(
        [&quot;show-ref&quot;, rev],
        cwd=dest,
        show_stdout=False,
        stdout_only=True,
        on_returncode=&quot;ignore&quot;,
    )
    refs = {}
    # NOTE: We do not use splitlines here since that would split on other
    #       unicode separators, which can be maliciously used to install a
    #       different revision.
    for line in output.strip().split(&quot;\n&quot;):
        line = line.rstrip(&quot;\r&quot;)
        if not line:
            continue
        try:
            ref_sha, ref_name = line.split(&quot; &quot;, maxsplit=2)
        except ValueError:
            # Include the offending line to simplify troubleshooting if
            # this error ever occurs.
            raise ValueError(f&quot;unexpected show-ref line: {line!r}&quot;)

        refs[ref_name] = ref_sha

    branch_ref = f&quot;refs/remotes/origin/{rev}&quot;
    tag_ref = f&quot;refs/tags/{rev}&quot;

    sha = refs.get(branch_ref)
    if sha is not None:
        return (sha, True)

    sha = refs.get(tag_ref)

    return (sha, False)

@classmethod
def _should_fetch(cls, dest: str, rev: str) -&gt; bool:
    &quot;&quot;&quot;
    Return true if rev is a ref or is a commit that we don&#39;t have locally.

    Branches and tags are not considered in this method because they are
    assumed to be always available locally (which is a normal outcome of
    ``git clone`` and ``git fetch --tags``).
    &quot;&quot;&quot;
    if rev.startswith(&quot;refs/&quot;):
        # Always fetch remote refs.
        return True

    if not looks_like_hash(rev):
        # Git fetch would fail with abbreviated commits.
        return False

    if cls.has_commit(dest, rev):
        # Don&#39;t fetch if we have the commit locally.
        return False

    return True

@classmethod
def resolve_revision(
    cls, dest: str, url: HiddenText, rev_options: RevOptions
) -&gt; RevOptions:
    &quot;&quot;&quot;
    Resolve a revision to a new RevOptions object with the SHA1 of the
    branch, tag, or ref if found.

    Args:
      rev_options: a RevOptions object.
    &quot;&quot;&quot;
    rev = rev_options.arg_rev
    # The arg_rev property&#39;s implementation for Git ensures that the
    # rev return value is always non-None.
    assert rev is not None

    sha, is_branch = cls.get_revision_sha(dest, rev)

    if sha is not None:
        rev_options = rev_options.make_new(sha)
        rev_options = replace(rev_options, branch_name=(rev if is_branch else None))

        return rev_options

    # Do not show a warning for the common case of something that has
    # the form of a Git commit hash.
    if not looks_like_hash(rev):
        logger.info(
            &quot;Did not find branch or tag &#39;%s&#39;, assuming revision or ref.&quot;,
            rev,
        )

    if not cls._should_fetch(dest, rev):
        return rev_options

    # fetch the requested revision
    cls.run_command(
        make_command(&quot;fetch&quot;, &quot;-q&quot;, url, rev_options.to_args()),
        cwd=dest,
    )
    # Change the revision to the SHA of the ref we fetched
    sha = cls.get_revision(dest, rev=&quot;FETCH_HEAD&quot;)
    rev_options = rev_options.make_new(sha)

    return rev_options

@classmethod
def is_commit_id_equal(cls, dest: str, name: str | None) -&gt; bool:
    &quot;&quot;&quot;
    Return whether the current commit hash equals the given name.

    Args:
      dest: the repository directory.
      name: a string name.
    &quot;&quot;&quot;
    if not name:
        # Then avoid an unnecessary subprocess call.
        return False

    return cls.get_revision(dest) == name

def fetch_new(
    self, dest: str, url: HiddenText, rev_options: RevOptions, verbosity: int
) -&gt; None:
    rev_display = rev_options.to_display()
    logger.info(&quot;Cloning %s%s to %s&quot;, url, rev_display, display_path(dest))
    if verbosity &lt;= 0:
        flags: tuple[str, ...] = (&quot;--quiet&quot;,)
    elif verbosity == 1:
        flags = ()
    else:
        flags = (&quot;--verbose&quot;, &quot;--progress&quot;)
    if self.get_git_version() &gt;= (2, 17):
        # Git added support for partial clone in 2.17
        # https://git-scm.com/docs/partial-clone
        # Speeds up cloning by functioning without a complete copy of repository
        self.run_command(
            make_command(
                &quot;clone&quot;,
                &quot;--filter=blob:none&quot;,
                *flags,
                url,
                dest,
            )
        )
    else:
        self.run_command(make_command(&quot;clone&quot;, *flags, url, dest))

    if rev_options.rev:
        # Then a specific revision was requested.
        rev_options = self.resolve_revision(dest, url, rev_options)
        branch_name = getattr(rev_options, &quot;branch_name&quot;, None)
        logger.debug(&quot;Rev options %s, branch_name %s&quot;, rev_options, branch_name)
        if branch_name is None:
            # Only do a checkout if the current commit id doesn&#39;t match
            # the requested revision.
            if not self.is_commit_id_equal(dest, rev_options.rev):
                cmd_args = make_command(
                    &quot;checkout&quot;,
                    &quot;-q&quot;,
                    rev_options.to_args(),
                )
                self.run_command(cmd_args, cwd=dest)
        elif self.get_current_branch(dest) != branch_name:
            # Then a specific branch was requested, and that branch
            # is not yet checked out.
            track_branch = f&quot;origin/{branch_name}&quot;
            cmd_args = [
                &quot;checkout&quot;,
                &quot;-b&quot;,
                branch_name,
                &quot;--track&quot;,
                track_branch,
            ]
            self.run_command(cmd_args, cwd=dest)
    else:
        sha = self.get_revision(dest)
        rev_options = rev_options.make_new(sha)

    logger.info(&quot;Resolved %s to commit %s&quot;, url, rev_options.rev)

    #: repo may contain submodules
    self.update_submodules(dest, verbosity=verbosity)

def switch(
    self,
    dest: str,
    url: HiddenText,
    rev_options: RevOptions,
    verbosity: int = 0,
) -&gt; None:
    self.run_command(
        make_command(&quot;config&quot;, &quot;remote.origin.url&quot;, url),
        cwd=dest,
    )

    extra_flags = []

    if verbosity &lt;= 0:
        extra_flags.append(&quot;-q&quot;)

    cmd_args = make_command(&quot;checkout&quot;, *extra_flags, rev_options.to_args())
    self.run_command(cmd_args, cwd=dest)

    self.update_submodules(dest, verbosity=verbosity)

def update(
    self,
    dest: str,
    url: HiddenText,
    rev_options: RevOptions,
    verbosity: int = 0,
) -&gt; None:
    extra_flags = []

    if verbosity &lt;= 0:
        extra_flags.append(&quot;-q&quot;)

    # First fetch changes from the default remote
    if self.get_git_version() &gt;= (1, 9):
        # fetch tags in addition to everything else
        self.run_command([&quot;fetch&quot;, &quot;--tags&quot;, *extra_flags], cwd=dest)
    else:
        self.run_command([&quot;fetch&quot;, *extra_flags], cwd=dest)
    # Then reset to wanted revision (maybe even origin/master)
    rev_options = self.resolve_revision(dest, url, rev_options)
    cmd_args = make_command(
        &quot;reset&quot;,
        &quot;--hard&quot;,
        *extra_flags,
        rev_options.to_args(),
    )
    self.run_command(cmd_args, cwd=dest)
    #: update submodules
    self.update_submodules(dest, verbosity=verbosity)

@classmethod
def get_remote_url(cls, location: str) -&gt; str:
    &quot;&quot;&quot;
    Return URL of the first remote encountered.

    Raises RemoteNotFoundError if the repository does not have a remote
    url configured.
    &quot;&quot;&quot;
    # We need to pass 1 for extra_ok_returncodes since the command
    # exits with return code 1 if there are no matching lines.
    stdout = cls.run_command(
        [&quot;config&quot;, &quot;--get-regexp&quot;, r&quot;remote\..*\.url&quot;],
        extra_ok_returncodes=(1,),
        show_stdout=False,
        stdout_only=True,
        cwd=location,
    )
    remotes = stdout.splitlines()
    try:
        found_remote = remotes[0]
    except IndexError:
        raise RemoteNotFoundError

    for remote in remotes:
        if remote.startswith(&quot;remote.origin.url &quot;):
            found_remote = remote
            break
    url = found_remote.split(&quot; &quot;)[1]
    return cls._git_remote_to_pip_url(url.strip())

@staticmethod
def _git_remote_to_pip_url(url: str) -&gt; str:
    &quot;&quot;&quot;
    Convert a remote url from what git uses to what pip accepts.

    There are 3 legal forms **url** may take:

        1. A fully qualified url: ssh://git@example.com/foo/bar.git
        2. A local project.git folder: /path/to/bare/repository.git
        3. SCP shorthand for form 1: git@example.com:foo/bar.git

    Form 1 is output as-is. Form 2 must be converted to URI and form 3 must
    be converted to form 1.

    See the corresponding test test_git_remote_url_to_pip() for examples of
    sample inputs/outputs.
    &quot;&quot;&quot;
    if re.match(r&quot;\w+://&quot;, url):
        # This is already valid. Pass it though as-is.
        return url
    if os.path.exists(url):
        # A local bare remote (git clone --mirror).
        # Needs a file:// prefix.
        return pathlib.PurePath(url).as_uri()
    scp_match = SCP_REGEX.match(url)
    if scp_match:
        # Add an ssh:// prefix and replace the &#39;:&#39; with a &#39;/&#39;.
        return scp_match.expand(r&quot;ssh://\1\2/\3&quot;)
    # Otherwise, bail out.
    raise RemoteNotValidError(url)

@classmethod
def has_commit(cls, location: str, rev: str) -&gt; bool:
    &quot;&quot;&quot;
    Check if rev is a commit that is available in the local repository.
    &quot;&quot;&quot;
    try:
        cls.run_command(
            [&quot;rev-parse&quot;, &quot;-q&quot;, &quot;--verify&quot;, &quot;sha^&quot; + rev],
            cwd=location,
            log_failed_cmd=False,
        )
    except InstallationError:
        return False
    else:
        return True

@classmethod
def get_revision(cls, location: str, rev: str | None = None) -&gt; str:
    if rev is None:
        rev = &quot;HEAD&quot;
    current_rev = cls.run_command(
        [&quot;rev-parse&quot;, rev],
        show_stdout=False,
        stdout_only=True,
        cwd=location,
    )
    return current_rev.strip()

@classmethod
def get_subdirectory(cls, location: str) -&gt; str | None:
    &quot;&quot;&quot;
    Return the path to Python project root, relative to the repo root.
    Return None if the project root is in the repo root.
    &quot;&quot;&quot;
    # find the repo root
    git_dir = cls.run_command(
        [&quot;rev-parse&quot;, &quot;--git-dir&quot;],
        show_stdout=False,
        stdout_only=True,
        cwd=location,
    ).strip()
    if not os.path.isabs(git_dir):
        git_dir = os.path.join(location, git_dir)
    repo_root = os.path.abspath(os.path.join(git_dir, &quot;..&quot;))
    return find_path_to_project_root_from_repo_root(location, repo_root)

@classmethod
def get_url_rev_and_auth(cls, url: str) -&gt; tuple[str, str | None, AuthInfo]:
    &quot;&quot;&quot;
    Prefixes stub URLs like &#39;user@hostname:user/repo.git&#39; with &#39;ssh://&#39;.
    That&#39;s required because although they use SSH they sometimes don&#39;t
    work with a ssh:// scheme (e.g. GitHub). But we need a scheme for
    parsing. Hence we remove it again afterwards and return it as a stub.
    &quot;&quot;&quot;
    # Works around an apparent Git bug
    # (see https://article.gmane.org/gmane.comp.version-control.git/146500)
    scheme, netloc, path, query, fragment = urlsplit(url)
    if scheme.endswith(&quot;file&quot;):
        initial_slashes = path[: -len(path.lstrip(&quot;/&quot;))]
        newpath = initial_slashes + urllib.request.url2pathname(path).replace(
            &quot;\\&quot;, &quot;/&quot;
        ).lstrip(&quot;/&quot;)
        after_plus = scheme.find(&quot;+&quot;) + 1
        url = scheme[:after_plus] + urlunsplit(
            (scheme[after_plus:], netloc, newpath, query, fragment),
        )

    if &quot;://&quot; not in url:
        assert &quot;file:&quot; not in url
        url = url.replace(&quot;git+&quot;, &quot;git+ssh://&quot;)
        url, rev, user_pass = super().get_url_rev_and_auth(url)
        url = url.replace(&quot;ssh://&quot;, &quot;&quot;)
    else:
        url, rev, user_pass = super().get_url_rev_and_auth(url)

    return url, rev, user_pass

@classmethod
def update_submodules(cls, location: str, verbosity: int = 0) -&gt; None:
    argv = [&quot;submodule&quot;, &quot;update&quot;, &quot;--init&quot;, &quot;--recursive&quot;]

    if verbosity &lt;= 0:
        argv.append(&quot;-q&quot;)

    if not os.path.exists(os.path.join(location, &quot;.gitmodules&quot;)):
        return
    cls.run_command(
        argv,
        cwd=location,
    )

@classmethod
def get_repository_root(cls, location: str) -&gt; str | None:
    loc = super().get_repository_root(location)
    if loc:
        return loc
    try:
        r = cls.run_command(
            [&quot;rev-parse&quot;, &quot;--show-toplevel&quot;],
            cwd=location,
            show_stdout=False,
            stdout_only=True,
            on_returncode=&quot;raise&quot;,
            log_failed_cmd=False,
        )
    except BadCommand:
        logger.debug(
            &quot;could not determine if %s is under git control &quot;
            &quot;because git is not available&quot;,
            location,
        )
        return None
    except InstallationError:
        return None
    return os.path.normpath(r.rstrip(&quot;\r\n&quot;))

@staticmethod
def should_add_vcs_url_prefix(repo_url: str) -&gt; bool:
    &quot;&quot;&quot;In either https or ssh form, requirements must be prefixed with git+.&quot;&quot;&quot;
    return True
</pre></div>
</div>
<p>vcs.register(Git)</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>