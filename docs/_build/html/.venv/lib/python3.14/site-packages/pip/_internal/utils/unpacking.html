

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/utils/unpacking.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Utilities related archives.”””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import logging
import os
import shutil
import stat
import sys
import tarfile
import zipfile
from collections.abc import Iterable
from zipfile import ZipInfo</p>
<p>from pip._internal.exceptions import InstallationError
from pip._internal.utils.filetypes import (
BZ2_EXTENSIONS,
TAR_EXTENSIONS,
XZ_EXTENSIONS,
ZIP_EXTENSIONS,
)
from pip._internal.utils.misc import ensure_dir</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>SUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS</p>
<p>try:
import bz2  # noqa</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SUPPORTED_EXTENSIONS += BZ2_EXTENSIONS
</pre></div>
</div>
<p>except ImportError:
logger.debug(“bz2 module is not available”)</p>
<p>try:
# Only for Python 3.3+
import lzma  # noqa</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SUPPORTED_EXTENSIONS += XZ_EXTENSIONS
</pre></div>
</div>
<p>except ImportError:
logger.debug(“lzma module is not available”)</p>
<p>def current_umask() -&gt; int:
“””Get the current umask which involves having to set it temporarily.”””
mask = os.umask(0)
os.umask(mask)
return mask</p>
<p>def split_leading_dir(path: str) -&gt; list[str]:
path = path.lstrip(“/”).lstrip(”&quot;)
if “/” in path and (
(”&quot; in path and path.find(“/”) &lt; path.find(”&quot;)) or “&quot; not in path
):
return path.split(“/”, 1)
elif “&quot; in path:
return path.split(”&quot;, 1)
else:
return [path, “”]</p>
<p>def has_leading_dir(paths: Iterable[str]) -&gt; bool:
“””Returns true if all the paths have the same leading path name
(i.e., everything is in one subdirectory in an archive)”””
common_prefix = None
for path in paths:
prefix, rest = split_leading_dir(path)
if not prefix:
return False
elif common_prefix is None:
common_prefix = prefix
elif prefix != common_prefix:
return False
return True</p>
<p>def is_within_directory(directory: str, target: str) -&gt; bool:
“””
Return true if the absolute path of target is within the directory
“””
abs_directory = os.path.abspath(directory)
abs_target = os.path.abspath(target)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>prefix = os.path.commonprefix([abs_directory, abs_target])
return prefix == abs_directory
</pre></div>
</div>
<p>def _get_default_mode_plus_executable() -&gt; int:
return 0o777 &amp; ~current_umask() | 0o111</p>
<p>def set_extracted_file_to_default_mode_plus_executable(path: str) -&gt; None:
“””
Make file present at path have execute for user/group/world
(chmod +x) is no-op on windows per python docs
“””
os.chmod(path, _get_default_mode_plus_executable())</p>
<p>def zip_item_is_executable(info: ZipInfo) -&gt; bool:
mode = info.external_attr &gt;&gt; 16
# if mode and regular file and any execute permissions for
# user/group/world?
return bool(mode and stat.S_ISREG(mode) and mode &amp; 0o111)</p>
<p>def unzip_file(filename: str, location: str, flatten: bool = True) -&gt; None:
“””
Unzip the file (with path <code class="docutils literal notranslate"><span class="pre">filename</span></code>) to the destination <code class="docutils literal notranslate"><span class="pre">location</span></code>.  All
files are written based on system defaults and umask (i.e. permissions are
not preserved), except that regular file members with any execute
permissions (user, group, or world) have “chmod +x” applied after being
written. Note that for windows, any execute changes using os.chmod are
no-ops per the python docs.
“””
ensure_dir(location)
zipfp = open(filename, “rb”)
try:
zip = zipfile.ZipFile(zipfp, allowZip64=True)
leading = has_leading_dir(zip.namelist()) and flatten
for info in zip.infolist():
name = info.filename
fn = name
if leading:
fn = split_leading_dir(name)[1]
fn = os.path.join(location, fn)
dir = os.path.dirname(fn)
if not is_within_directory(location, fn):
message = (
“The zip file ({}) has a file ({}) trying to install “
“outside target directory ({})”
)
raise InstallationError(message.format(filename, fn, location))
if fn.endswith((“/”, “&quot;)):
# A directory
ensure_dir(fn)
else:
ensure_dir(dir)
# Don’t use read() to avoid allocating an arbitrarily large
# chunk of memory for the file’s content
fp = zip.open(name)
try:
with open(fn, “wb”) as destfp:
shutil.copyfileobj(fp, destfp)
finally:
fp.close()
if zip_item_is_executable(info):
set_extracted_file_to_default_mode_plus_executable(fn)
finally:
zipfp.close()</p>
<p>def untar_file(filename: str, location: str) -&gt; None:
“””
Untar the file (with path <code class="docutils literal notranslate"><span class="pre">filename</span></code>) to the destination <code class="docutils literal notranslate"><span class="pre">location</span></code>.
All files are written based on system defaults and umask (i.e. permissions
are not preserved), except that regular file members with any execute
permissions (user, group, or world) have “chmod +x” applied on top of the
default.  Note that for windows, any execute changes using os.chmod are
no-ops per the python docs.
“””
ensure_dir(location)
if filename.lower().endswith(“.gz”) or filename.lower().endswith(“.tgz”):
mode = “r:gz”
elif filename.lower().endswith(BZ2_EXTENSIONS):
mode = “r:bz2”
elif filename.lower().endswith(XZ_EXTENSIONS):
mode = “r:xz”
elif filename.lower().endswith(“.tar”):
mode = “r”
else:
logger.warning(
“Cannot determine compression type for file %s”,
filename,
)
mode = “r:*”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tar = tarfile.open(filename, mode, encoding=&quot;utf-8&quot;)  # type: ignore
try:
    leading = has_leading_dir([member.name for member in tar.getmembers()])

    # PEP 706 added `tarfile.data_filter`, and made some other changes to
    # Python&#39;s tarfile module (see below). The features were backported to
    # security releases.
    try:
        data_filter = tarfile.data_filter
    except AttributeError:
        _untar_without_filter(filename, location, tar, leading)
    else:
        default_mode_plus_executable = _get_default_mode_plus_executable()

        if leading:
            # Strip the leading directory from all files in the archive,
            # including hardlink targets (which are relative to the
            # unpack location).
            for member in tar.getmembers():
                name_lead, name_rest = split_leading_dir(member.name)
                member.name = name_rest
                if member.islnk():
                    lnk_lead, lnk_rest = split_leading_dir(member.linkname)
                    if lnk_lead == name_lead:
                        member.linkname = lnk_rest

        def pip_filter(member: tarfile.TarInfo, path: str) -&gt; tarfile.TarInfo:
            orig_mode = member.mode
            try:
                try:
                    member = data_filter(member, location)
                except tarfile.LinkOutsideDestinationError:
                    if sys.version_info[:3] in {
                        (3, 9, 17),
                        (3, 10, 12),
                        (3, 11, 4),
                    }:
                        # The tarfile filter in specific Python versions
                        # raises LinkOutsideDestinationError on valid input
                        # (https://github.com/python/cpython/issues/107845)
                        # Ignore the error there, but do use the
                        # more lax `tar_filter`
                        member = tarfile.tar_filter(member, location)
                    else:
                        raise
            except tarfile.TarError as exc:
                message = &quot;Invalid member in the tar file {}: {}&quot;
                # Filter error messages mention the member name.
                # No need to add it here.
                raise InstallationError(
                    message.format(
                        filename,
                        exc,
                    )
                )
            if member.isfile() and orig_mode &amp; 0o111:
                member.mode = default_mode_plus_executable
            else:
                # See PEP 706 note above.
                # The PEP changed this from `int` to `Optional[int]`,
                # where None means &quot;use the default&quot;. Mypy doesn&#39;t
                # know this yet.
                member.mode = None  # type: ignore [assignment]
            return member

        tar.extractall(location, filter=pip_filter)

finally:
    tar.close()
</pre></div>
</div>
<p>def is_symlink_target_in_tar(tar: tarfile.TarFile, tarinfo: tarfile.TarInfo) -&gt; bool:
“””Check if the file pointed to by the symbolic link is in the tar archive”””
linkname = os.path.join(os.path.dirname(tarinfo.name), tarinfo.linkname)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>linkname = os.path.normpath(linkname)
linkname = linkname.replace(&quot;\\&quot;, &quot;/&quot;)

try:
    tar.getmember(linkname)
    return True
except KeyError:
    return False
</pre></div>
</div>
<p>def _untar_without_filter(
filename: str,
location: str,
tar: tarfile.TarFile,
leading: bool,
) -&gt; None:
“””Fallback for Python without tarfile.data_filter”””
# NOTE: This function can be removed once pip requires CPython ≥ 3.12.​
# PEP 706 added tarfile.data_filter, made tarfile extraction operations more secure.
# This feature is fully supported from CPython 3.12 onward.
for member in tar.getmembers():
fn = member.name
if leading:
fn = split_leading_dir(fn)[1]
path = os.path.join(location, fn)
if not is_within_directory(location, path):
message = (
“The tar file ({}) has a file ({}) trying to install “
“outside target directory ({})”
)
raise InstallationError(message.format(filename, path, location))
if member.isdir():
ensure_dir(path)
elif member.issym():
if not is_symlink_target_in_tar(tar, member):
message = (
“The tar file ({}) has a file ({}) trying to install “
“outside target directory ({})”
)
raise InstallationError(
message.format(filename, member.name, member.linkname)
)
try:
tar._extract_member(member, path)
except Exception as exc:
# Some corrupt tar files seem to produce this
# (specifically bad symlinks)
logger.warning(
“In the tar file %s the member %s is invalid: %s”,
filename,
member.name,
exc,
)
continue
else:
try:
fp = tar.extractfile(member)
except (KeyError, AttributeError) as exc:
# Some corrupt tar files seem to produce this
# (specifically bad symlinks)
logger.warning(
“In the tar file %s the member %s is invalid: %s”,
filename,
member.name,
exc,
)
continue
ensure_dir(os.path.dirname(path))
assert fp is not None
with open(path, “wb”) as destfp:
shutil.copyfileobj(fp, destfp)
fp.close()
# Update the timestamp (useful for cython compiled files)
tar.utime(member, path)
# member have any execute permissions for user/group/world?
if member.mode &amp; 0o111:
set_extracted_file_to_default_mode_plus_executable(path)</p>
<p>def unpack_file(
filename: str,
location: str,
content_type: str | None = None,
) -&gt; None:
filename = os.path.realpath(filename)
if (
content_type == “application/zip”
or filename.lower().endswith(ZIP_EXTENSIONS)
or zipfile.is_zipfile(filename)
):
unzip_file(filename, location, flatten=not filename.endswith(“.whl”))
elif (
content_type == “application/x-gzip”
or tarfile.is_tarfile(filename)
or filename.lower().endswith(TAR_EXTENSIONS + BZ2_EXTENSIONS + XZ_EXTENSIONS)
):
untar_file(filename, location)
else:
# FIXME: handle?
# FIXME: magic signatures?
logger.critical(
“Cannot unpack file %s (downloaded from %s, content-type: %s); “
“cannot detect archive format”,
filename,
location,
content_type,
)
raise InstallationError(f”Cannot determine archive format of {location}”)</p>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>