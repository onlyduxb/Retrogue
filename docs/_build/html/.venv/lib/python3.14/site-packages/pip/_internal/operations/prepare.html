

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The following comment should be removed at some point in the future. &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">The following comment should be removed at some point in the future.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/operations/prepare.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Prepares a distribution for installation”””</p>
<section id="the-following-comment-should-be-removed-at-some-point-in-the-future">
<h1>The following comment should be removed at some point in the future.<a class="headerlink" href="#the-following-comment-should-be-removed-at-some-point-in-the-future" title="Link to this heading"></a></h1>
</section>
<section id="mypy-strict-optional-false">
<h1>mypy: strict-optional=False<a class="headerlink" href="#mypy-strict-optional-false" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import annotations</p>
<p>import mimetypes
import os
import shutil
from collections.abc import Iterable
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING</p>
<p>from pip._vendor.packaging.utils import canonicalize_name</p>
<p>from pip._internal.build_env import BuildEnvironmentInstaller
from pip._internal.distributions import make_distribution_for_install_requirement
from pip._internal.distributions.installed import InstalledDistribution
from pip._internal.exceptions import (
DirectoryUrlHashUnsupported,
HashMismatch,
HashUnpinned,
InstallationError,
MetadataInconsistent,
NetworkConnectionError,
VcsHashUnsupported,
)
from pip._internal.index.package_finder import PackageFinder
from pip._internal.metadata import BaseDistribution, get_metadata_distribution
from pip._internal.models.direct_url import ArchiveInfo
from pip._internal.models.link import Link
from pip._internal.models.wheel import Wheel
from pip._internal.network.download import Downloader
from pip._internal.network.lazy_wheel import (
HTTPRangeRequestUnsupported,
dist_from_wheel_url,
)
from pip._internal.network.session import PipSession
from pip._internal.operations.build.build_tracker import BuildTracker
from pip._internal.req.req_install import InstallRequirement
from pip._internal.utils._log import getLogger
from pip._internal.utils.direct_url_helpers import (
direct_url_for_editable,
direct_url_from_link,
)
from pip._internal.utils.hashes import Hashes, MissingHashes
from pip._internal.utils.logging import indent_log
from pip._internal.utils.misc import (
display_path,
hash_file,
hide_url,
redact_auth_from_requirement,
)
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.unpacking import unpack_file
from pip._internal.vcs import vcs</p>
<p>if TYPE_CHECKING:
from pip._internal.cli.progress_bars import BarType</p>
<p>logger = getLogger(<strong>name</strong>)</p>
<p>def _get_prepared_distribution(
req: InstallRequirement,
build_tracker: BuildTracker,
build_env_installer: BuildEnvironmentInstaller,
build_isolation: bool,
check_build_deps: bool,
) -&gt; BaseDistribution:
“””Prepare a distribution for installation.”””
abstract_dist = make_distribution_for_install_requirement(req)
tracker_id = abstract_dist.build_tracker_id
if tracker_id is not None:
with build_tracker.track(req, tracker_id):
abstract_dist.prepare_distribution_metadata(
build_env_installer, build_isolation, check_build_deps
)
return abstract_dist.get_metadata_distribution()</p>
<p>def unpack_vcs_link(link: Link, location: str, verbosity: int) -&gt; None:
vcs_backend = vcs.get_backend_for_scheme(link.scheme)
assert vcs_backend is not None
vcs_backend.unpack(location, url=hide_url(link.url), verbosity=verbosity)</p>
<p>&#64;dataclass
class File:
path: str
content_type: str | None = None</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __post_init__(self) -&gt; None:
    if self.content_type is None:
        # Try to guess the file&#39;s MIME type. If the system MIME tables
        # can&#39;t be loaded, give up.
        try:
            self.content_type = mimetypes.guess_type(self.path)[0]
        except OSError:
            pass
</pre></div>
</div>
<p>def get_http_url(
link: Link,
download: Downloader,
download_dir: str | None = None,
hashes: Hashes | None = None,
) -&gt; File:
temp_dir = TempDirectory(kind=”unpack”, globally_managed=True)
# If a download dir is specified, is the file already downloaded there?
already_downloaded_path = None
if download_dir:
already_downloaded_path = _check_download_dir(link, download_dir, hashes)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if already_downloaded_path:
    from_path = already_downloaded_path
    content_type = None
else:
    # let&#39;s download to a tmp dir
    from_path, content_type = download(link, temp_dir.path)
    if hashes:
        hashes.check_against_path(from_path)

return File(from_path, content_type)
</pre></div>
</div>
<p>def get_file_url(
link: Link, download_dir: str | None = None, hashes: Hashes | None = None
) -&gt; File:
“””Get file and optionally check its hash.”””
# If a download dir is specified, is the file already there and valid?
already_downloaded_path = None
if download_dir:
already_downloaded_path = _check_download_dir(link, download_dir, hashes)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if already_downloaded_path:
    from_path = already_downloaded_path
else:
    from_path = link.file_path

# If --require-hashes is off, `hashes` is either empty, the
# link&#39;s embedded hash, or MissingHashes; it is required to
# match. If --require-hashes is on, we are satisfied by any
# hash in `hashes` matching: a URL-based or an option-based
# one; no internet-sourced hash will be in `hashes`.
if hashes:
    hashes.check_against_path(from_path)
return File(from_path, None)
</pre></div>
</div>
<p>def unpack_url(
link: Link,
location: str,
download: Downloader,
verbosity: int,
download_dir: str | None = None,
hashes: Hashes | None = None,
) -&gt; File | None:
“””Unpack link into location, downloading if required.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param hashes: A Hashes object, one of whose embedded hashes must match,
    or HashMismatch will be raised. If the Hashes is empty, no matches are
    required, and unhashable types of requirements (like VCS ones, which
    would ordinarily raise HashUnsupported) are allowed.
&quot;&quot;&quot;
# non-editable vcs urls
if link.is_vcs:
    unpack_vcs_link(link, location, verbosity=verbosity)
    return None

assert not link.is_existing_dir()

# file urls
if link.is_file:
    file = get_file_url(link, download_dir, hashes=hashes)

# http urls
else:
    file = get_http_url(
        link,
        download,
        download_dir,
        hashes=hashes,
    )

# unpack the archive to the build dir location. even when only downloading
# archives, they have to be unpacked to parse dependencies, except wheels
if not link.is_wheel:
    unpack_file(file.path, location, file.content_type)

return file
</pre></div>
</div>
<p>def _check_download_dir(
link: Link,
download_dir: str,
hashes: Hashes | None,
warn_on_hash_mismatch: bool = True,
) -&gt; str | None:
“””Check download_dir for previously downloaded file with correct hash
If a correct file is found return its path else None
“””
download_path = os.path.join(download_dir, link.filename)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if not os.path.exists(download_path):
    return None

# If already downloaded, does its hash match?
logger.info(&quot;File was already downloaded %s&quot;, download_path)
if hashes:
    try:
        hashes.check_against_path(download_path)
    except HashMismatch:
        if warn_on_hash_mismatch:
            logger.warning(
                &quot;Previously-downloaded file %s has bad hash. Re-downloading.&quot;,
                download_path,
            )
        os.unlink(download_path)
        return None
return download_path
</pre></div>
</div>
<p>class RequirementPreparer:
“””Prepares a Requirement”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(  # noqa: PLR0913 (too many parameters)
    self,
    *,
    build_dir: str,
    download_dir: str | None,
    src_dir: str,
    build_isolation: bool,
    build_isolation_installer: BuildEnvironmentInstaller,
    check_build_deps: bool,
    build_tracker: BuildTracker,
    session: PipSession,
    progress_bar: BarType,
    finder: PackageFinder,
    require_hashes: bool,
    use_user_site: bool,
    lazy_wheel: bool,
    verbosity: int,
    legacy_resolver: bool,
    resume_retries: int,
) -&gt; None:
    super().__init__()

    self.src_dir = src_dir
    self.build_dir = build_dir
    self.build_tracker = build_tracker
    self._session = session
    self._download = Downloader(session, progress_bar, resume_retries)
    self.finder = finder

    # Where still-packed archives should be written to. If None, they are
    # not saved, and are deleted immediately after unpacking.
    self.download_dir = download_dir

    # Is build isolation allowed?
    self.build_isolation = build_isolation
    self.build_env_installer = build_isolation_installer

    # Should check build dependencies?
    self.check_build_deps = check_build_deps

    # Should hash-checking be required?
    self.require_hashes = require_hashes

    # Should install in user site-packages?
    self.use_user_site = use_user_site

    # Should wheels be downloaded lazily?
    self.use_lazy_wheel = lazy_wheel

    # How verbose should underlying tooling be?
    self.verbosity = verbosity

    # Are we using the legacy resolver?
    self.legacy_resolver = legacy_resolver

    # Memoized downloaded files, as mapping of url: path.
    self._downloaded: dict[str, str] = {}

    # Previous &quot;header&quot; printed for a link-based InstallRequirement
    self._previous_requirement_header = (&quot;&quot;, &quot;&quot;)

def _log_preparing_link(self, req: InstallRequirement) -&gt; None:
    &quot;&quot;&quot;Provide context for the requirement being prepared.&quot;&quot;&quot;
    if req.link.is_file and not req.is_wheel_from_cache:
        message = &quot;Processing %s&quot;
        information = str(display_path(req.link.file_path))
    else:
        message = &quot;Collecting %s&quot;
        information = redact_auth_from_requirement(req.req) if req.req else str(req)

    # If we used req.req, inject requirement source if available (this
    # would already be included if we used req directly)
    if req.req and req.comes_from:
        if isinstance(req.comes_from, str):
            comes_from: str | None = req.comes_from
        else:
            comes_from = req.comes_from.from_path()
        if comes_from:
            information += f&quot; (from {comes_from})&quot;

    if (message, information) != self._previous_requirement_header:
        self._previous_requirement_header = (message, information)
        logger.info(message, information)

    if req.is_wheel_from_cache:
        with indent_log():
            logger.info(&quot;Using cached %s&quot;, req.link.filename)

def _ensure_link_req_src_dir(
    self, req: InstallRequirement, parallel_builds: bool
) -&gt; None:
    &quot;&quot;&quot;Ensure source_dir of a linked InstallRequirement.&quot;&quot;&quot;
    # Since source_dir is only set for editable requirements.
    if req.link.is_wheel:
        # We don&#39;t need to unpack wheels, so no need for a source
        # directory.
        return
    assert req.source_dir is None
    if req.link.is_existing_dir():
        # build local directories in-tree
        req.source_dir = req.link.file_path
        return

    # We always delete unpacked sdists after pip runs.
    req.ensure_has_source_dir(
        self.build_dir,
        autodelete=True,
        parallel_builds=parallel_builds,
    )
    req.ensure_pristine_source_checkout()

def _get_linked_req_hashes(self, req: InstallRequirement) -&gt; Hashes:
    # By the time this is called, the requirement&#39;s link should have
    # been checked so we can tell what kind of requirements req is
    # and raise some more informative errors than otherwise.
    # (For example, we can raise VcsHashUnsupported for a VCS URL
    # rather than HashMissing.)
    if not self.require_hashes:
        return req.hashes(trust_internet=True)

    # We could check these first 2 conditions inside unpack_url
    # and save repetition of conditions, but then we would
    # report less-useful error messages for unhashable
    # requirements, complaining that there&#39;s no hash provided.
    if req.link.is_vcs:
        raise VcsHashUnsupported()
    if req.link.is_existing_dir():
        raise DirectoryUrlHashUnsupported()

    # Unpinned packages are asking for trouble when a new version
    # is uploaded.  This isn&#39;t a security check, but it saves users
    # a surprising hash mismatch in the future.
    # file:/// URLs aren&#39;t pinnable, so don&#39;t complain about them
    # not being pinned.
    if not req.is_direct and not req.is_pinned:
        raise HashUnpinned()

    # If known-good hashes are missing for this requirement,
    # shim it with a facade object that will provoke hash
    # computation and then raise a HashMissing exception
    # showing the user what the hash should be.
    return req.hashes(trust_internet=False) or MissingHashes()

def _fetch_metadata_only(
    self,
    req: InstallRequirement,
) -&gt; BaseDistribution | None:
    if self.legacy_resolver:
        logger.debug(
            &quot;Metadata-only fetching is not used in the legacy resolver&quot;,
        )
        return None
    if self.require_hashes:
        logger.debug(
            &quot;Metadata-only fetching is not used as hash checking is required&quot;,
        )
        return None
    # Try PEP 658 metadata first, then fall back to lazy wheel if unavailable.
    return self._fetch_metadata_using_link_data_attr(
        req
    ) or self._fetch_metadata_using_lazy_wheel(req.link)

def _fetch_metadata_using_link_data_attr(
    self,
    req: InstallRequirement,
) -&gt; BaseDistribution | None:
    &quot;&quot;&quot;Fetch metadata from the data-dist-info-metadata attribute, if possible.&quot;&quot;&quot;
    # (1) Get the link to the metadata file, if provided by the backend.
    metadata_link = req.link.metadata_link()
    if metadata_link is None:
        return None
    assert req.req is not None
    logger.verbose(
        &quot;Obtaining dependency information for %s from %s&quot;,
        req.req,
        metadata_link,
    )
    # (2) Download the contents of the METADATA file, separate from the dist itself.
    metadata_file = get_http_url(
        metadata_link,
        self._download,
        hashes=metadata_link.as_hashes(),
    )
    with open(metadata_file.path, &quot;rb&quot;) as f:
        metadata_contents = f.read()
    # (3) Generate a dist just from those file contents.
    metadata_dist = get_metadata_distribution(
        metadata_contents,
        req.link.filename,
        req.req.name,
    )
    # (4) Ensure the Name: field from the METADATA file matches the name from the
    #     install requirement.
    #
    #     NB: raw_name will fall back to the name from the install requirement if
    #     the Name: field is not present, but it&#39;s noted in the raw_name docstring
    #     that that should NEVER happen anyway.
    if canonicalize_name(metadata_dist.raw_name) != canonicalize_name(req.req.name):
        raise MetadataInconsistent(
            req, &quot;Name&quot;, req.req.name, metadata_dist.raw_name
        )
    return metadata_dist

def _fetch_metadata_using_lazy_wheel(
    self,
    link: Link,
) -&gt; BaseDistribution | None:
    &quot;&quot;&quot;Fetch metadata using lazy wheel, if possible.&quot;&quot;&quot;
    # --use-feature=fast-deps must be provided.
    if not self.use_lazy_wheel:
        return None
    if link.is_file or not link.is_wheel:
        logger.debug(
            &quot;Lazy wheel is not used as %r does not point to a remote wheel&quot;,
            link,
        )
        return None

    wheel = Wheel(link.filename)
    name = wheel.name
    logger.info(
        &quot;Obtaining dependency information from %s %s&quot;,
        name,
        wheel.version,
    )
    url = link.url.split(&quot;#&quot;, 1)[0]
    try:
        return dist_from_wheel_url(name, url, self._session)
    except HTTPRangeRequestUnsupported:
        logger.debug(&quot;%s does not support range requests&quot;, url)
        return None

def _complete_partial_requirements(
    self,
    partially_downloaded_reqs: Iterable[InstallRequirement],
    parallel_builds: bool = False,
) -&gt; None:
    &quot;&quot;&quot;Download any requirements which were only fetched by metadata.&quot;&quot;&quot;
    # Download to a temporary directory. These will be copied over as
    # needed for downstream &#39;download&#39;, &#39;wheel&#39;, and &#39;install&#39; commands.
    temp_dir = TempDirectory(kind=&quot;unpack&quot;, globally_managed=True).path

    # Map each link to the requirement that owns it. This allows us to set
    # `req.local_file_path` on the appropriate requirement after passing
    # all the links at once into BatchDownloader.
    links_to_fully_download: dict[Link, InstallRequirement] = {}
    for req in partially_downloaded_reqs:
        assert req.link
        links_to_fully_download[req.link] = req

    batch_download = self._download.batch(links_to_fully_download.keys(), temp_dir)
    for link, (filepath, _) in batch_download:
        logger.debug(&quot;Downloading link %s to %s&quot;, link, filepath)
        req = links_to_fully_download[link]
        # Record the downloaded file path so wheel reqs can extract a Distribution
        # in .get_dist().
        req.local_file_path = filepath
        # Record that the file is downloaded so we don&#39;t do it again in
        # _prepare_linked_requirement().
        self._downloaded[req.link.url] = filepath

        # If this is an sdist, we need to unpack it after downloading, but the
        # .source_dir won&#39;t be set up until we are in _prepare_linked_requirement().
        # Add the downloaded archive to the install requirement to unpack after
        # preparing the source dir.
        if not req.is_wheel:
            req.needs_unpacked_archive(Path(filepath))

    # This step is necessary to ensure all lazy wheels are processed
    # successfully by the &#39;download&#39;, &#39;wheel&#39;, and &#39;install&#39; commands.
    for req in partially_downloaded_reqs:
        self._prepare_linked_requirement(req, parallel_builds)

def prepare_linked_requirement(
    self, req: InstallRequirement, parallel_builds: bool = False
) -&gt; BaseDistribution:
    &quot;&quot;&quot;Prepare a requirement to be obtained from req.link.&quot;&quot;&quot;
    assert req.link
    self._log_preparing_link(req)
    with indent_log():
        # Check if the relevant file is already available
        # in the download directory
        file_path = None
        if self.download_dir is not None and req.link.is_wheel:
            hashes = self._get_linked_req_hashes(req)
            file_path = _check_download_dir(
                req.link,
                self.download_dir,
                hashes,
                # When a locally built wheel has been found in cache, we don&#39;t warn
                # about re-downloading when the already downloaded wheel hash does
                # not match. This is because the hash must be checked against the
                # original link, not the cached link. It that case the already
                # downloaded file will be removed and re-fetched from cache (which
                # implies a hash check against the cache entry&#39;s origin.json).
                warn_on_hash_mismatch=not req.is_wheel_from_cache,
            )

        if file_path is not None:
            # The file is already available, so mark it as downloaded
            self._downloaded[req.link.url] = file_path
        else:
            # The file is not available, attempt to fetch only metadata
            metadata_dist = self._fetch_metadata_only(req)
            if metadata_dist is not None:
                req.needs_more_preparation = True
                req.set_dist(metadata_dist)
                # Ensure download_info is available even in dry-run mode
                if req.download_info is None:
                    req.download_info = direct_url_from_link(
                        req.link, req.source_dir
                    )
                return metadata_dist

        # None of the optimizations worked, fully prepare the requirement
        return self._prepare_linked_requirement(req, parallel_builds)

def prepare_linked_requirements_more(
    self, reqs: Iterable[InstallRequirement], parallel_builds: bool = False
) -&gt; None:
    &quot;&quot;&quot;Prepare linked requirements more, if needed.&quot;&quot;&quot;
    reqs = [req for req in reqs if req.needs_more_preparation]
    for req in reqs:
        # Determine if any of these requirements were already downloaded.
        if self.download_dir is not None and req.link.is_wheel:
            hashes = self._get_linked_req_hashes(req)
            file_path = _check_download_dir(req.link, self.download_dir, hashes)
            if file_path is not None:
                self._downloaded[req.link.url] = file_path
                req.needs_more_preparation = False

    # Prepare requirements we found were already downloaded for some
    # reason. The other downloads will be completed separately.
    partially_downloaded_reqs: list[InstallRequirement] = []
    for req in reqs:
        if req.needs_more_preparation:
            partially_downloaded_reqs.append(req)
        else:
            self._prepare_linked_requirement(req, parallel_builds)

    # TODO: separate this part out from RequirementPreparer when the v1
    # resolver can be removed!
    self._complete_partial_requirements(
        partially_downloaded_reqs,
        parallel_builds=parallel_builds,
    )

def _prepare_linked_requirement(
    self, req: InstallRequirement, parallel_builds: bool
) -&gt; BaseDistribution:
    assert req.link
    link = req.link

    hashes = self._get_linked_req_hashes(req)

    if hashes and req.is_wheel_from_cache:
        assert req.download_info is not None
        assert link.is_wheel
        assert link.is_file
        # We need to verify hashes, and we have found the requirement in the cache
        # of locally built wheels.
        if (
            isinstance(req.download_info.info, ArchiveInfo)
            and req.download_info.info.hashes
            and hashes.has_one_of(req.download_info.info.hashes)
        ):
            # At this point we know the requirement was built from a hashable source
            # artifact, and we verified that the cache entry&#39;s hash of the original
            # artifact matches one of the hashes we expect. We don&#39;t verify hashes
            # against the cached wheel, because the wheel is not the original.
            hashes = None
        else:
            logger.warning(
                &quot;The hashes of the source archive found in cache entry &quot;
                &quot;don&#39;t match, ignoring cached built wheel &quot;
                &quot;and re-downloading source.&quot;
            )
            req.link = req.cached_wheel_source_link
            link = req.link

    self._ensure_link_req_src_dir(req, parallel_builds)

    if link.is_existing_dir():
        local_file = None
    elif link.url not in self._downloaded:
        try:
            local_file = unpack_url(
                link,
                req.source_dir,
                self._download,
                self.verbosity,
                self.download_dir,
                hashes,
            )
        except NetworkConnectionError as exc:
            raise InstallationError(
                f&quot;Could not install requirement {req} because of HTTP &quot;
                f&quot;error {exc} for URL {link}&quot;
            )
    else:
        file_path = self._downloaded[link.url]
        if hashes:
            hashes.check_against_path(file_path)
        local_file = File(file_path, content_type=None)

    # If download_info is set, we got it from the wheel cache.
    if req.download_info is None:
        # Editables don&#39;t go through this function (see
        # prepare_editable_requirement).
        assert not req.editable
        req.download_info = direct_url_from_link(link, req.source_dir)
        # Make sure we have a hash in download_info. If we got it as part of the
        # URL, it will have been verified and we can rely on it. Otherwise we
        # compute it from the downloaded file.
        # FIXME: https://github.com/pypa/pip/issues/11943
        if (
            isinstance(req.download_info.info, ArchiveInfo)
            and not req.download_info.info.hashes
            and local_file
        ):
            hash = hash_file(local_file.path)[0].hexdigest()
            # We populate info.hash for backward compatibility.
            # This will automatically populate info.hashes.
            req.download_info.info.hash = f&quot;sha256={hash}&quot;

    # For use in later processing,
    # preserve the file path on the requirement.
    if local_file:
        req.local_file_path = local_file.path

    dist = _get_prepared_distribution(
        req,
        self.build_tracker,
        self.build_env_installer,
        self.build_isolation,
        self.check_build_deps,
    )
    return dist

def save_linked_requirement(self, req: InstallRequirement) -&gt; None:
    assert self.download_dir is not None
    assert req.link is not None
    link = req.link
    if link.is_vcs or (link.is_existing_dir() and req.editable):
        # Make a .zip of the source_dir we already created.
        req.archive(self.download_dir)
        return

    if link.is_existing_dir():
        logger.debug(
            &quot;Not copying link to destination directory &quot;
            &quot;since it is a directory: %s&quot;,
            link,
        )
        return
    if req.local_file_path is None:
        # No distribution was downloaded for this requirement.
        return

    download_location = os.path.join(self.download_dir, link.filename)
    if not os.path.exists(download_location):
        shutil.copy(req.local_file_path, download_location)
        download_path = display_path(download_location)
        logger.info(&quot;Saved %s&quot;, download_path)

def prepare_editable_requirement(
    self,
    req: InstallRequirement,
) -&gt; BaseDistribution:
    &quot;&quot;&quot;Prepare an editable requirement.&quot;&quot;&quot;
    assert req.editable, &quot;cannot prepare a non-editable req as editable&quot;

    logger.info(&quot;Obtaining %s&quot;, req)

    with indent_log():
        if self.require_hashes:
            raise InstallationError(
                f&quot;The editable requirement {req} cannot be installed when &quot;
                &quot;requiring hashes, because there is no single file to &quot;
                &quot;hash.&quot;
            )
        req.ensure_has_source_dir(self.src_dir)
        req.update_editable()
        assert req.source_dir
        req.download_info = direct_url_for_editable(req.unpacked_source_directory)

        dist = _get_prepared_distribution(
            req,
            self.build_tracker,
            self.build_env_installer,
            self.build_isolation,
            self.check_build_deps,
        )

        req.check_if_exists(self.use_user_site)

    return dist

def prepare_installed_requirement(
    self,
    req: InstallRequirement,
    skip_reason: str,
) -&gt; BaseDistribution:
    &quot;&quot;&quot;Prepare an already-installed requirement.&quot;&quot;&quot;
    assert req.satisfied_by, &quot;req should have been satisfied but isn&#39;t&quot;
    assert skip_reason is not None, (
        &quot;did not get skip reason skipped but req.satisfied_by &quot;
        f&quot;is set to {req.satisfied_by}&quot;
    )
    logger.info(
        &quot;Requirement %s: %s (%s)&quot;, skip_reason, req, req.satisfied_by.version
    )
    with indent_log():
        if self.require_hashes:
            logger.debug(
                &quot;Since it is already installed, we are trusting this &quot;
                &quot;package without checking its hash. To ensure a &quot;
                &quot;completely repeatable environment, install into an &quot;
                &quot;empty virtualenv.&quot;
            )
        return InstalledDistribution(req).get_metadata_distribution()
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>