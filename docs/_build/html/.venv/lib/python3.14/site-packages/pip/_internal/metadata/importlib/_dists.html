

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/metadata/importlib/_dists.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>from <strong>future</strong> import annotations</p>
<p>import email.message
import importlib.metadata
import pathlib
import zipfile
from collections.abc import Collection, Iterable, Iterator, Mapping, Sequence
from os import PathLike
from typing import (
cast,
)</p>
<p>from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
from pip._vendor.packaging.version import Version
from pip._vendor.packaging.version import parse as parse_version</p>
<p>from pip._internal.exceptions import InvalidWheel, UnsupportedWheel
from pip._internal.metadata.base import (
BaseDistribution,
BaseEntryPoint,
InfoPath,
Wheel,
)
from pip._internal.utils.misc import normalize_path
from pip._internal.utils.packaging import get_requirement
from pip._internal.utils.temp_dir import TempDirectory
from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file</p>
<p>from ._compat import (
BadMetadata,
BasePath,
get_dist_canonical_name,
parse_name_and_version_from_info_directory,
)</p>
<p>class WheelDistribution(importlib.metadata.Distribution):
“””An <code class="docutils literal notranslate"><span class="pre">importlib.metadata.Distribution</span></code> read from a wheel.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Although ``importlib.metadata.PathDistribution`` accepts ``zipfile.Path``,
its implementation is too &quot;lazy&quot; for pip&#39;s needs (we can&#39;t keep the ZipFile
handle open for the entire lifetime of the distribution object).

This implementation eagerly reads the entire metadata directory into the
memory instead, and operates from that.
&quot;&quot;&quot;

def __init__(
    self,
    files: Mapping[pathlib.PurePosixPath, bytes],
    info_location: pathlib.PurePosixPath,
) -&gt; None:
    self._files = files
    self.info_location = info_location

@classmethod
def from_zipfile(
    cls,
    zf: zipfile.ZipFile,
    name: str,
    location: str,
) -&gt; WheelDistribution:
    info_dir, _ = parse_wheel(zf, name)
    paths = (
        (name, pathlib.PurePosixPath(name.split(&quot;/&quot;, 1)[-1]))
        for name in zf.namelist()
        if name.startswith(f&quot;{info_dir}/&quot;)
    )
    files = {
        relpath: read_wheel_metadata_file(zf, fullpath)
        for fullpath, relpath in paths
    }
    info_location = pathlib.PurePosixPath(location, info_dir)
    return cls(files, info_location)

def iterdir(self, path: InfoPath) -&gt; Iterator[pathlib.PurePosixPath]:
    # Only allow iterating through the metadata directory.
    if pathlib.PurePosixPath(str(path)) in self._files:
        return iter(self._files)
    raise FileNotFoundError(path)

def read_text(self, filename: str) -&gt; str | None:
    try:
        data = self._files[pathlib.PurePosixPath(filename)]
    except KeyError:
        return None
    try:
        text = data.decode(&quot;utf-8&quot;)
    except UnicodeDecodeError as e:
        wheel = self.info_location.parent
        error = f&quot;Error decoding metadata for {wheel}: {e} in {filename} file&quot;
        raise UnsupportedWheel(error)
    return text

def locate_file(self, path: str | PathLike[str]) -&gt; pathlib.Path:
    # This method doesn&#39;t make sense for our in-memory wheel, but the API
    # requires us to define it.
    raise NotImplementedError
</pre></div>
</div>
<p>class Distribution(BaseDistribution):
def <strong>init</strong>(
self,
dist: importlib.metadata.Distribution,
info_location: BasePath | None,
installed_location: BasePath | None,
) -&gt; None:
self._dist = dist
self._info_location = info_location
self._installed_location = installed_location</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>@classmethod
def from_directory(cls, directory: str) -&gt; BaseDistribution:
    info_location = pathlib.Path(directory)
    dist = importlib.metadata.Distribution.at(info_location)
    return cls(dist, info_location, info_location.parent)

@classmethod
def from_metadata_file_contents(
    cls,
    metadata_contents: bytes,
    filename: str,
    project_name: str,
) -&gt; BaseDistribution:
    # Generate temp dir to contain the metadata file, and write the file contents.
    temp_dir = pathlib.Path(
        TempDirectory(kind=&quot;metadata&quot;, globally_managed=True).path
    )
    metadata_path = temp_dir / &quot;METADATA&quot;
    metadata_path.write_bytes(metadata_contents)
    # Construct dist pointing to the newly created directory.
    dist = importlib.metadata.Distribution.at(metadata_path.parent)
    return cls(dist, metadata_path.parent, None)

@classmethod
def from_wheel(cls, wheel: Wheel, name: str) -&gt; BaseDistribution:
    try:
        with wheel.as_zipfile() as zf:
            dist = WheelDistribution.from_zipfile(zf, name, wheel.location)
    except zipfile.BadZipFile as e:
        raise InvalidWheel(wheel.location, name) from e
    return cls(dist, dist.info_location, pathlib.PurePosixPath(wheel.location))

@property
def location(self) -&gt; str | None:
    if self._info_location is None:
        return None
    return str(self._info_location.parent)

@property
def info_location(self) -&gt; str | None:
    if self._info_location is None:
        return None
    return str(self._info_location)

@property
def installed_location(self) -&gt; str | None:
    if self._installed_location is None:
        return None
    return normalize_path(str(self._installed_location))

@property
def canonical_name(self) -&gt; NormalizedName:
    return get_dist_canonical_name(self._dist)

@property
def version(self) -&gt; Version:
    try:
        version = (
            parse_name_and_version_from_info_directory(self._dist)[1]
            or self._dist.version
        )
        return parse_version(version)
    except TypeError:
        raise BadMetadata(self._dist, reason=&quot;invalid metadata entry `version`&quot;)

@property
def raw_version(self) -&gt; str:
    return self._dist.version

def is_file(self, path: InfoPath) -&gt; bool:
    return self._dist.read_text(str(path)) is not None

def iter_distutils_script_names(self) -&gt; Iterator[str]:
    # A distutils installation is always &quot;flat&quot; (not in e.g. egg form), so
    # if this distribution&#39;s info location is NOT a pathlib.Path (but e.g.
    # zipfile.Path), it can never contain any distutils scripts.
    if not isinstance(self._info_location, pathlib.Path):
        return
    for child in self._info_location.joinpath(&quot;scripts&quot;).iterdir():
        yield child.name

def read_text(self, path: InfoPath) -&gt; str:
    content = self._dist.read_text(str(path))
    if content is None:
        raise FileNotFoundError(path)
    return content

def iter_entry_points(self) -&gt; Iterable[BaseEntryPoint]:
    # importlib.metadata&#39;s EntryPoint structure satisfies BaseEntryPoint.
    return self._dist.entry_points

def _metadata_impl(self) -&gt; email.message.Message:
    # From Python 3.10+, importlib.metadata declares PackageMetadata as the
    # return type. This protocol is unfortunately a disaster now and misses
    # a ton of fields that we need, including get() and get_payload(). We
    # rely on the implementation that the object is actually a Message now,
    # until upstream can improve the protocol. (python/cpython#94952)
    return cast(email.message.Message, self._dist.metadata)

def iter_provided_extras(self) -&gt; Iterable[NormalizedName]:
    return [
        canonicalize_name(extra)
        for extra in self.metadata.get_all(&quot;Provides-Extra&quot;, [])
    ]

def iter_dependencies(self, extras: Collection[str] = ()) -&gt; Iterable[Requirement]:
    contexts: Sequence[dict[str, str]] = [{&quot;extra&quot;: e} for e in extras]
    for req_string in self.metadata.get_all(&quot;Requires-Dist&quot;, []):
        # strip() because email.message.Message.get_all() may return a leading \n
        # in case a long header was wrapped.
        req = get_requirement(req_string.strip())
        if not req.marker:
            yield req
        elif not extras and req.marker.evaluate({&quot;extra&quot;: &quot;&quot;}):
            yield req
        elif any(req.marker.evaluate(context) for context in contexts):
            yield req
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>