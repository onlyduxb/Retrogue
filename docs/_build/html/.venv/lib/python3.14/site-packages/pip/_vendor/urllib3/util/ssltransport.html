

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>&lt;no title&gt; &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">&lt;no title&gt;</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/util/ssltransport.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>import io
import socket
import ssl</p>
<p>from ..exceptions import ProxySchemeUnsupported
from ..packages import six</p>
<p>SSL_BLOCKSIZE = 16384</p>
<p>class SSLTransport:
“””
The SSLTransport wraps an existing socket and establishes an SSL connection.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Contrary to Python&#39;s implementation of SSLSocket, it allows you to chain
multiple TLS connections together. It&#39;s particularly useful if you need to
implement TLS within TLS.

The class supports most of the socket API operations.
&quot;&quot;&quot;

@staticmethod
def _validate_ssl_context_for_tls_in_tls(ssl_context):
    &quot;&quot;&quot;
    Raises a ProxySchemeUnsupported if the provided ssl_context can&#39;t be used
    for TLS in TLS.

    The only requirement is that the ssl_context provides the &#39;wrap_bio&#39;
    methods.
    &quot;&quot;&quot;

    if not hasattr(ssl_context, &quot;wrap_bio&quot;):
        if six.PY2:
            raise ProxySchemeUnsupported(
                &quot;TLS in TLS requires SSLContext.wrap_bio() which isn&#39;t &quot;
                &quot;supported on Python 2&quot;
            )
        else:
            raise ProxySchemeUnsupported(
                &quot;TLS in TLS requires SSLContext.wrap_bio() which isn&#39;t &quot;
                &quot;available on non-native SSLContext&quot;
            )

def __init__(
    self, socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True
):
    &quot;&quot;&quot;
    Create an SSLTransport around socket using the provided ssl_context.
    &quot;&quot;&quot;
    self.incoming = ssl.MemoryBIO()
    self.outgoing = ssl.MemoryBIO()

    self.suppress_ragged_eofs = suppress_ragged_eofs
    self.socket = socket

    self.sslobj = ssl_context.wrap_bio(
        self.incoming, self.outgoing, server_hostname=server_hostname
    )

    # Perform initial handshake.
    self._ssl_io_loop(self.sslobj.do_handshake)

def __enter__(self):
    return self

def __exit__(self, *_):
    self.close()

def fileno(self):
    return self.socket.fileno()

def read(self, len=1024, buffer=None):
    return self._wrap_ssl_read(len, buffer)

def recv(self, len=1024, flags=0):
    if flags != 0:
        raise ValueError(&quot;non-zero flags not allowed in calls to recv&quot;)
    return self._wrap_ssl_read(len)

def recv_into(self, buffer, nbytes=None, flags=0):
    if flags != 0:
        raise ValueError(&quot;non-zero flags not allowed in calls to recv_into&quot;)
    if buffer and (nbytes is None):
        nbytes = len(buffer)
    elif nbytes is None:
        nbytes = 1024
    return self.read(nbytes, buffer)

def sendall(self, data, flags=0):
    if flags != 0:
        raise ValueError(&quot;non-zero flags not allowed in calls to sendall&quot;)
    count = 0
    with memoryview(data) as view, view.cast(&quot;B&quot;) as byte_view:
        amount = len(byte_view)
        while count &lt; amount:
            v = self.send(byte_view[count:])
            count += v

def send(self, data, flags=0):
    if flags != 0:
        raise ValueError(&quot;non-zero flags not allowed in calls to send&quot;)
    response = self._ssl_io_loop(self.sslobj.write, data)
    return response

def makefile(
    self, mode=&quot;r&quot;, buffering=None, encoding=None, errors=None, newline=None
):
    &quot;&quot;&quot;
    Python&#39;s httpclient uses makefile and buffered io when reading HTTP
    messages and we need to support it.

    This is unfortunately a copy and paste of socket.py makefile with small
    changes to point to the socket directly.
    &quot;&quot;&quot;
    if not set(mode) &lt;= {&quot;r&quot;, &quot;w&quot;, &quot;b&quot;}:
        raise ValueError(&quot;invalid mode %r (only r, w, b allowed)&quot; % (mode,))

    writing = &quot;w&quot; in mode
    reading = &quot;r&quot; in mode or not writing
    assert reading or writing
    binary = &quot;b&quot; in mode
    rawmode = &quot;&quot;
    if reading:
        rawmode += &quot;r&quot;
    if writing:
        rawmode += &quot;w&quot;
    raw = socket.SocketIO(self, rawmode)
    self.socket._io_refs += 1
    if buffering is None:
        buffering = -1
    if buffering &lt; 0:
        buffering = io.DEFAULT_BUFFER_SIZE
    if buffering == 0:
        if not binary:
            raise ValueError(&quot;unbuffered streams must be binary&quot;)
        return raw
    if reading and writing:
        buffer = io.BufferedRWPair(raw, raw, buffering)
    elif reading:
        buffer = io.BufferedReader(raw, buffering)
    else:
        assert writing
        buffer = io.BufferedWriter(raw, buffering)
    if binary:
        return buffer
    text = io.TextIOWrapper(buffer, encoding, errors, newline)
    text.mode = mode
    return text

def unwrap(self):
    self._ssl_io_loop(self.sslobj.unwrap)

def close(self):
    self.socket.close()

def getpeercert(self, binary_form=False):
    return self.sslobj.getpeercert(binary_form)

def version(self):
    return self.sslobj.version()

def cipher(self):
    return self.sslobj.cipher()

def selected_alpn_protocol(self):
    return self.sslobj.selected_alpn_protocol()

def selected_npn_protocol(self):
    return self.sslobj.selected_npn_protocol()

def shared_ciphers(self):
    return self.sslobj.shared_ciphers()

def compression(self):
    return self.sslobj.compression()

def settimeout(self, value):
    self.socket.settimeout(value)

def gettimeout(self):
    return self.socket.gettimeout()

def _decref_socketios(self):
    self.socket._decref_socketios()

def _wrap_ssl_read(self, len, buffer=None):
    try:
        return self._ssl_io_loop(self.sslobj.read, len, buffer)
    except ssl.SSLError as e:
        if e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:
            return 0  # eof, return 0.
        else:
            raise

def _ssl_io_loop(self, func, *args):
    &quot;&quot;&quot;Performs an I/O loop between incoming/outgoing and the socket.&quot;&quot;&quot;
    should_loop = True
    ret = None

    while should_loop:
        errno = None
        try:
            ret = func(*args)
        except ssl.SSLError as e:
            if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):
                # WANT_READ, and WANT_WRITE are expected, others are not.
                raise e
            errno = e.errno

        buf = self.outgoing.read()
        self.socket.sendall(buf)

        if errno is None:
            should_loop = False
        elif errno == ssl.SSL_ERROR_WANT_READ:
            buf = self.socket.recv(SSL_BLOCKSIZE)
            if buf:
                self.incoming.write(buf)
            else:
                self.incoming.write_eof()
    return ret
</pre></div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>