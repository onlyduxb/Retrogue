

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>This file is dual licensed under the terms of the Apache License, Version &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">This file is dual licensed under the terms of the Apache License, Version</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/packaging/tags.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version">
<h1>This file is dual licensed under the terms of the Apache License, Version<a class="headerlink" href="#this-file-is-dual-licensed-under-the-terms-of-the-apache-license-version" title="Link to this heading"></a></h1>
</section>
<section id="and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository">
<h1>2.0, and the BSD License. See the LICENSE file in the root of this repository<a class="headerlink" href="#and-the-bsd-license-see-the-license-file-in-the-root-of-this-repository" title="Link to this heading"></a></h1>
</section>
<section id="for-complete-details">
<h1>for complete details.<a class="headerlink" href="#for-complete-details" title="Link to this heading"></a></h1>
<p>from <strong>future</strong> import annotations</p>
<p>import logging
import platform
import re
import struct
import subprocess
import sys
import sysconfig
from importlib.machinery import EXTENSION_SUFFIXES
from typing import (
Iterable,
Iterator,
Sequence,
Tuple,
cast,
)</p>
<p>from . import _manylinux, _musllinux</p>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<p>PythonVersion = Sequence[int]
AppleVersion = Tuple[int, int]</p>
<p>INTERPRETER_SHORT_NAMES: dict[str, str] = {
“python”: “py”,  # Generic.
“cpython”: “cp”,
“pypy”: “pp”,
“ironpython”: “ip”,
“jython”: “jy”,
}</p>
<p>_32_BIT_INTERPRETER = struct.calcsize(“P”) == 4</p>
<p>class Tag:
“””
A representation of the tag triple for a wheel.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Instances are considered immutable and thus are hashable. Equality checking
is also supported.
&quot;&quot;&quot;

__slots__ = [&quot;_abi&quot;, &quot;_hash&quot;, &quot;_interpreter&quot;, &quot;_platform&quot;]

def __init__(self, interpreter: str, abi: str, platform: str) -&gt; None:
    self._interpreter = interpreter.lower()
    self._abi = abi.lower()
    self._platform = platform.lower()
    # The __hash__ of every single element in a Set[Tag] will be evaluated each time
    # that a set calls its `.disjoint()` method, which may be called hundreds of
    # times when scanning a page of links for packages with tags matching that
    # Set[Tag]. Pre-computing the value here produces significant speedups for
    # downstream consumers.
    self._hash = hash((self._interpreter, self._abi, self._platform))

@property
def interpreter(self) -&gt; str:
    return self._interpreter

@property
def abi(self) -&gt; str:
    return self._abi

@property
def platform(self) -&gt; str:
    return self._platform

def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, Tag):
        return NotImplemented

    return (
        (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.
        and (self._platform == other._platform)
        and (self._abi == other._abi)
        and (self._interpreter == other._interpreter)
    )

def __hash__(self) -&gt; int:
    return self._hash

def __str__(self) -&gt; str:
    return f&quot;{self._interpreter}-{self._abi}-{self._platform}&quot;

def __repr__(self) -&gt; str:
    return f&quot;&lt;{self} @ {id(self)}&gt;&quot;
</pre></div>
</div>
<p>def parse_tag(tag: str) -&gt; frozenset[Tag]:
“””
Parses the provided tag (e.g. <code class="docutils literal notranslate"><span class="pre">py3-none-any</span></code>) into a frozenset of Tag instances.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Returning a set is required due to the possibility that the tag is a
compressed tag set.
&quot;&quot;&quot;
tags = set()
interpreters, abis, platforms = tag.split(&quot;-&quot;)
for interpreter in interpreters.split(&quot;.&quot;):
    for abi in abis.split(&quot;.&quot;):
        for platform_ in platforms.split(&quot;.&quot;):
            tags.add(Tag(interpreter, abi, platform_))
return frozenset(tags)
</pre></div>
</div>
<p>def _get_config_var(name: str, warn: bool = False) -&gt; int | str | None:
value: int | str | None = sysconfig.get_config_var(name)
if value is None and warn:
logger.debug(
“Config variable ‘%s’ is unset, Python ABI tag may be incorrect”, name
)
return value</p>
<p>def <em>normalize_string(string: str) -&gt; str:
return string.replace(“.”, “</em>”).replace(“-”, “<em>”).replace(” “, “</em>”)</p>
<p>def _is_threaded_cpython(abis: list[str]) -&gt; bool:
“””
Determine if the ABI corresponds to a threaded (<code class="docutils literal notranslate"><span class="pre">--disable-gil</span></code>) build.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The threaded builds are indicated by a &quot;t&quot; in the abiflags.
&quot;&quot;&quot;
if len(abis) == 0:
    return False
# expect e.g., cp313
m = re.match(r&quot;cp\d+(.*)&quot;, abis[0])
if not m:
    return False
abiflags = m.group(1)
return &quot;t&quot; in abiflags
</pre></div>
</div>
<p>def _abi3_applies(python_version: PythonVersion, threading: bool) -&gt; bool:
“””
Determine if the Python version supports abi3.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)
builds do not support abi3.
&quot;&quot;&quot;
return len(python_version) &gt; 1 and tuple(python_version) &gt;= (3, 2) and not threading
</pre></div>
</div>
<p>def _cpython_abis(py_version: PythonVersion, warn: bool = False) -&gt; list[str]:
py_version = tuple(py_version)  # To allow for version comparison.
abis = []
version = _version_nodot(py_version[:2])
threading = debug = pymalloc = ucs4 = “”
with_debug = _get_config_var(“Py_DEBUG”, warn)
has_refcount = hasattr(sys, “gettotalrefcount”)
# Windows doesn’t set Py_DEBUG, so checking for support of debug-compiled
# extension modules is the best option.
# https://github.com/pypa/pip/issues/3383#issuecomment-173267692
has_ext = “_d.pyd” in EXTENSION_SUFFIXES
if with_debug or (with_debug is None and (has_refcount or has_ext)):
debug = “d”
if py_version &gt;= (3, 13) and _get_config_var(“Py_GIL_DISABLED”, warn):
threading = “t”
if py_version &lt; (3, 8):
with_pymalloc = _get_config_var(“WITH_PYMALLOC”, warn)
if with_pymalloc or with_pymalloc is None:
pymalloc = “m”
if py_version &lt; (3, 3):
unicode_size = _get_config_var(“Py_UNICODE_SIZE”, warn)
if unicode_size == 4 or (
unicode_size is None and sys.maxunicode == 0x10FFFF
):
ucs4 = “u”
elif debug:
# Debug builds can also load “normal” extension modules.
# We can also assume no UCS-4 or pymalloc requirement.
abis.append(f”cp{version}{threading}”)
abis.insert(0, f”cp{version}{threading}{debug}{pymalloc}{ucs4}”)
return abis</p>
<p>def cpython_tags(
python_version: PythonVersion | None = None,
abis: Iterable[str] | None = None,
platforms: Iterable[str] | None = None,
*,
warn: bool = False,
) -&gt; Iterator[Tag]:
“””
Yields the tags for a CPython interpreter.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The tags consist of:
- cp&lt;python_version&gt;-&lt;abi&gt;-&lt;platform&gt;
- cp&lt;python_version&gt;-abi3-&lt;platform&gt;
- cp&lt;python_version&gt;-none-&lt;platform&gt;
- cp&lt;less than python_version&gt;-abi3-&lt;platform&gt;  # Older Python versions down to 3.2.

If python_version only specifies a major version then user-provided ABIs and
the &#39;none&#39; ABItag will be used.

If &#39;abi3&#39; or &#39;none&#39; are specified in &#39;abis&#39; then they will be yielded at
their normal position and not at the beginning.
&quot;&quot;&quot;
if not python_version:
    python_version = sys.version_info[:2]

interpreter = f&quot;cp{_version_nodot(python_version[:2])}&quot;

if abis is None:
    if len(python_version) &gt; 1:
        abis = _cpython_abis(python_version, warn)
    else:
        abis = []
abis = list(abis)
# &#39;abi3&#39; and &#39;none&#39; are explicitly handled later.
for explicit_abi in (&quot;abi3&quot;, &quot;none&quot;):
    try:
        abis.remove(explicit_abi)
    except ValueError:
        pass

platforms = list(platforms or platform_tags())
for abi in abis:
    for platform_ in platforms:
        yield Tag(interpreter, abi, platform_)

threading = _is_threaded_cpython(abis)
use_abi3 = _abi3_applies(python_version, threading)
if use_abi3:
    yield from (Tag(interpreter, &quot;abi3&quot;, platform_) for platform_ in platforms)
yield from (Tag(interpreter, &quot;none&quot;, platform_) for platform_ in platforms)

if use_abi3:
    for minor_version in range(python_version[1] - 1, 1, -1):
        for platform_ in platforms:
            version = _version_nodot((python_version[0], minor_version))
            interpreter = f&quot;cp{version}&quot;
            yield Tag(interpreter, &quot;abi3&quot;, platform_)
</pre></div>
</div>
<p>def _generic_abi() -&gt; list[str]:
“””
Return the ABI tag based on EXT_SUFFIX.
“””
# The following are examples of <code class="docutils literal notranslate"><span class="pre">EXT_SUFFIX</span></code>.
# We want to keep the parts which are related to the ABI and remove the
# parts which are related to the platform:
# - linux:   ‘.cpython-310-x86_64-linux-gnu.so’ =&gt; cp310
# - mac:     ‘.cpython-310-darwin.so’           =&gt; cp310
# - win:     ‘.cp310-win_amd64.pyd’             =&gt; cp310
# - win:     ‘.pyd’                             =&gt; cp37 (uses _cpython_abis())
# - pypy:    ‘.pypy38-pp73-x86_64-linux-gnu.so’ =&gt; pypy38_pp73
# - graalpy: ‘.graalpy-38-native-x86_64-darwin.dylib’
#                                               =&gt; graalpy_38_native</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ext_suffix = _get_config_var(&quot;EXT_SUFFIX&quot;, warn=True)
if not isinstance(ext_suffix, str) or ext_suffix[0] != &quot;.&quot;:
    raise SystemError(&quot;invalid sysconfig.get_config_var(&#39;EXT_SUFFIX&#39;)&quot;)
parts = ext_suffix.split(&quot;.&quot;)
if len(parts) &lt; 3:
    # CPython3.7 and earlier uses &quot;.pyd&quot; on Windows.
    return _cpython_abis(sys.version_info[:2])
soabi = parts[1]
if soabi.startswith(&quot;cpython&quot;):
    # non-windows
    abi = &quot;cp&quot; + soabi.split(&quot;-&quot;)[1]
elif soabi.startswith(&quot;cp&quot;):
    # windows
    abi = soabi.split(&quot;-&quot;)[0]
elif soabi.startswith(&quot;pypy&quot;):
    abi = &quot;-&quot;.join(soabi.split(&quot;-&quot;)[:2])
elif soabi.startswith(&quot;graalpy&quot;):
    abi = &quot;-&quot;.join(soabi.split(&quot;-&quot;)[:3])
elif soabi:
    # pyston, ironpython, others?
    abi = soabi
else:
    return []
return [_normalize_string(abi)]
</pre></div>
</div>
<p>def generic_tags(
interpreter: str | None = None,
abis: Iterable[str] | None = None,
platforms: Iterable[str] | None = None,
*,
warn: bool = False,
) -&gt; Iterator[Tag]:
“””
Yields the tags for a generic interpreter.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The tags consist of:
- &lt;interpreter&gt;-&lt;abi&gt;-&lt;platform&gt;

The &quot;none&quot; ABI will be added if it was not explicitly provided.
&quot;&quot;&quot;
if not interpreter:
    interp_name = interpreter_name()
    interp_version = interpreter_version(warn=warn)
    interpreter = &quot;&quot;.join([interp_name, interp_version])
if abis is None:
    abis = _generic_abi()
else:
    abis = list(abis)
platforms = list(platforms or platform_tags())
if &quot;none&quot; not in abis:
    abis.append(&quot;none&quot;)
for abi in abis:
    for platform_ in platforms:
        yield Tag(interpreter, abi, platform_)
</pre></div>
</div>
<p>def _py_interpreter_range(py_version: PythonVersion) -&gt; Iterator[str]:
“””
Yields Python versions in descending order.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>After the latest version, the major-only version will be yielded, and then
all previous versions of that major version.
&quot;&quot;&quot;
if len(py_version) &gt; 1:
    yield f&quot;py{_version_nodot(py_version[:2])}&quot;
yield f&quot;py{py_version[0]}&quot;
if len(py_version) &gt; 1:
    for minor in range(py_version[1] - 1, -1, -1):
        yield f&quot;py{_version_nodot((py_version[0], minor))}&quot;
</pre></div>
</div>
<p>def compatible_tags(
python_version: PythonVersion | None = None,
interpreter: str | None = None,
platforms: Iterable[str] | None = None,
) -&gt; Iterator[Tag]:
“””
Yields the sequence of tags that are compatible with a specific version of Python.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The tags consist of:
- py*-none-&lt;platform&gt;
- &lt;interpreter&gt;-none-any  # ... if `interpreter` is provided.
- py*-none-any
&quot;&quot;&quot;
if not python_version:
    python_version = sys.version_info[:2]
platforms = list(platforms or platform_tags())
for version in _py_interpreter_range(python_version):
    for platform_ in platforms:
        yield Tag(version, &quot;none&quot;, platform_)
if interpreter:
    yield Tag(interpreter, &quot;none&quot;, &quot;any&quot;)
for version in _py_interpreter_range(python_version):
    yield Tag(version, &quot;none&quot;, &quot;any&quot;)
</pre></div>
</div>
<p>def _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -&gt; str:
if not is_32bit:
return arch</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if arch.startswith(&quot;ppc&quot;):
    return &quot;ppc&quot;

return &quot;i386&quot;
</pre></div>
</div>
<p>def _mac_binary_formats(version: AppleVersion, cpu_arch: str) -&gt; list[str]:
formats = [cpu_arch]
if cpu_arch == “x86_64”:
if version &lt; (10, 4):
return []
formats.extend([“intel”, “fat64”, “fat32”])</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>elif cpu_arch == &quot;i386&quot;:
    if version &lt; (10, 4):
        return []
    formats.extend([&quot;intel&quot;, &quot;fat32&quot;, &quot;fat&quot;])

elif cpu_arch == &quot;ppc64&quot;:
    # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?
    if version &gt; (10, 5) or version &lt; (10, 4):
        return []
    formats.append(&quot;fat64&quot;)

elif cpu_arch == &quot;ppc&quot;:
    if version &gt; (10, 6):
        return []
    formats.extend([&quot;fat32&quot;, &quot;fat&quot;])

if cpu_arch in {&quot;arm64&quot;, &quot;x86_64&quot;}:
    formats.append(&quot;universal2&quot;)

if cpu_arch in {&quot;x86_64&quot;, &quot;i386&quot;, &quot;ppc64&quot;, &quot;ppc&quot;, &quot;intel&quot;}:
    formats.append(&quot;universal&quot;)

return formats
</pre></div>
</div>
<p>def mac_platforms(
version: AppleVersion | None = None, arch: str | None = None
) -&gt; Iterator[str]:
“””
Yields the platform tags for a macOS system.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The `version` parameter is a two-item tuple specifying the macOS version to
generate platform tags for. The `arch` parameter is the CPU architecture to
generate platform tags for. Both parameters default to the appropriate value
for the current system.
&quot;&quot;&quot;
version_str, _, cpu_arch = platform.mac_ver()
if version is None:
    version = cast(&quot;AppleVersion&quot;, tuple(map(int, version_str.split(&quot;.&quot;)[:2])))
    if version == (10, 16):
        # When built against an older macOS SDK, Python will report macOS 10.16
        # instead of the real version.
        version_str = subprocess.run(
            [
                sys.executable,
                &quot;-sS&quot;,
                &quot;-c&quot;,
                &quot;import platform; print(platform.mac_ver()[0])&quot;,
            ],
            check=True,
            env={&quot;SYSTEM_VERSION_COMPAT&quot;: &quot;0&quot;},
            stdout=subprocess.PIPE,
            text=True,
        ).stdout
        version = cast(&quot;AppleVersion&quot;, tuple(map(int, version_str.split(&quot;.&quot;)[:2])))
else:
    version = version
if arch is None:
    arch = _mac_arch(cpu_arch)
else:
    arch = arch

if (10, 0) &lt;= version and version &lt; (11, 0):
    # Prior to Mac OS 11, each yearly release of Mac OS bumped the
    # &quot;minor&quot; version number.  The major version was always 10.
    major_version = 10
    for minor_version in range(version[1], -1, -1):
        compat_version = major_version, minor_version
        binary_formats = _mac_binary_formats(compat_version, arch)
        for binary_format in binary_formats:
            yield f&quot;macosx_{major_version}_{minor_version}_{binary_format}&quot;

if version &gt;= (11, 0):
    # Starting with Mac OS 11, each yearly release bumps the major version
    # number.   The minor versions are now the midyear updates.
    minor_version = 0
    for major_version in range(version[0], 10, -1):
        compat_version = major_version, minor_version
        binary_formats = _mac_binary_formats(compat_version, arch)
        for binary_format in binary_formats:
            yield f&quot;macosx_{major_version}_{minor_version}_{binary_format}&quot;

if version &gt;= (11, 0):
    # Mac OS 11 on x86_64 is compatible with binaries from previous releases.
    # Arm64 support was introduced in 11.0, so no Arm binaries from previous
    # releases exist.
    #
    # However, the &quot;universal2&quot; binary format can have a
    # macOS version earlier than 11.0 when the x86_64 part of the binary supports
    # that version of macOS.
    major_version = 10
    if arch == &quot;x86_64&quot;:
        for minor_version in range(16, 3, -1):
            compat_version = major_version, minor_version
            binary_formats = _mac_binary_formats(compat_version, arch)
            for binary_format in binary_formats:
                yield f&quot;macosx_{major_version}_{minor_version}_{binary_format}&quot;
    else:
        for minor_version in range(16, 3, -1):
            compat_version = major_version, minor_version
            binary_format = &quot;universal2&quot;
            yield f&quot;macosx_{major_version}_{minor_version}_{binary_format}&quot;
</pre></div>
</div>
<p>def ios_platforms(
version: AppleVersion | None = None, multiarch: str | None = None
) -&gt; Iterator[str]:
“””
Yields the platform tags for an iOS system.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param version: A two-item tuple specifying the iOS version to generate
    platform tags for. Defaults to the current iOS version.
:param multiarch: The CPU architecture+ABI to generate platform tags for -
    (the value used by `sys.implementation._multiarch` e.g.,
    `arm64_iphoneos` or `x84_64_iphonesimulator`). Defaults to the current
    multiarch value.
&quot;&quot;&quot;
if version is None:
    # if iOS is the current platform, ios_ver *must* be defined. However,
    # it won&#39;t exist for CPython versions before 3.13, which causes a mypy
    # error.
    _, release, _, _ = platform.ios_ver()  # type: ignore[attr-defined, unused-ignore]
    version = cast(&quot;AppleVersion&quot;, tuple(map(int, release.split(&quot;.&quot;)[:2])))

if multiarch is None:
    multiarch = sys.implementation._multiarch
multiarch = multiarch.replace(&quot;-&quot;, &quot;_&quot;)

ios_platform_template = &quot;ios_{major}_{minor}_{multiarch}&quot;

# Consider any iOS major.minor version from the version requested, down to
# 12.0. 12.0 is the first iOS version that is known to have enough features
# to support CPython. Consider every possible minor release up to X.9. There
# highest the minor has ever gone is 8 (14.8 and 15.8) but having some extra
# candidates that won&#39;t ever match doesn&#39;t really hurt, and it saves us from
# having to keep an explicit list of known iOS versions in the code. Return
# the results descending order of version number.

# If the requested major version is less than 12, there won&#39;t be any matches.
if version[0] &lt; 12:
    return

# Consider the actual X.Y version that was requested.
yield ios_platform_template.format(
    major=version[0], minor=version[1], multiarch=multiarch
)

# Consider every minor version from X.0 to the minor version prior to the
# version requested by the platform.
for minor in range(version[1] - 1, -1, -1):
    yield ios_platform_template.format(
        major=version[0], minor=minor, multiarch=multiarch
    )

for major in range(version[0] - 1, 11, -1):
    for minor in range(9, -1, -1):
        yield ios_platform_template.format(
            major=major, minor=minor, multiarch=multiarch
        )
</pre></div>
</div>
<p>def android_platforms(
api_level: int | None = None, abi: str | None = None
) -&gt; Iterator[str]:
“””
Yields the :attr:<code class="docutils literal notranslate"><span class="pre">~Tag.platform</span></code> tags for Android. If this function is invoked on
non-Android platforms, the <code class="docutils literal notranslate"><span class="pre">api_level</span></code> and <code class="docutils literal notranslate"><span class="pre">abi</span></code> arguments are required.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:param int api_level: The maximum `API level
    &lt;https://developer.android.com/tools/releases/platforms&gt;`__ to return. Defaults
    to the current system&#39;s version, as returned by ``platform.android_ver``.
:param str abi: The `Android ABI &lt;https://developer.android.com/ndk/guides/abis&gt;`__,
    e.g. ``arm64_v8a``. Defaults to the current system&#39;s ABI , as returned by
    ``sysconfig.get_platform``. Hyphens and periods will be replaced with
    underscores.
&quot;&quot;&quot;
if platform.system() != &quot;Android&quot; and (api_level is None or abi is None):
    raise TypeError(
        &quot;on non-Android platforms, the api_level and abi arguments are required&quot;
    )

if api_level is None:
    # Python 3.13 was the first version to return platform.system() == &quot;Android&quot;,
    # and also the first version to define platform.android_ver().
    api_level = platform.android_ver().api_level  # type: ignore[attr-defined]

if abi is None:
    abi = sysconfig.get_platform().split(&quot;-&quot;)[-1]
abi = _normalize_string(abi)

# 16 is the minimum API level known to have enough features to support CPython
# without major patching. Yield every API level from the maximum down to the
# minimum, inclusive.
min_api_level = 16
for ver in range(api_level, min_api_level - 1, -1):
    yield f&quot;android_{ver}_{abi}&quot;
</pre></div>
</div>
<p>def _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -&gt; Iterator[str]:
linux = <em>normalize_string(sysconfig.get_platform())
if not linux.startswith(“linux</em>”):
# we should never be here, just yield the sysconfig one and return
yield linux
return
if is_32bit:
if linux == “linux_x86_64”:
linux = “linux_i686”
elif linux == “linux_aarch64”:
linux = “linux_armv8l”
<em>, arch = linux.split(”</em>”, 1)
archs = {“armv8l”: [“armv8l”, “armv7l”]}.get(arch, [arch])
yield from _manylinux.platform_tags(archs)
yield from <em>musllinux.platform_tags(archs)
for arch in archs:
yield f”linux</em>{arch}”</p>
<p>def _generic_platforms() -&gt; Iterator[str]:
yield _normalize_string(sysconfig.get_platform())</p>
<p>def platform_tags() -&gt; Iterator[str]:
“””
Provides the platform tags for this installation.
“””
if platform.system() == “Darwin”:
return mac_platforms()
elif platform.system() == “iOS”:
return ios_platforms()
elif platform.system() == “Android”:
return android_platforms()
elif platform.system() == “Linux”:
return _linux_platforms()
else:
return _generic_platforms()</p>
<p>def interpreter_name() -&gt; str:
“””
Returns the name of the running interpreter.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Some implementations have a reserved, two-letter abbreviation which will
be returned when appropriate.
&quot;&quot;&quot;
name = sys.implementation.name
return INTERPRETER_SHORT_NAMES.get(name) or name
</pre></div>
</div>
<p>def interpreter_version(*, warn: bool = False) -&gt; str:
“””
Returns the version of the running interpreter.
“””
version = _get_config_var(“py_version_nodot”, warn=warn)
if version:
version = str(version)
else:
version = _version_nodot(sys.version_info[:2])
return version</p>
<p>def _version_nodot(version: PythonVersion) -&gt; str:
return “”.join(map(str, version))</p>
<p>def sys_tags(*, warn: bool = False) -&gt; Iterator[Tag]:
“””
Returns the sequence of tag triples for the running interpreter.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The order of the sequence corresponds to priority order for the
interpreter, from most to least important.
&quot;&quot;&quot;

interp_name = interpreter_name()
if interp_name == &quot;cp&quot;:
    yield from cpython_tags(warn=warn)
else:
    yield from generic_tags()

if interp_name == &quot;pp&quot;:
    interp = &quot;pp3&quot;
elif interp_name == &quot;cp&quot;:
    interp = &quot;cp&quot; + interpreter_version(warn=warn)
else:
    interp = None
yield from compatible_tags(interpreter=interp)
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>