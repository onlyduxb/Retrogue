

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How should we wait on sockets? &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">How should we wait on sockets?</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_vendor/urllib3/util/wait.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>import errno
import select
import sys
from functools import partial</p>
<p>try:
from time import monotonic
except ImportError:
from time import time as monotonic</p>
<p><strong>all</strong> = [“NoWayToWaitForSocketError”, “wait_for_read”, “wait_for_write”]</p>
<p>class NoWayToWaitForSocketError(Exception):
pass</p>
<section id="how-should-we-wait-on-sockets">
<h1>How should we wait on sockets?<a class="headerlink" href="#how-should-we-wait-on-sockets" title="Link to this heading"></a></h1>
</section>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="there-are-two-types-of-apis-you-can-use-for-waiting-on-sockets-the-fancy">
<h1>There are two types of APIs you can use for waiting on sockets: the fancy<a class="headerlink" href="#there-are-two-types-of-apis-you-can-use-for-waiting-on-sockets-the-fancy" title="Link to this heading"></a></h1>
</section>
<section id="modern-stateful-apis-like-epoll-kqueue-and-the-older-stateless-apis-like">
<h1>modern stateful APIs like epoll/kqueue, and the older stateless APIs like<a class="headerlink" href="#modern-stateful-apis-like-epoll-kqueue-and-the-older-stateless-apis-like" title="Link to this heading"></a></h1>
</section>
<section id="select-poll-the-stateful-apis-are-more-efficient-when-you-have-a-lots-of">
<h1>select/poll. The stateful APIs are more efficient when you have a lots of<a class="headerlink" href="#select-poll-the-stateful-apis-are-more-efficient-when-you-have-a-lots-of" title="Link to this heading"></a></h1>
</section>
<section id="sockets-to-keep-track-of-because-you-can-set-them-up-once-and-then-use-them">
<h1>sockets to keep track of, because you can set them up once and then use them<a class="headerlink" href="#sockets-to-keep-track-of-because-you-can-set-them-up-once-and-then-use-them" title="Link to this heading"></a></h1>
</section>
<section id="lots-of-times-but-we-only-ever-want-to-wait-on-a-single-socket-at-a-time">
<h1>lots of times. But we only ever want to wait on a single socket at a time<a class="headerlink" href="#lots-of-times-but-we-only-ever-want-to-wait-on-a-single-socket-at-a-time" title="Link to this heading"></a></h1>
</section>
<section id="and-don-t-want-to-keep-track-of-state-so-the-stateless-apis-are-actually">
<h1>and don’t want to keep track of state, so the stateless APIs are actually<a class="headerlink" href="#and-don-t-want-to-keep-track-of-state-so-the-stateless-apis-are-actually" title="Link to this heading"></a></h1>
</section>
<section id="more-efficient-so-we-want-to-use-select-or-poll">
<h1>more efficient. So we want to use select() or poll().<a class="headerlink" href="#more-efficient-so-we-want-to-use-select-or-poll" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
</section>
<section id="now-how-do-we-choose-between-select-and-poll-on-traditional-unixes">
<h1>Now, how do we choose between select() and poll()? On traditional Unixes,<a class="headerlink" href="#now-how-do-we-choose-between-select-and-poll-on-traditional-unixes" title="Link to this heading"></a></h1>
</section>
<section id="select-has-a-strange-calling-convention-that-makes-it-slow-or-fail">
<h1>select() has a strange calling convention that makes it slow, or fail<a class="headerlink" href="#select-has-a-strange-calling-convention-that-makes-it-slow-or-fail" title="Link to this heading"></a></h1>
</section>
<section id="altogether-for-high-numbered-file-descriptors-the-point-of-poll-is-to-fix">
<h1>altogether, for high-numbered file descriptors. The point of poll() is to fix<a class="headerlink" href="#altogether-for-high-numbered-file-descriptors-the-point-of-poll-is-to-fix" title="Link to this heading"></a></h1>
</section>
<section id="that-so-on-unixes-we-prefer-poll">
<h1>that, so on Unixes, we prefer poll().<a class="headerlink" href="#that-so-on-unixes-we-prefer-poll" title="Link to this heading"></a></h1>
</section>
<section id="id3">
<h1><a class="headerlink" href="#id3" title="Link to this heading"></a></h1>
</section>
<section id="on-windows-there-is-no-poll-or-at-least-python-doesn-t-provide-a-wrapper">
<h1>On Windows, there is no poll() (or at least Python doesn’t provide a wrapper<a class="headerlink" href="#on-windows-there-is-no-poll-or-at-least-python-doesn-t-provide-a-wrapper" title="Link to this heading"></a></h1>
</section>
<section id="for-it-but-that-s-ok-because-on-windows-select-doesn-t-have-this">
<h1>for it), but that’s OK, because on Windows, select() doesn’t have this<a class="headerlink" href="#for-it-but-that-s-ok-because-on-windows-select-doesn-t-have-this" title="Link to this heading"></a></h1>
</section>
<section id="strange-calling-convention-plain-select-works-fine">
<h1>strange calling convention; plain select() works fine.<a class="headerlink" href="#strange-calling-convention-plain-select-works-fine" title="Link to this heading"></a></h1>
</section>
<section id="id4">
<h1><a class="headerlink" href="#id4" title="Link to this heading"></a></h1>
</section>
<section id="so-on-windows-we-use-select-and-everywhere-else-we-use-poll-we-also">
<h1>So: on Windows we use select(), and everywhere else we use poll(). We also<a class="headerlink" href="#so-on-windows-we-use-select-and-everywhere-else-we-use-poll-we-also" title="Link to this heading"></a></h1>
</section>
<section id="fall-back-to-select-in-case-poll-is-somehow-broken-or-missing">
<h1>fall back to select() in case poll() is somehow broken or missing.<a class="headerlink" href="#fall-back-to-select-in-case-poll-is-somehow-broken-or-missing" title="Link to this heading"></a></h1>
<p>if sys.version_info &gt;= (3, 5):
# Modern Python, that retries syscalls by default
def _retry_on_intr(fn, timeout):
return fn(timeout)</p>
<p>else:
# Old and broken Pythons.
def _retry_on_intr(fn, timeout):
if timeout is None:
deadline = float(“inf”)
else:
deadline = monotonic() + timeout</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    while True:
        try:
            return fn(timeout)
        # OSError for 3 &lt;= pyver &lt; 3.5, select.error for pyver &lt;= 2.7
        except (OSError, select.error) as e:
            # &#39;e.args[0]&#39; incantation works for both OSError and select.error
            if e.args[0] != errno.EINTR:
                raise
            else:
                timeout = deadline - monotonic()
                if timeout &lt; 0:
                    timeout = 0
                if timeout == float(&quot;inf&quot;):
                    timeout = None
                continue
</pre></div>
</div>
<p>def select_wait_for_socket(sock, read=False, write=False, timeout=None):
if not read and not write:
raise RuntimeError(“must specify at least one of read=True, write=True”)
rcheck = []
wcheck = []
if read:
rcheck.append(sock)
if write:
wcheck.append(sock)
# When doing a non-blocking connect, most systems signal success by
# marking the socket writable. Windows, though, signals success by marked
# it as “exceptional”. We paper over the difference by checking the write
# sockets for both conditions. (The stdlib selectors module does the same
# thing.)
fn = partial(select.select, rcheck, wcheck, wcheck)
rready, wready, xready = _retry_on_intr(fn, timeout)
return bool(rready or wready or xready)</p>
<p>def poll_wait_for_socket(sock, read=False, write=False, timeout=None):
if not read and not write:
raise RuntimeError(“must specify at least one of read=True, write=True”)
mask = 0
if read:
mask |= select.POLLIN
if write:
mask |= select.POLLOUT
poll_obj = select.poll()
poll_obj.register(sock, mask)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># For some reason, poll() takes timeout in milliseconds
def do_poll(t):
    if t is not None:
        t *= 1000
    return poll_obj.poll(t)

return bool(_retry_on_intr(do_poll, timeout))
</pre></div>
</div>
<p>def null_wait_for_socket(*args, **kwargs):
raise NoWayToWaitForSocketError(“no select-equivalent available”)</p>
<p>def _have_working_poll():
# Apparently some systems have a select.poll that fails as soon as you try
# to use it, either due to strange configuration or broken monkeypatching
# from libraries like eventlet/greenlet.
try:
poll_obj = select.poll()
_retry_on_intr(poll_obj.poll, 0)
except (AttributeError, OSError):
return False
else:
return True</p>
<p>def wait_for_socket(*args, **kwargs):
# We delay choosing which implementation to use until the first time we’re
# called. We could do it at import time, but then we might make the wrong
# decision if someone goes wild with monkeypatching select.poll after
# we’re imported.
global wait_for_socket
if _have_working_poll():
wait_for_socket = poll_wait_for_socket
elif hasattr(select, “select”):
wait_for_socket = select_wait_for_socket
else:  # Platform-specific: Appengine.
wait_for_socket = null_wait_for_socket
return wait_for_socket(*args, **kwargs)</p>
<p>def wait_for_read(sock, timeout=None):
“””Waits for reading to be available on a given socket.
Returns True if the socket is readable, or False if the timeout expired.
“””
return wait_for_socket(sock, read=True, timeout=timeout)</p>
<p>def wait_for_write(sock, timeout=None):
“””Waits for writing to be available on a given socket.
Returns True if the socket is readable, or False if the timeout expired.
“””
return wait_for_socket(sock, write=True, timeout=timeout)</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>