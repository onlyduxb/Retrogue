

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title> &mdash; Retrogue 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../../../../_static/fonts.css?v=5583d106" />

  
      <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../../../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../../../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            Retrogue
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">Retrogue</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/.venv/lib/python3.14/site-packages/pip/_internal/exceptions.py.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>“””Exceptions used throughout package.</p>
<p>This module MUST NOT try to import from anything within <code class="docutils literal notranslate"><span class="pre">pip._internal</span></code> to
operate. This is expected to be importable from any/all files within the
subpackage and, thus, should not depend on them.
“””</p>
<p>from <strong>future</strong> import annotations</p>
<p>import configparser
import contextlib
import locale
import logging
import pathlib
import re
import sys
from collections.abc import Iterator
from itertools import chain, groupby, repeat
from typing import TYPE_CHECKING, Literal</p>
<p>from pip._vendor.packaging.requirements import InvalidRequirement
from pip._vendor.packaging.version import InvalidVersion
from pip._vendor.rich.console import Console, ConsoleOptions, RenderResult
from pip._vendor.rich.markup import escape
from pip._vendor.rich.text import Text</p>
<p>if TYPE_CHECKING:
from hashlib import _Hash</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>from pip._vendor.requests.models import Request, Response

from pip._internal.metadata import BaseDistribution
from pip._internal.network.download import _FileDownload
from pip._internal.req.req_install import InstallRequirement
</pre></div>
</div>
<p>logger = logging.getLogger(<strong>name</strong>)</p>
<section id="id1">
<h1><a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
</section>
<section id="scaffolding">
<h1>Scaffolding<a class="headerlink" href="#scaffolding" title="Link to this heading"></a></h1>
</section>
<section id="id2">
<h1><a class="headerlink" href="#id2" title="Link to this heading"></a></h1>
<p>def _is_kebab_case(s: str) -&gt; bool:
return re.match(r”^[a-z]+(-[a-z]+)*$”, s) is not None</p>
<p>def _prefix_with_indent(
s: Text | str,
console: Console,
*,
prefix: str,
indent: str,
) -&gt; Text:
if isinstance(s, Text):
text = s
else:
text = console.render_str(s)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>return console.render_str(prefix, overflow=&quot;ignore&quot;) + console.render_str(
    f&quot;\n{indent}&quot;, overflow=&quot;ignore&quot;
).join(text.split(allow_blank=True))
</pre></div>
</div>
<p>class PipError(Exception):
“””The base pip error.”””</p>
<p>class DiagnosticPipError(PipError):
“””An error, that presents diagnostic information to the user.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This contains a bunch of logic, to enable pretty presentation of our error
messages. Each error gets a unique reference. Each error can also include
additional context, a hint and/or a note -- which are presented with the
main error message in a consistent style.

This is adapted from the error output styling in `sphinx-theme-builder`.
&quot;&quot;&quot;

reference: str

def __init__(
    self,
    *,
    kind: Literal[&quot;error&quot;, &quot;warning&quot;] = &quot;error&quot;,
    reference: str | None = None,
    message: str | Text,
    context: str | Text | None,
    hint_stmt: str | Text | None,
    note_stmt: str | Text | None = None,
    link: str | None = None,
) -&gt; None:
    # Ensure a proper reference is provided.
    if reference is None:
        assert hasattr(self, &quot;reference&quot;), &quot;error reference not provided!&quot;
        reference = self.reference
    assert _is_kebab_case(reference), &quot;error reference must be kebab-case!&quot;

    self.kind = kind
    self.reference = reference

    self.message = message
    self.context = context

    self.note_stmt = note_stmt
    self.hint_stmt = hint_stmt

    self.link = link

    super().__init__(f&quot;&lt;{self.__class__.__name__}: {self.reference}&gt;&quot;)

def __repr__(self) -&gt; str:
    return (
        f&quot;&lt;{self.__class__.__name__}(&quot;
        f&quot;reference={self.reference!r}, &quot;
        f&quot;message={self.message!r}, &quot;
        f&quot;context={self.context!r}, &quot;
        f&quot;note_stmt={self.note_stmt!r}, &quot;
        f&quot;hint_stmt={self.hint_stmt!r}&quot;
        &quot;)&gt;&quot;
    )

def __rich_console__(
    self,
    console: Console,
    options: ConsoleOptions,
) -&gt; RenderResult:
    colour = &quot;red&quot; if self.kind == &quot;error&quot; else &quot;yellow&quot;

    yield f&quot;[{colour} bold]{self.kind}[/]: [bold]{self.reference}[/]&quot;
    yield &quot;&quot;

    if not options.ascii_only:
        # Present the main message, with relevant context indented.
        if self.context is not None:
            yield _prefix_with_indent(
                self.message,
                console,
                prefix=f&quot;[{colour}]×[/] &quot;,
                indent=f&quot;[{colour}]│[/] &quot;,
            )
            yield _prefix_with_indent(
                self.context,
                console,
                prefix=f&quot;[{colour}]╰─&gt;[/] &quot;,
                indent=f&quot;[{colour}]   [/] &quot;,
            )
        else:
            yield _prefix_with_indent(
                self.message,
                console,
                prefix=&quot;[red]×[/] &quot;,
                indent=&quot;  &quot;,
            )
    else:
        yield self.message
        if self.context is not None:
            yield &quot;&quot;
            yield self.context

    if self.note_stmt is not None or self.hint_stmt is not None:
        yield &quot;&quot;

    if self.note_stmt is not None:
        yield _prefix_with_indent(
            self.note_stmt,
            console,
            prefix=&quot;[magenta bold]note[/]: &quot;,
            indent=&quot;      &quot;,
        )
    if self.hint_stmt is not None:
        yield _prefix_with_indent(
            self.hint_stmt,
            console,
            prefix=&quot;[cyan bold]hint[/]: &quot;,
            indent=&quot;      &quot;,
        )

    if self.link is not None:
        yield &quot;&quot;
        yield f&quot;Link: {self.link}&quot;
</pre></div>
</div>
</section>
<section id="id3">
<h1><a class="headerlink" href="#id3" title="Link to this heading"></a></h1>
</section>
<section id="actual-errors">
<h1>Actual Errors<a class="headerlink" href="#actual-errors" title="Link to this heading"></a></h1>
</section>
<section id="id4">
<h1><a class="headerlink" href="#id4" title="Link to this heading"></a></h1>
<p>class ConfigurationError(PipError):
“””General exception in configuration”””</p>
<p>class InstallationError(PipError):
“””General exception during installation”””</p>
<p>class FailedToPrepareCandidate(InstallationError):
“””Raised when we fail to prepare a candidate (i.e. fetch and generate metadata).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is intentionally not a diagnostic error, since the output will be presented
above this error, when this occurs. This should instead present information to the
user.
&quot;&quot;&quot;

def __init__(
    self, *, package_name: str, requirement_chain: str, failed_step: str
) -&gt; None:
    super().__init__(f&quot;Failed to build &#39;{package_name}&#39; when {failed_step.lower()}&quot;)
    self.package_name = package_name
    self.requirement_chain = requirement_chain
    self.failed_step = failed_step
</pre></div>
</div>
<p>class MissingPyProjectBuildRequires(DiagnosticPipError):
“””Raised when pyproject.toml has <code class="docutils literal notranslate"><span class="pre">build-system</span></code>, but no <code class="docutils literal notranslate"><span class="pre">build-system.requires</span></code>.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>reference = &quot;missing-pyproject-build-system-requires&quot;

def __init__(self, *, package: str) -&gt; None:
    super().__init__(
        message=f&quot;Can not process {escape(package)}&quot;,
        context=Text(
            &quot;This package has an invalid pyproject.toml file.\n&quot;
            &quot;The [build-system] table is missing the mandatory `requires` key.&quot;
        ),
        note_stmt=&quot;This is an issue with the package mentioned above, not pip.&quot;,
        hint_stmt=Text(&quot;See PEP 518 for the detailed specification.&quot;),
    )
</pre></div>
</div>
<p>class InvalidPyProjectBuildRequires(DiagnosticPipError):
“””Raised when pyproject.toml an invalid <code class="docutils literal notranslate"><span class="pre">build-system.requires</span></code>.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>reference = &quot;invalid-pyproject-build-system-requires&quot;

def __init__(self, *, package: str, reason: str) -&gt; None:
    super().__init__(
        message=f&quot;Can not process {escape(package)}&quot;,
        context=Text(
            &quot;This package has an invalid `build-system.requires` key in &quot;
            f&quot;pyproject.toml.\n{reason}&quot;
        ),
        note_stmt=&quot;This is an issue with the package mentioned above, not pip.&quot;,
        hint_stmt=Text(&quot;See PEP 518 for the detailed specification.&quot;),
    )
</pre></div>
</div>
<p>class NoneMetadataError(PipError):
“””Raised when accessing a Distribution’s “METADATA” or “PKG-INFO”.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This signifies an inconsistency, when the Distribution claims to have
the metadata file (if not, raise ``FileNotFoundError`` instead), but is
not actually able to produce its content. This may be due to permission
errors.
&quot;&quot;&quot;

def __init__(
    self,
    dist: BaseDistribution,
    metadata_name: str,
) -&gt; None:
    &quot;&quot;&quot;
    :param dist: A Distribution object.
    :param metadata_name: The name of the metadata being accessed
        (can be &quot;METADATA&quot; or &quot;PKG-INFO&quot;).
    &quot;&quot;&quot;
    self.dist = dist
    self.metadata_name = metadata_name

def __str__(self) -&gt; str:
    # Use `dist` in the error message because its stringification
    # includes more information, like the version and location.
    return f&quot;None {self.metadata_name} metadata found for distribution: {self.dist}&quot;
</pre></div>
</div>
<p>class UserInstallationInvalid(InstallationError):
“””A –user install is requested on an environment without user site.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __str__(self) -&gt; str:
    return &quot;User base directory is not specified&quot;
</pre></div>
</div>
<p>class InvalidSchemeCombination(InstallationError):
def <strong>str</strong>(self) -&gt; str:
before = “, “.join(str(a) for a in self.args[:-1])
return f”Cannot set {before} and {self.args[-1]} together”</p>
<p>class DistributionNotFound(InstallationError):
“””Raised when a distribution cannot be found to satisfy a requirement”””</p>
<p>class RequirementsFileParseError(InstallationError):
“””Raised when a general error occurs parsing a requirements file line.”””</p>
<p>class BestVersionAlreadyInstalled(PipError):
“””Raised when the most up-to-date version of a package is already
installed.”””</p>
<p>class BadCommand(PipError):
“””Raised when virtualenv or a command is not found”””</p>
<p>class CommandError(PipError):
“””Raised when there is an error in command-line arguments”””</p>
<p>class PreviousBuildDirError(PipError):
“””Raised when there’s a previous conflicting build directory”””</p>
<p>class NetworkConnectionError(PipError):
“””HTTP connection error”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    error_msg: str,
    response: Response | None = None,
    request: Request | None = None,
) -&gt; None:
    &quot;&quot;&quot;
    Initialize NetworkConnectionError with  `request` and `response`
    objects.
    &quot;&quot;&quot;
    self.response = response
    self.request = request
    self.error_msg = error_msg
    if (
        self.response is not None
        and not self.request
        and hasattr(response, &quot;request&quot;)
    ):
        self.request = self.response.request
    super().__init__(error_msg, response, request)

def __str__(self) -&gt; str:
    return str(self.error_msg)
</pre></div>
</div>
<p>class InvalidWheelFilename(InstallationError):
“””Invalid wheel filename.”””</p>
<p>class UnsupportedWheel(InstallationError):
“””Unsupported wheel.”””</p>
<p>class InvalidWheel(InstallationError):
“””Invalid (e.g. corrupt) wheel.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, location: str, name: str):
    self.location = location
    self.name = name

def __str__(self) -&gt; str:
    return f&quot;Wheel &#39;{self.name}&#39; located at {self.location} is invalid.&quot;
</pre></div>
</div>
<p>class MetadataInconsistent(InstallationError):
“””Built metadata contains inconsistent information.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is raised when the metadata contains values (e.g. name and version)
that do not match the information previously obtained from sdist filename,
user-supplied ``#egg=`` value, or an install requirement name.
&quot;&quot;&quot;

def __init__(
    self, ireq: InstallRequirement, field: str, f_val: str, m_val: str
) -&gt; None:
    self.ireq = ireq
    self.field = field
    self.f_val = f_val
    self.m_val = m_val

def __str__(self) -&gt; str:
    return (
        f&quot;Requested {self.ireq} has inconsistent {self.field}: &quot;
        f&quot;expected {self.f_val!r}, but metadata has {self.m_val!r}&quot;
    )
</pre></div>
</div>
<p>class MetadataInvalid(InstallationError):
“””Metadata is invalid.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, ireq: InstallRequirement, error: str) -&gt; None:
    self.ireq = ireq
    self.error = error

def __str__(self) -&gt; str:
    return f&quot;Requested {self.ireq} has invalid metadata: {self.error}&quot;
</pre></div>
</div>
<p>class InstallationSubprocessError(DiagnosticPipError, InstallationError):
“””A subprocess call failed.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>reference = &quot;subprocess-exited-with-error&quot;

def __init__(
    self,
    *,
    command_description: str,
    exit_code: int,
    output_lines: list[str] | None,
) -&gt; None:
    if output_lines is None:
        output_prompt = Text(&quot;No available output.&quot;)
    else:
        output_prompt = (
            Text.from_markup(f&quot;[red][{len(output_lines)} lines of output][/]\n&quot;)
            + Text(&quot;&quot;.join(output_lines))
            + Text.from_markup(R&quot;[red]\[end of output][/]&quot;)
        )

    super().__init__(
        message=(
            f&quot;[green]{escape(command_description)}[/] did not run successfully.\n&quot;
            f&quot;exit code: {exit_code}&quot;
        ),
        context=output_prompt,
        hint_stmt=None,
        note_stmt=(
            &quot;This error originates from a subprocess, and is likely not a &quot;
            &quot;problem with pip.&quot;
        ),
    )

    self.command_description = command_description
    self.exit_code = exit_code

def __str__(self) -&gt; str:
    return f&quot;{self.command_description} exited with {self.exit_code}&quot;
</pre></div>
</div>
<p>class MetadataGenerationFailed(DiagnosticPipError, InstallationError):
reference = “metadata-generation-failed”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    *,
    package_details: str,
) -&gt; None:
    super().__init__(
        message=&quot;Encountered error while generating package metadata.&quot;,
        context=escape(package_details),
        hint_stmt=&quot;See above for details.&quot;,
        note_stmt=&quot;This is an issue with the package mentioned above, not pip.&quot;,
    )

def __str__(self) -&gt; str:
    return &quot;metadata generation failed&quot;
</pre></div>
</div>
<p>class HashErrors(InstallationError):
“””Multiple HashError instances rolled into one for reporting”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self) -&gt; None:
    self.errors: list[HashError] = []

def append(self, error: HashError) -&gt; None:
    self.errors.append(error)

def __str__(self) -&gt; str:
    lines = []
    self.errors.sort(key=lambda e: e.order)
    for cls, errors_of_cls in groupby(self.errors, lambda e: e.__class__):
        lines.append(cls.head)
        lines.extend(e.body() for e in errors_of_cls)
    if lines:
        return &quot;\n&quot;.join(lines)
    return &quot;&quot;

def __bool__(self) -&gt; bool:
    return bool(self.errors)
</pre></div>
</div>
<p>class HashError(InstallationError):
“””
A failure to verify a package against known-good hashes</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:cvar order: An int sorting hash exception classes by difficulty of
    recovery (lower being harder), so the user doesn&#39;t bother fretting
    about unpinned packages when he has deeper issues, like VCS
    dependencies, to deal with. Also keeps error reports in a
    deterministic order.
:cvar head: A section heading for display above potentially many
    exceptions of this kind
:ivar req: The InstallRequirement that triggered this error. This is
    pasted on after the exception is instantiated, because it&#39;s not
    typically available earlier.

&quot;&quot;&quot;

req: InstallRequirement | None = None
head = &quot;&quot;
order: int = -1

def body(self) -&gt; str:
    &quot;&quot;&quot;Return a summary of me for display under the heading.

    This default implementation simply prints a description of the
    triggering requirement.

    :param req: The InstallRequirement that provoked this error, with
        its link already populated by the resolver&#39;s _populate_link().

    &quot;&quot;&quot;
    return f&quot;    {self._requirement_name()}&quot;

def __str__(self) -&gt; str:
    return f&quot;{self.head}\n{self.body()}&quot;

def _requirement_name(self) -&gt; str:
    &quot;&quot;&quot;Return a description of the requirement that triggered me.

    This default implementation returns long description of the req, with
    line numbers

    &quot;&quot;&quot;
    return str(self.req) if self.req else &quot;unknown package&quot;
</pre></div>
</div>
<p>class VcsHashUnsupported(HashError):
“””A hash was provided for a version-control-system-based requirement, but
we don’t have a method for hashing those.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>order = 0
head = (
    &quot;Can&#39;t verify hashes for these requirements because we don&#39;t &quot;
    &quot;have a way to hash version control repositories:&quot;
)
</pre></div>
</div>
<p>class DirectoryUrlHashUnsupported(HashError):
“””A hash was provided for a version-control-system-based requirement, but
we don’t have a method for hashing those.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>order = 1
head = (
    &quot;Can&#39;t verify hashes for these file:// requirements because they &quot;
    &quot;point to directories:&quot;
)
</pre></div>
</div>
<p>class HashMissing(HashError):
“””A hash was needed for a requirement but is absent.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>order = 2
head = (
    &quot;Hashes are required in --require-hashes mode, but they are &quot;
    &quot;missing from some requirements. Here is a list of those &quot;
    &quot;requirements along with the hashes their downloaded archives &quot;
    &quot;actually had. Add lines like these to your requirements files to &quot;
    &quot;prevent tampering. (If you did not enable --require-hashes &quot;
    &quot;manually, note that it turns on automatically when any package &quot;
    &quot;has a hash.)&quot;
)

def __init__(self, gotten_hash: str) -&gt; None:
    &quot;&quot;&quot;
    :param gotten_hash: The hash of the (possibly malicious) archive we
        just downloaded
    &quot;&quot;&quot;
    self.gotten_hash = gotten_hash

def body(self) -&gt; str:
    # Dodge circular import.
    from pip._internal.utils.hashes import FAVORITE_HASH

    package = None
    if self.req:
        # In the case of URL-based requirements, display the original URL
        # seen in the requirements file rather than the package name,
        # so the output can be directly copied into the requirements file.
        package = (
            self.req.original_link
            if self.req.is_direct
            # In case someone feeds something downright stupid
            # to InstallRequirement&#39;s constructor.
            else getattr(self.req, &quot;req&quot;, None)
        )
    return &quot;    {} --hash={}:{}&quot;.format(
        package or &quot;unknown package&quot;, FAVORITE_HASH, self.gotten_hash
    )
</pre></div>
</div>
<p>class HashUnpinned(HashError):
“””A requirement had a hash specified but was not pinned to a specific
version.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>order = 3
head = (
    &quot;In --require-hashes mode, all requirements must have their &quot;
    &quot;versions pinned with ==. These do not:&quot;
)
</pre></div>
</div>
<p>class HashMismatch(HashError):
“””
Distribution file hash values don’t match.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:ivar package_name: The name of the package that triggered the hash
    mismatch. Feel free to write to this after the exception is raise to
    improve its error message.

&quot;&quot;&quot;

order = 4
head = (
    &quot;THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS &quot;
    &quot;FILE. If you have updated the package versions, please update &quot;
    &quot;the hashes. Otherwise, examine the package contents carefully; &quot;
    &quot;someone may have tampered with them.&quot;
)

def __init__(self, allowed: dict[str, list[str]], gots: dict[str, _Hash]) -&gt; None:
    &quot;&quot;&quot;
    :param allowed: A dict of algorithm names pointing to lists of allowed
        hex digests
    :param gots: A dict of algorithm names pointing to hashes we
        actually got from the files under suspicion
    &quot;&quot;&quot;
    self.allowed = allowed
    self.gots = gots

def body(self) -&gt; str:
    return f&quot;    {self._requirement_name()}:\n{self._hash_comparison()}&quot;

def _hash_comparison(self) -&gt; str:
    &quot;&quot;&quot;
    Return a comparison of actual and expected hash values.

    Example::

           Expected sha256 abcdeabcdeabcdeabcdeabcdeabcdeabcdeabcdeabcde
                        or 123451234512345123451234512345123451234512345
                Got        bcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdefbcdef

    &quot;&quot;&quot;

    def hash_then_or(hash_name: str) -&gt; chain[str]:
        # For now, all the decent hashes have 6-char names, so we can get
        # away with hard-coding space literals.
        return chain([hash_name], repeat(&quot;    or&quot;))

    lines: list[str] = []
    for hash_name, expecteds in self.allowed.items():
        prefix = hash_then_or(hash_name)
        lines.extend((f&quot;        Expected {next(prefix)} {e}&quot;) for e in expecteds)
        lines.append(
            f&quot;             Got        {self.gots[hash_name].hexdigest()}\n&quot;
        )
    return &quot;\n&quot;.join(lines)
</pre></div>
</div>
<p>class UnsupportedPythonVersion(InstallationError):
“””Unsupported python version according to Requires-Python package
metadata.”””</p>
<p>class ConfigurationFileCouldNotBeLoaded(ConfigurationError):
“””When there are errors while loading a configuration file”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    reason: str = &quot;could not be loaded&quot;,
    fname: str | None = None,
    error: configparser.Error | None = None,
) -&gt; None:
    super().__init__(error)
    self.reason = reason
    self.fname = fname
    self.error = error

def __str__(self) -&gt; str:
    if self.fname is not None:
        message_part = f&quot; in {self.fname}.&quot;
    else:
        assert self.error is not None
        message_part = f&quot;.\n{self.error}\n&quot;
    return f&quot;Configuration file {self.reason}{message_part}&quot;
</pre></div>
</div>
<p>_DEFAULT_EXTERNALLY_MANAGED_ERROR = f”””<br />
The Python environment under {sys.prefix} is managed externally, and may not be
manipulated by the user. Please use specific tooling from the distributor of
the Python installation to interact with this environment instead.
“””</p>
<p>class ExternallyManagedEnvironment(DiagnosticPipError):
“””The current environment is externally managed.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>This is raised when the current environment is externally managed, as
defined by `PEP 668`_. The ``EXTERNALLY-MANAGED`` configuration is checked
and displayed when the error is bubbled up to the user.

:param error: The error message read from ``EXTERNALLY-MANAGED``.
&quot;&quot;&quot;

reference = &quot;externally-managed-environment&quot;

def __init__(self, error: str | None) -&gt; None:
    if error is None:
        context = Text(_DEFAULT_EXTERNALLY_MANAGED_ERROR)
    else:
        context = Text(error)
    super().__init__(
        message=&quot;This environment is externally managed&quot;,
        context=context,
        note_stmt=(
            &quot;If you believe this is a mistake, please contact your &quot;
            &quot;Python installation or OS distribution provider. &quot;
            &quot;You can override this, at the risk of breaking your Python &quot;
            &quot;installation or OS, by passing --break-system-packages.&quot;
        ),
        hint_stmt=Text(&quot;See PEP 668 for the detailed specification.&quot;),
    )

@staticmethod
def _iter_externally_managed_error_keys() -&gt; Iterator[str]:
    # LC_MESSAGES is in POSIX, but not the C standard. The most common
    # platform that does not implement this category is Windows, where
    # using other categories for console message localization is equally
    # unreliable, so we fall back to the locale-less vendor message. This
    # can always be re-evaluated when a vendor proposes a new alternative.
    try:
        category = locale.LC_MESSAGES
    except AttributeError:
        lang: str | None = None
    else:
        lang, _ = locale.getlocale(category)
    if lang is not None:
        yield f&quot;Error-{lang}&quot;
        for sep in (&quot;-&quot;, &quot;_&quot;):
            before, found, _ = lang.partition(sep)
            if not found:
                continue
            yield f&quot;Error-{before}&quot;
    yield &quot;Error&quot;

@classmethod
def from_config(
    cls,
    config: pathlib.Path | str,
) -&gt; ExternallyManagedEnvironment:
    parser = configparser.ConfigParser(interpolation=None)
    try:
        parser.read(config, encoding=&quot;utf-8&quot;)
        section = parser[&quot;externally-managed&quot;]
        for key in cls._iter_externally_managed_error_keys():
            with contextlib.suppress(KeyError):
                return cls(section[key])
    except KeyError:
        pass
    except (OSError, UnicodeDecodeError, configparser.ParsingError):
        from pip._internal.utils._log import VERBOSE

        exc_info = logger.isEnabledFor(VERBOSE)
        logger.warning(&quot;Failed to read %s&quot;, config, exc_info=exc_info)
    return cls(None)
</pre></div>
</div>
<p>class UninstallMissingRecord(DiagnosticPipError):
reference = “uninstall-no-record-file”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, *, distribution: BaseDistribution) -&gt; None:
    installer = distribution.installer
    if not installer or installer == &quot;pip&quot;:
        dep = f&quot;{distribution.raw_name}=={distribution.version}&quot;
        hint = Text.assemble(
            &quot;You might be able to recover from this via: &quot;,
            (f&quot;pip install --force-reinstall --no-deps {dep}&quot;, &quot;green&quot;),
        )
    else:
        hint = Text(
            f&quot;The package was installed by {installer}. &quot;
            &quot;You should check if it can uninstall the package.&quot;
        )

    super().__init__(
        message=Text(f&quot;Cannot uninstall {distribution}&quot;),
        context=(
            &quot;The package&#39;s contents are unknown: &quot;
            f&quot;no RECORD file was found for {distribution.raw_name}.&quot;
        ),
        hint_stmt=hint,
    )
</pre></div>
</div>
<p>class LegacyDistutilsInstall(DiagnosticPipError):
reference = “uninstall-distutils-installed-package”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, *, distribution: BaseDistribution) -&gt; None:
    super().__init__(
        message=Text(f&quot;Cannot uninstall {distribution}&quot;),
        context=(
            &quot;It is a distutils installed project and thus we cannot accurately &quot;
            &quot;determine which files belong to it which would lead to only a partial &quot;
            &quot;uninstall.&quot;
        ),
        hint_stmt=None,
    )
</pre></div>
</div>
<p>class InvalidInstalledPackage(DiagnosticPipError):
reference = “invalid-installed-package”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(
    self,
    *,
    dist: BaseDistribution,
    invalid_exc: InvalidRequirement | InvalidVersion,
) -&gt; None:
    installed_location = dist.installed_location

    if isinstance(invalid_exc, InvalidRequirement):
        invalid_type = &quot;requirement&quot;
    else:
        invalid_type = &quot;version&quot;

    super().__init__(
        message=Text(
            f&quot;Cannot process installed package {dist} &quot;
            + (f&quot;in {installed_location!r} &quot; if installed_location else &quot;&quot;)
            + f&quot;because it has an invalid {invalid_type}:\n{invalid_exc.args[0]}&quot;
        ),
        context=(
            &quot;Starting with pip 24.1, packages with invalid &quot;
            f&quot;{invalid_type}s can not be processed.&quot;
        ),
        hint_stmt=&quot;To proceed this package must be uninstalled.&quot;,
    )
</pre></div>
</div>
<p>class IncompleteDownloadError(DiagnosticPipError):
“””Raised when the downloader receives fewer bytes than advertised
in the Content-Length header.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>reference = &quot;incomplete-download&quot;

def __init__(self, download: _FileDownload) -&gt; None:
    # Dodge circular import.
    from pip._internal.utils.misc import format_size

    assert download.size is not None
    download_status = (
        f&quot;{format_size(download.bytes_received)}/{format_size(download.size)}&quot;
    )
    if download.reattempts:
        retry_status = f&quot;after {download.reattempts + 1} attempts &quot;
        hint = &quot;Use --resume-retries to configure resume attempt limit.&quot;
    else:
        # Download retrying is not enabled.
        retry_status = &quot;&quot;
        hint = &quot;Consider using --resume-retries to enable download resumption.&quot;
    message = Text(
        f&quot;Download failed {retry_status}because not enough bytes &quot;
        f&quot;were received ({download_status})&quot;
    )

    super().__init__(
        message=message,
        context=f&quot;URL: {download.link.redacted_url}&quot;,
        hint_stmt=hint,
        note_stmt=&quot;This is an issue with network connectivity, not pip.&quot;,
    )
</pre></div>
</div>
<p>class ResolutionTooDeepError(DiagnosticPipError):
“””Raised when the dependency resolver exceeds the maximum recursion depth.”””</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>reference = &quot;resolution-too-deep&quot;

def __init__(self) -&gt; None:
    super().__init__(
        message=&quot;Dependency resolution exceeded maximum depth&quot;,
        context=(
            &quot;Pip cannot resolve the current dependencies as the dependency graph &quot;
            &quot;is too complex for pip to solve efficiently.&quot;
        ),
        hint_stmt=(
            &quot;Try adding lower bounds to constrain your dependencies, &quot;
            &quot;for example: &#39;package&gt;=2.0.0&#39; instead of just &#39;package&#39;. &quot;
        ),
        link=&quot;https://pip.pypa.io/en/stable/topics/dependency-resolution/#handling-resolution-too-deep-errors&quot;,
    )
</pre></div>
</div>
<p>class InstallWheelBuildError(DiagnosticPipError):
reference = “failed-wheel-build-for-install”</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>def __init__(self, failed: list[InstallRequirement]) -&gt; None:
    super().__init__(
        message=(
            &quot;Failed to build installable wheels for some &quot;
            &quot;pyproject.toml based projects&quot;
        ),
        context=&quot;, &quot;.join(r.name for r in failed),  # type: ignore
        hint_stmt=None,
    )
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Adam Worsnip.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>